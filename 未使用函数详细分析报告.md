# 未使用函数分析报告

## HistoryManager 函数分析

### 1. setHistoryLimit(int limit)
**定义位置**: `Analysis/src/application/history/history_manager.cpp:104-115`
**声明位置**: `Analysis/src/application/history/history_manager.h:86`

**搜索结果**:
- ✗ 无实际调用（只在定义处出现）
- ✓ 在文档中有提及 (`设计文档/撤销重做功能实现文档.md`)
- 在头文件中有完整实现

**Qt属性系统**: ✗ 不是Q_PROPERTY

**公共API评估**: 
- 这是一个公共方法，可能被客户代码使用
- 提供了调整历史深度的机制，符合配置需求
- 内部有验证逻辑（limit必须>0）

**删除建议**: **保留** - 这是配置接口，虽然当前未使用但属于公共API

---

### 2. undoCount() const
**定义位置**: `Analysis/src/application/history/history_manager.cpp:92`
**声明位置**: `Analysis/src/application/history/history_manager.h:69`

**搜索结果**:
- ✗ 无实际调用
- 在文档中有提及 (`设计文档/撤销重做功能实现文档.md:870`)
- 文档显示用于调试目的

**Qt属性系统**: ✗ 不是Q_PROPERTY

**公共API评估**:
- 这是一个查询方法，用于获取撤销栈大小
- 在UI中可能需要显示撤销历史深度信息
- 配对关系：有 canUndo()（已使用），但 undoCount() 未使用

**删除建议**: **可删除** - 功能可由 canUndo() + 内部 undoStack 的监控替代，当前无实际需求

---

### 3. redoCount() const
**定义位置**: `Analysis/src/application/history/history_manager.cpp:94`
**声明位置**: `Analysis/src/application/history/history_manager.h:75`

**搜索结果**:
- ✗ 无实际调用
- 与 undoCount() 对称

**Qt属性系统**: ✗ 不是Q_PROPERTY

**公共API评估**:
- 与 undoCount() 对称，同样是查询方法
- 配对关系：有 canRedo()（已使用），但 redoCount() 未使用

**删除建议**: **可删除** - 功能可由 canRedo() 替代，当前无实际需求

---

### 4. historyLimit() const
**定义位置**: `Analysis/src/application/history/history_manager.cpp:117`
**声明位置**: `Analysis/src/application/history/history_manager.h:92`

**搜索结果**:
- ✗ 无实际调用

**Qt属性系统**: ✗ 不是Q_PROPERTY

**公共API评估**:
- 这是 setHistoryLimit() 的配套getter
- 用于获取当前设置的历史深度限制
- 如果保留 setHistoryLimit()，则应保留此getter保持API完整

**删除建议**: **保留或与setHistoryLimit()一起删除** - 通常getter/setter应该配对出现

---

## AlgorithmResult 函数分析

### 1. historyResult(const QString&, int) - OutputKeys 命名空间
**定义位置**: `Analysis/src/domain/algorithm/algorithm_result.h:100-102` (inline函数)

**搜索结果**:
- ✓ 在 algorithm_coordinator.cpp 中有相关的 OutputKeys::latestResult() 调用
- ✗ 实际没有找到 OutputKeys::historyResult() 的直接调用
- 在头文件文档注释中有使用示例

**Qt属性系统**: ✗ 不是Q_PROPERTY（这是命名空间函数，不是成员函数）

**公共API评估**:
- 这是一个键名生成函数，用于在 AlgorithmContext 中存储算法历史结果
- 设计上是预留的，但当前业务逻辑未实现历史结果存储功能
- 配对函数：latestResult() 已使用，historyResult() 未使用

**删除建议**: **可删除** - 历史结果存储功能当前未实现，可在需要时再添加

---

### 2. algorithmKey() const
**定义位置**: `Analysis/src/domain/algorithm/algorithm_result.h:248`
**返回值**: 算法标识字符串（如"differentiation"）

**搜索结果**:
- ✗ 无实际调用

**用法分析**:
- 虽然未被调用，但这是结果对象的核心元数据
- 用于追踪结果来自哪个算法
- 设计上是信息完整性的一部分

**公共API评估**:
- 属于结果对象的标准元数据
- 可能被客户代码需要（用于日志、调试、结果路由）

**删除建议**: **保留** - 虽未使用但是核心元数据，属于标准API

---

### 3. timestamp() const
**定义位置**: `Analysis/src/domain/algorithm/algorithm_result.h:251`
**返回值**: QDateTime（生成时间）

**搜索结果**:
- ✗ 无实际调用

**用法分析**:
- 用于记录算法执行时间
- 可用于结果顺序追踪和时间戳关联
- 设计上用于审计和日志记录

**公共API评估**:
- 属于结果的标准元数据
- 在数据分析和结果验证中可能需要

**删除建议**: **保留** - 虽未使用但是标准元数据，属于信息完整性API

---

### 4. addCurve(const ThermalCurve&)
**定义位置**: `Analysis/src/domain/algorithm/algorithm_result.h:258-260`
**实现**: 追加曲线到 m_curves 列表

**搜索结果**:
- ✗ 无实际调用（代码库中使用的是 setCurve() 而非 addCurve()）
- ✓ 配对方法 setCurve() 在4个算法中被调用

**用法对比**:
```cpp
// 在算法中使用的是 setCurve()（会清空列表）
result.setCurve(outputCurve);  // 已在以下算法中使用：
// - DifferentiationAlgorithm
// - IntegrationAlgorithm
// - MovingAverageFilterAlgorithm
// - BaselineCorrectionAlgorithm

// addCurve() 用于添加多条曲线（Composite输出），但未被使用
result.addCurve(curve);  // 未使用
```

**公共API评估**:
- 这是Composite结果类型的接口（用于多曲线输出）
- 当前算法实现中没有使用此方法
- setCurve() 是替代品，但语义不同（addCurve 是追加，setCurve 是替换）

**删除建议**: **可删除** - Composite结果类型的多曲线功能当前未实现，待需要时再实现

---

### 5. primaryCurve() const
**定义位置**: `Analysis/src/domain/algorithm/algorithm_result.h:279-281`
**返回值**: 第一条曲线的指针（用于单曲线结果）

**搜索结果**:
- ✗ 无实际调用
- 设计上用于快速获取主曲线

**用法分析**:
- 这是 curves().first() 的便捷方法
- 带有空指针安全检查

**公共API评估**:
- 提供了便利的访问方式
- curves() 已被使用，但 primaryCurve() 未被使用

**删除建议**: **可删除** - 功能已被 curves() 覆盖，可用 curves().isEmpty() ? nullptr : &curves().first() 替代

---

### 6. setMarkers(const QList<QPointF>&)
**定义位置**: `Analysis/src/domain/algorithm/algorithm_result.h:295`
**实现**: 设置标注点列表（直接替换）

**搜索结果**:
- ✗ 无实际调用
- ✓ 配对方法：addMarker() 在 BaselineCorrectionAlgorithm 中被调用

**用法对比**:
```cpp
// 已使用的方式
result.addMarker(point1, "基线起点");  // BaselineCorrectionAlgorithm:181-182
result.addMarker(point2, "基线终点");

// 未使用的方式
result.setMarkers(markerList);  // 未使用
```

**语义区别**:
- addMarker(): 逐个添加单个标注点，支持标签
- setMarkers(): 批量设置整个标注点列表（适合从其他数据结构转换）

**删除建议**: **可删除** - 功能可由 addMarker() 替代，当前使用模式是逐个添加

---

### 7. setRegions(const QList<QPolygonF>&)
**定义位置**: `Analysis/src/domain/algorithm/algorithm_result.h:309`
**实现**: 设置区域列表（直接替换）

**搜索结果**:
- ✗ 无实际调用
- ✓ 配对方法：addRegion() 可被调用但当前未被使用

**用法分析**:
- 设计上用于设置区域（如峰面积的积分区域）
- 类似于 setMarkers()，是批量设置方法

**功能状态**:
- 区域输出功能在 handleRegionResult() 中被提及为 TODO
- 整个区域相关功能当前未实现

**删除建议**: **可删除** - 区域功能当前未实现，可在需要时重新添加

---

### 8. regions() const
**定义位置**: `Analysis/src/domain/algorithm/algorithm_result.h:310`
**返回值**: 所有区域列表

**搜索结果**:
- ✗ 无实际调用
- 与 setRegions() 配对

**功能状态**:
- 这是 setRegions() 的配套getter
- 区域功能整体未实现

**删除建议**: **可删除** - 与 setRegions() 一起删除，待区域功能实现时重新添加

---

### 9. setPeakPosition(const QPointF&)
**定义位置**: `Analysis/src/domain/algorithm/algorithm_result.h:363-365`
**实现**: 在元数据中设置峰位置

**搜索结果**:
- ✗ 无实际调用
- 应该在PeakAreaAlgorithm中使用，但未找到调用

**设计意图**:
- 用于记录峰值点坐标
- 存储在元数据中：m_meta[MetaKeys::PeakPosition] = pos

**功能重复**:
- setMeta(MetaKeys::PeakPosition, pos) 可以达到相同目的
- 这是便利方法

**删除建议**: **可删除** - 功能已被 setMeta() 覆盖，可用 result.setMeta(MetaKeys::PeakPosition, pos) 替代

---

### 10. peakPosition() const
**定义位置**: `Analysis/src/domain/algorithm/algorithm_result.h:367-369`
**返回值**: 峰位置坐标

**搜索结果**:
- ✗ 无实际调用
- setPeakPosition() 的配套getter

**功能状态**:
- 与 setPeakPosition() 配对
- 可由 metaValue<QPointF>(MetaKeys::PeakPosition) 替代

**删除建议**: **可删除** - 与 setPeakPosition() 一起删除，可用元数据方法替代

---

### 11. signalType() const (AlgorithmResult)
**定义位置**: `Analysis/src/domain/algorithm/algorithm_result.h:375-377`
**返回值**: SignalType 枚举

**搜索结果**:
- ✗ 无实际调用（grep结果中的 signalType() 是 ThermalCurve 的方法，不是 AlgorithmResult）

**设计意图**:
- 记录结果曲线的信号类型（Raw/Derivative/Baseline等）
- setSignalType() 在 baseline_correction_algorithm.cpp 中会被调用

**功能重复**:
- 可由 metaValue<SignalType>(MetaKeys::SignalType) 替代
- setSignalType() 已实现，但 signalType() getter 未被使用

**删除建议**: **可删除** - 功能已被元数据方法覆盖

---

## 总结与删除建议

### HistoryManager

| 函数 | 调用情况 | 公共API | 建议 | 理由 |
|------|--------|--------|------|------|
| setHistoryLimit(int) | 无调用 | 是 | **保留** | 配置接口，属于公共API |
| undoCount() | 无调用 | 是 | **可删除** | 功能由 canUndo() 替代，无实际需求 |
| redoCount() | 无调用 | 是 | **可删除** | 功能由 canRedo() 替代，无实际需求 |
| historyLimit() | 无调用 | 是 | **保留或配对删除** | setter getter应配对，或与setHistoryLimit一起删除 |

### AlgorithmResult

| 函数 | 调用情况 | 功能状态 | 建议 | 理由 |
|------|--------|---------|------|------|
| OutputKeys::historyResult() | 无调用 | 未实现 | **可删除** | 历史结果存储功能未实现 |
| algorithmKey() | 无调用 | 核心元数据 | **保留** | 标准API，用于结果追踪 |
| timestamp() | 无调用 | 核心元数据 | **保留** | 标准API，用于审计 |
| addCurve() | 无调用 | 未实现 | **可删除** | Composite多曲线功能未实现 |
| primaryCurve() | 无调用 | 重复功能 | **可删除** | curves() 已覆盖此功能 |
| setMarkers() | 无调用 | 重复功能 | **可删除** | addMarker() 已满足需求 |
| setRegions() | 无调用 | 未实现 | **可删除** | 区域功能未实现 |
| regions() | 无调用 | 未实现 | **可删除** | 与setRegions()配对删除 |
| setPeakPosition() | 无调用 | 重复功能 | **可删除** | setMeta() 已覆盖 |
| peakPosition() | 无调用 | 重复功能 | **可删除** | metaValue() 已覆盖 |
| signalType() | 无调用 | 重复功能 | **可删除** | metaValue() 已覆盖 |

---

## 删除优先级

### 高优先级（立即删除）
1. **undoCount()** 和 **redoCount()** - 无实际用途，重复功能
2. **addCurve()** - 待实现功能，当前未使用
3. **setRegions()** 和 **regions()** - 待实现功能，无调用
4. **setPeakPosition()** 和 **peakPosition()** - 功能重复

### 中优先级（可考虑删除）
1. **primaryCurve()** - 便利方法，但功能重复
2. **setMarkers()** - 便利方法，但功能重复
3. **historyLimit()** - 根据是否保留 setHistoryLimit() 而定
4. **signalType()** - 功能完全重复

### 低优先级（建议保留）
1. **setHistoryLimit()** - 公共配置API
2. **algorithmKey()** - 核心元数据API
3. **timestamp()** - 核心元数据API
4. **OutputKeys::historyResult()** - 预留接口，设计完整性

