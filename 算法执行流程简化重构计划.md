# 算法执行流程简化重构计划

## 一、当前架构分析

### 1.1 代码量统计
- **AlgorithmCoordinator.h**: 278 行
- **AlgorithmCoordinator.cpp**: 445 行
- **总计**: 723 行

### 1.2 当前复杂度分析

**复杂的状态管理**：
```cpp
enum class PendingPhase {
    None,
    AwaitParameters,   // 等待参数输入
    AwaitPoints        // 等待点选
};

struct MetadataPendingRequest {
    QString algorithmName;
    QString curveId;
    QVariantMap parameters;
    bool needsPointSelection = false;
    int requiredPointCount = 0;
    QString pointSelectionHint;
    QVector<ThermalDataPoint> collectedPoints;
    PendingPhase phase = PendingPhase::None;  // 状态机
};
```

**复杂的信号链**：
- `requestGenericParameterDialog()` - 请求参数对话框
- `handleGenericParameterSubmission()` - 处理参数提交
- `requestPointSelection()` - 请求点选
- `handlePointSelectionResult()` - 处理点选结果
- `executeAlgorithm()` - 最终执行

**多个执行入口**：
- `runByName()` - 元数据驱动执行（方案B）
- `handleGenericParameterSubmission()` - 参数提交后执行
- `handlePointSelectionResult()` - 点选完成后执行

---

## 二、新设计方案：线性流程架构

### 2.1 核心思想

**用户的新思路**：
```
用户点击算法
  ↓
【判断1】是否有参数弹窗？
  → 有 → 弹出对话框，等待用户输入
  → 无 → 跳过
  ↓
【判断2】是否有点选交互？
  → 有 → 放入待处理队列，等待用户选点
  → 无 → 直接执行
  ↓
交互完成（或无需交互）
  ↓
放入线程计算
  ↓
计算完成后，统一输出（AlgorithmResult）
```

**关键优势**：
- ✅ 流程线性，易于理解
- ✅ 只有一个待处理请求（无需复杂状态机）
- ✅ 统一的数据输入/输出
- ✅ 减少 50% 以上的代码量

---

### 2.2 简化后的结构

**简化的待处理请求**：
```cpp
struct PendingAlgorithmRequest {
    QString algorithmName;          // 算法名称
    QString curveId;                // 目标曲线ID
    QVariantMap parameters;         // 已收集的参数
    bool waitingForPoints = false;  // 是否正在等待选点
    int requiredPointCount = 0;     // 所需点数
    QString pointHint;              // 选点提示
};
```

**移除的复杂性**：
- ❌ 移除 `PendingPhase` 枚举（不需要状态机）
- ❌ 移除 `collectedPoints` 字段（点选后直接执行，无需存储）
- ❌ 移除多个中间槽函数

---

### 2.3 新的执行流程

**唯一入口方法**：
```cpp
class AlgorithmCoordinator : public QObject {
public:
    // 唯一的执行入口
    void run(const QString& algorithmName);

    // 用户完成参数输入后调用
    void submitParameters(const QVariantMap& parameters);

    // 用户完成点选后调用
    void submitPoints(const QVector<ThermalDataPoint>& points);

    // 取消当前操作
    void cancel();

signals:
    // 请求参数对话框（包含算法描述符）
    void requestParameterDialog(const QString& algorithmName, const AlgorithmDescriptor& descriptor);

    // 请求点选
    void requestPointSelection(const QString& algorithmName, int requiredCount, const QString& hint);

    // 算法开始执行
    void algorithmStarted(const QString& taskId, const QString& algorithmName);

    // 算法完成
    void algorithmFinished(const QString& algorithmName, const AlgorithmResult& result);

    // 算法失败
    void algorithmFailed(const QString& algorithmName, const QString& reason);

private:
    // 内部执行方法（所有数据就绪后调用）
    void execute();

    // 待处理的请求（只有一个）
    std::optional<PendingAlgorithmRequest> m_pending;

    // 当前执行的任务ID
    QString m_currentTaskId;
};
```

---

## 三、详细重构步骤

### Phase 1: 简化状态结构（预计减少 100 行）

**删除的代码**：
1. ❌ `enum class PendingPhase` (5 行)
2. ❌ `struct MetadataPendingRequest` 中的冗余字段 (约 3 行)
3. ❌ 复杂的阶段判断逻辑 (约 30 行)

**新增的代码**：
1. ✅ 简化的 `PendingAlgorithmRequest` 结构 (约 8 行)

**净减少**：约 30 行

---

### Phase 2: 统一执行入口（预计减少 150 行）

**删除的方法**：
1. ❌ `handleGenericParameterSubmission()` (约 50 行)
2. ❌ 复杂的 `runByName()` 逻辑 (约 80 行)
3. ❌ 多个中间状态判断 (约 40 行)

**新增的方法**：
1. ✅ 简化的 `run()` 方法 (约 40 行)
2. ✅ `submitParameters()` 方法 (约 15 行)
3. ✅ `submitPoints()` 方法 (约 15 行)
4. ✅ 统一的 `execute()` 方法 (约 30 行)

**净减少**：约 70 行

---

### Phase 3: 简化信号处理（预计减少 80 行）

**删除的信号**：
1. ❌ `requestGenericParameterDialog(QString, QVariant)` - 使用 QVariant 传递描述符（复杂）

**新增的信号**：
1. ✅ `requestParameterDialog(QString, AlgorithmDescriptor)` - 直接传递类型化的描述符

**删除的槽函数**：
1. ❌ 多个中间槽函数的复杂逻辑

**净减少**：约 80 行

---

### Phase 4: 优化异步执行集成（预计减少 50 行）

**当前问题**：
- 异步执行的信号转发逻辑冗余
- 多处重复的错误处理代码

**优化方案**：
1. ✅ 统一的错误处理入口 `handleError()`（已存在，复用）
2. ✅ 简化的结果处理 `onAlgorithmResultReady()`
3. ✅ 移除重复的状态重置代码

**净减少**：约 50 行

---

## 四、预估代码减少量

| 阶段 | 删除行数 | 新增行数 | 净减少 |
|------|---------|---------|--------|
| Phase 1: 简化状态结构 | ~40 | ~10 | ~30 |
| Phase 2: 统一执行入口 | ~170 | ~100 | ~70 |
| Phase 3: 简化信号处理 | ~100 | ~20 | ~80 |
| Phase 4: 优化异步执行 | ~60 | ~10 | ~50 |
| **总计** | **~370** | **~140** | **~230** |

**重构后代码量**：
- 当前：723 行
- 重构后：~490 行
- **减少比例**：约 32%

---

## 五、新架构的执行流程示例

### 5.1 无需交互的算法（如微分）

```cpp
// 用户点击"微分"按钮
coordinator->run("differentiation");

// 内部流程：
void AlgorithmCoordinator::run(const QString& algorithmName) {
    // 1. 获取算法描述符
    auto descriptor = getDescriptor(algorithmName);

    // 2. 判断是否需要参数弹窗
    if (descriptor.parameters.isEmpty()) {
        // 无需参数，判断是否需要点选
        if (descriptor.interaction == AlgorithmInteraction::None) {
            // 无需交互，直接执行
            execute();
            return;
        }
    }

    // ... 其他情况
}

// 直接执行
void AlgorithmCoordinator::execute() {
    // 获取活动曲线
    ThermalCurve* curve = m_curveManager->getActiveCurve();

    // 注入数据到上下文
    m_context->setValue("activeCurve", QVariant::fromValue(curve));

    // 提交到线程池执行
    QString taskId = m_algorithmManager->executeAsync(
        m_pending->algorithmName, m_context);

    m_currentTaskId = taskId;
}

// 结果回调
void AlgorithmCoordinator::onAsyncAlgorithmFinished(
    const QString& taskId, const QString& algorithmName,
    const AlgorithmResult& result, qint64 elapsedMs) {

    // 发出完成信号
    emit algorithmFinished(algorithmName, result);

    // 清理状态
    m_pending.reset();
    m_currentTaskId.clear();
}
```

---

### 5.2 需要参数的算法（如移动平均）

```cpp
// 用户点击"移动平均"按钮
coordinator->run("moving_average");

// 内部流程：
void AlgorithmCoordinator::run(const QString& algorithmName) {
    auto descriptor = getDescriptor(algorithmName);

    // 判断需要参数弹窗
    if (!descriptor.parameters.isEmpty()) {
        // 保存待处理请求
        PendingAlgorithmRequest pending;
        pending.algorithmName = algorithmName;
        pending.curveId = m_curveManager->getActiveCurve()->id();
        m_pending = pending;

        // 发出信号，请求参数对话框
        emit requestParameterDialog(algorithmName, descriptor);
        return;  // 等待用户输入
    }
}

// 用户提交参数
void AlgorithmCoordinator::submitParameters(const QVariantMap& parameters) {
    if (!m_pending.has_value()) {
        return;
    }

    // 保存参数
    m_pending->parameters = parameters;

    // 获取描述符，判断是否需要点选
    auto descriptor = getDescriptor(m_pending->algorithmName);
    if (descriptor.interaction == AlgorithmInteraction::PointSelection) {
        // 需要点选
        m_pending->waitingForPoints = true;
        m_pending->requiredPointCount = descriptor.requiredPointCount;
        m_pending->pointHint = descriptor.pointSelectionHint;

        emit requestPointSelection(
            m_pending->algorithmName,
            descriptor.requiredPointCount,
            descriptor.pointSelectionHint);
        return;  // 等待用户选点
    }

    // 无需选点，直接执行
    execute();
}
```

---

### 5.3 需要点选的算法（如基线校正）

```cpp
// 用户点击"基线校正"按钮
coordinator->run("baseline_correction");

// 内部流程：
void AlgorithmCoordinator::run(const QString& algorithmName) {
    auto descriptor = getDescriptor(algorithmName);

    // 无需参数，但需要点选
    if (descriptor.interaction == AlgorithmInteraction::PointSelection) {
        PendingAlgorithmRequest pending;
        pending.algorithmName = algorithmName;
        pending.curveId = m_curveManager->getActiveCurve()->id();
        pending.waitingForPoints = true;
        pending.requiredPointCount = descriptor.requiredPointCount;
        pending.pointHint = descriptor.pointSelectionHint;
        m_pending = pending;

        emit requestPointSelection(
            algorithmName,
            descriptor.requiredPointCount,
            descriptor.pointSelectionHint);
        return;  // 等待用户选点
    }
}

// 用户完成点选
void AlgorithmCoordinator::submitPoints(const QVector<ThermalDataPoint>& points) {
    if (!m_pending.has_value() || !m_pending->waitingForPoints) {
        return;
    }

    // 验证点数
    if (points.size() < m_pending->requiredPointCount) {
        emit algorithmFailed(m_pending->algorithmName,
            QString("需要选择至少 %1 个点，当前选择了 %2 个")
                .arg(m_pending->requiredPointCount)
                .arg(points.size()));
        return;
    }

    // 保存点选数据到上下文
    m_context->setValue("selectedPoints", QVariant::fromValue(points));

    // 执行算法
    execute();
}
```

---

## 六、关键优势总结

### 6.1 架构简化

| 特性 | 当前架构 | 新架构 |
|------|---------|--------|
| **执行入口** | 3个（runByName, handleGenericParameterSubmission, handlePointSelectionResult） | 1个（run） |
| **状态管理** | 复杂状态机（PendingPhase） | 简单标志位（waitingForPoints） |
| **数据存储** | MetadataPendingRequest（9个字段） | PendingAlgorithmRequest（6个字段） |
| **代码行数** | 723 行 | ~490 行（减少 32%） |

---

### 6.2 维护性提升

**更清晰的流程**：
```
旧架构：
run() → requestDialog() → handleSubmission()
      → requestPoints() → handlePoints()
      → executeAlgorithm() → onResult()

新架构：
run() → [等待参数] → submitParameters()
      → [等待点选] → submitPoints()
      → execute() → onResult()
```

**更简单的状态判断**：
```cpp
// 旧架构
if (m_metadataPending->phase == PendingPhase::AwaitParameters) {
    // ...
} else if (m_metadataPending->phase == PendingPhase::AwaitPoints) {
    // ...
}

// 新架构
if (m_pending->waitingForPoints) {
    // 只需要一个标志位
}
```

---

### 6.3 扩展性增强

**添加新的交互类型**：
```cpp
// 旧架构：需要修改状态机
enum class PendingPhase {
    None,
    AwaitParameters,
    AwaitPoints,
    AwaitCurveSelection,  // 新增：需要修改多处
};

// 新架构：只需添加标志位
struct PendingAlgorithmRequest {
    bool waitingForPoints = false;
    bool waitingForCurve = false;  // 新增：影响最小
};
```

---

## 七、实施计划

### 7.1 第一步：创建新的 PendingAlgorithmRequest 结构
- [ ] 在 `algorithm_coordinator.h` 中定义新结构
- [ ] 替换 `m_metadataPending` 为 `m_pending`

### 7.2 第二步：重构 run() 方法
- [ ] 合并 `runByName()` 的逻辑
- [ ] 简化参数/点选判断流程
- [ ] 移除 `PendingPhase` 枚举

### 7.3 第三步：实现 submitParameters() 和 submitPoints()
- [ ] 替换 `handleGenericParameterSubmission()`
- [ ] 替换 `handlePointSelectionResult()`
- [ ] 统一调用 `execute()`

### 7.4 第四步：简化信号定义
- [ ] 修改 `requestParameterDialog` 信号
- [ ] 保留 `requestPointSelection` 信号（已简化）
- [ ] 更新 UI 层的信号连接

### 7.5 第五步：测试验证
- [ ] 测试微分算法（无交互）
- [ ] 测试移动平均（参数弹窗）
- [ ] 测试基线校正（点选交互）
- [ ] 测试峰面积（参数 + 点选）

---

## 八、风险评估

### 8.1 兼容性风险
- ⚠️ **信号修改**：UI 层需要更新信号连接
  - 解决方案：保留旧信号，逐步迁移

### 8.2 功能回归风险
- ⚠️ **现有算法可能受影响**
  - 解决方案：完整的回归测试清单

### 8.3 迁移成本
- ⚠️ **需要修改 MainController 中的连接**
  - 解决方案：一次性修改，统一测试

---

## 九、预期收益

### 9.1 代码量减少
- **减少约 230 行代码**（32%）
- 更易于理解和维护

### 9.2 性能提升
- 减少状态判断逻辑
- 更快的执行路径

### 9.3 可维护性
- 线性流程，易于追踪
- 减少 bug 出现的可能性

### 9.4 可扩展性
- 更容易添加新的交互类型
- 更灵活的算法配置

---

## 十、结论

**这次重构将显著简化算法执行流程，预计减少 32% 的代码量，同时提升可维护性和可扩展性。**

**关键改进**：
- ✅ 线性执行流程（参数 → 点选 → 执行 → 输出）
- ✅ 简化状态管理（移除复杂状态机）
- ✅ 统一执行入口（只有一个 `run()` 方法）
- ✅ 清晰的数据流向（AlgorithmContext → 算法 → AlgorithmResult）

**下一步行动**：
1. 审查计划并确认设计方案
2. 开始 Phase 1 实施（简化状态结构）
3. 逐步完成所有阶段
4. 全面测试验证

---

**文档版本**: v1.0
**创建日期**: 2025-11-18
**作者**: Claude Code
**状态**: 待审批
