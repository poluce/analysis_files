# ç»Ÿä¸€ç®—æ³•è¾“å‡ºè®¾è®¡ - ä¸Šä¸‹æ–‡é©±åŠ¨æ¶æ„ v2.0

## ğŸ“‹ è®¾è®¡ç›®æ ‡

å½“å‰é¡¹ç›®å·²å®ç°**ç»Ÿä¸€è¾“å…¥**ï¼ˆç®—æ³•ä» `AlgorithmContext` æ‹‰å–æ•°æ®ï¼‰ï¼Œä½†è¾“å‡ºä»æ˜¯ `QVariant` è¿”å›å€¼ï¼Œå­˜åœ¨ä»¥ä¸‹é—®é¢˜ï¼š

### å½“å‰é—®é¢˜
| é—®é¢˜ | æè¿° |
|------|------|
| âŒ **ç±»å‹ä¸å®‰å…¨** | `QVariant` éœ€è¦æ‰‹åŠ¨è½¬æ¢ï¼Œç¼ºå°‘ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥ |
| âŒ **å•è¾“å‡ºé™åˆ¶** | åªèƒ½è¿”å›ä¸€ä¸ªå€¼ï¼Œæ— æ³•æ”¯æŒå¤šè¾“å‡ºï¼ˆå¦‚é¢ç§¯+æ–°æ›²çº¿ï¼‰ |
| âŒ **ç¼ºä¹å…ƒæ•°æ®** | æ— æ³•ä¼ é€’å•ä½ã€ç²¾åº¦ã€æ˜¾ç¤ºæ ·å¼ç­‰é™„åŠ ä¿¡æ¯ |
| âŒ **éå¯¹ç§°è®¾è®¡** | è¾“å…¥ç”¨ä¸Šä¸‹æ–‡ï¼ˆæ‹‰å–ï¼‰ï¼Œè¾“å‡ºç”¨è¿”å›å€¼ï¼ˆæ¨é€ï¼‰ |
| âŒ **è°ƒè¯•å›°éš¾** | æ— æ³•è¿½è¸ªè¾“å‡ºå€¼çš„ç”Ÿæˆæ—¶é—´å’Œæ¥æº |

### è®¾è®¡ç›®æ ‡
âœ… **å®Œå…¨å¯¹ç§°**ï¼šè¾“å…¥è¾“å‡ºå‡ä½¿ç”¨ `AlgorithmContext`
âœ… **å¤šè¾“å‡ºæ”¯æŒ**ï¼šç®—æ³•å¯å†™å…¥å¤šä¸ªè¾“å‡ºé”®
âœ… **å…ƒæ•°æ®ä¼ é€’**ï¼šé™„åŠ å•ä½ã€æ ‡ç­¾ã€ç²¾åº¦ç­‰ä¿¡æ¯
âœ… **ç±»å‹å®‰å…¨**ï¼šé€šè¿‡æ¨¡æ¿æ–¹æ³•ç±»å‹å®‰å…¨åœ°è®¿é—®
âœ… **å¯è¿½æº¯æ€§**ï¼šæ¯ä¸ªè¾“å‡ºå€¼éƒ½æœ‰æ—¶é—´æˆ³å’Œæ¥æºæ ‡è®°

---

## ğŸ¯ æ ¸å¿ƒè®¾è®¡ç†å¿µ

### å¯¹ç§°æ¶æ„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   AlgorithmContext                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚            INPUT (ç®—æ³•æ‹‰å–)                        â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚ activeCurve      : ThermalCurve*                  â”‚  â”‚
â”‚  â”‚ param.windowSize : int                            â”‚  â”‚
â”‚  â”‚ selectedPoints   : QVector<QPointF>               â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                           â†“                              â”‚
â”‚                    Algorithm Logic                       â”‚
â”‚                           â†“                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚           OUTPUT (ç®—æ³•å†™å…¥)                        â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚ output.curve          : QVector<ThermalDataPoint> â”‚  â”‚
â”‚  â”‚ output.signalType     : SignalType                â”‚  â”‚
â”‚  â”‚ output.metadata.unit  : QString                   â”‚  â”‚
â”‚  â”‚ output.area           : double                    â”‚  â”‚
â”‚  â”‚ output.annotations    : QVariantList              â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“¦ æ ‡å‡†è¾“å‡ºé”®è§„èŒƒ

### å‘½åçº¦å®š
æ‰€æœ‰è¾“å‡ºé”®ä»¥ `output.` ä¸ºå‰ç¼€ï¼Œéµå¾ªåˆ†ç±»å‘½åï¼š

```cpp
// ä¸»è¾“å‡º
output.curve           // è¾“å‡ºçš„æ›²çº¿æ•°æ® (QVector<ThermalDataPoint>)
output.signalType      // è¾“å‡ºä¿¡å·ç±»å‹ (SignalType)

// æ•°å€¼è¾“å‡º
output.area            // é¢ç§¯å€¼ (double)
output.peakPosition    // å³°ä½ç½® (QPointF)
output.intersections   // äº¤ç‚¹é›†åˆ (QVector<QPointF>)

// å…ƒæ•°æ®
output.metadata.unit   // å•ä½ (QString)
output.metadata.label  // æ ‡ç­¾ (QString)
output.metadata.precision  // ç²¾åº¦ (int)
output.metadata.color  // æ˜¾ç¤ºé¢œè‰² (QColor)

// å¯è§†åŒ–
output.annotations     // æ ‡æ³¨åˆ—è¡¨ (QVariantList)
output.series          // Qt Charts ç³»åˆ—å¯¹è±¡ (QAbstractSeries*)

// å¤šè¾“å‡º
output.curves          // å¤šæ¡æ›²çº¿ (QVariantList of QVector<ThermalDataPoint>)
output.messages        // æ¶ˆæ¯åˆ—è¡¨ (QStringList)
```

### æ•°æ®åˆ†ç±»

| åˆ†ç±» | é”®åå‰ç¼€ | ç±»å‹ | ç¤ºä¾‹ |
|------|----------|------|------|
| æ›²çº¿æ•°æ® | `output.curve*` | `QVector<ThermalDataPoint>` | `output.curve` |
| æ•°å€¼ç»“æœ | `output.*` | `double`, `int`, `QPointF` | `output.area` |
| å…ƒæ•°æ® | `output.metadata.*` | å„ç§åŸºç¡€ç±»å‹ | `output.metadata.unit` |
| å¯è§†åŒ– | `output.annotations` | `QVariantList` | æ ‡æ³¨ã€æ ‡è®° |
| å¤šè¾“å‡º | `output.curves`, `output.messages` | `QVariantList` | å¤šæ›²çº¿ã€å¤šæ¶ˆæ¯ |

---

## ğŸ”¨ å®ç°æ–¹æ¡ˆ

### 1ï¸âƒ£ ä¿®æ”¹æ¥å£å®šä¹‰

```cpp
// src/domain/algorithm/i_thermal_algorithm.h

class IThermalAlgorithm {
public:
    /**
     * @brief æ‰§è¡Œç®—æ³•ï¼ˆä¸Šä¸‹æ–‡é©±åŠ¨ï¼Œçº¯è™šå‡½æ•°ï¼‰ã€‚
     *
     * âœ… **è¾“å…¥**ï¼šç®—æ³•ä»ä¸Šä¸‹æ–‡æ‹‰å–æ•°æ®
     * âœ… **è¾“å‡º**ï¼šç®—æ³•å°†ç»“æœå†™å…¥ä¸Šä¸‹æ–‡
     *
     * è¾“å…¥é”®ï¼ˆæ‹‰å–ï¼‰ï¼š
     * - activeCurve       : ThermalCurve*
     * - param.*           : ç®—æ³•å‚æ•°
     * - selectedPoints    : QVector<QPointF>
     * - referenceCurve    : ThermalCurve*
     *
     * è¾“å‡ºé”®ï¼ˆå†™å…¥ï¼‰ï¼š
     * - output.curve      : QVector<ThermalDataPoint>
     * - output.signalType : SignalType
     * - output.area       : double
     * - output.metadata.* : å…ƒæ•°æ®
     * - output.annotations: QVariantList
     *
     * è¿”å›å€¼ï¼š
     * - true: æ‰§è¡ŒæˆåŠŸ
     * - false: æ‰§è¡Œå¤±è´¥ï¼ˆé”™è¯¯ä¿¡æ¯å†™å…¥ output.errorï¼‰
     *
     * @param context ç®—æ³•ä¸Šä¸‹æ–‡ï¼ŒåŒ…å«è¾“å…¥æ•°æ®å’Œè¾“å‡ºç»“æœã€‚
     * @return æ‰§è¡Œæ˜¯å¦æˆåŠŸã€‚
     */
    virtual bool executeWithContext(AlgorithmContext* context) = 0;
};
```

**å…³é”®å˜æ›´**ï¼š
- è¿”å›ç±»å‹ä» `QVariant` æ”¹ä¸º `bool`ï¼ˆè¡¨ç¤ºæˆåŠŸ/å¤±è´¥ï¼‰
- è¾“å‡ºé€šè¿‡ `context->setValue()` å†™å…¥ä¸Šä¸‹æ–‡
- é”™è¯¯ä¿¡æ¯å†™å…¥ `output.error`

---

### 2ï¸âƒ£ ç®—æ³•å®ç°ç¤ºä¾‹

#### ç¤ºä¾‹Aï¼šç®€å•ç®—æ³•ï¼ˆå¾®åˆ†ï¼‰

```cpp
// src/infrastructure/algorithm/differentiation_algorithm.cpp

bool DifferentiationAlgorithm::executeWithContext(AlgorithmContext* context) {
    // 1. éªŒè¯ä¸Šä¸‹æ–‡
    if (!context) {
        return false;
    }

    // 2. æ‹‰å–è¾“å…¥
    auto curve = context->get<ThermalCurve*>("activeCurve");
    if (!curve.has_value() || !curve.value()) {
        context->setValue("output.error", "æœªæ‰¾åˆ°æ´»åŠ¨æ›²çº¿", "DifferentiationAlgorithm");
        return false;
    }

    int windowSize = context->get<int>("param.windowSize").value_or(50);

    // 3. è·å–è¾“å…¥æ•°æ®
    const auto& inputData = curve.value()->getProcessedData();
    if (inputData.size() < windowSize * 2) {
        context->setValue("output.error", "æ•°æ®ç‚¹æ•°ä¸è¶³", "DifferentiationAlgorithm");
        return false;
    }

    // 4. æ‰§è¡Œç®—æ³•é€»è¾‘
    QVector<ThermalDataPoint> outputData;
    for (int i = windowSize; i < inputData.size() - windowSize; ++i) {
        // ... å¾®åˆ†è®¡ç®— ...
        outputData.append(point);
    }

    // 5. å†™å…¥è¾“å‡ºåˆ°ä¸Šä¸‹æ–‡
    context->setValue("output.curve",
                      QVariant::fromValue(outputData),
                      "DifferentiationAlgorithm");

    context->setValue("output.signalType",
                      QVariant::fromValue(SignalType::Derivative),
                      "DifferentiationAlgorithm");

    context->setValue("output.metadata.unit",
                      "mg/min",
                      "DifferentiationAlgorithm");

    context->setValue("output.metadata.label",
                      "DTG",
                      "DifferentiationAlgorithm");

    return true;
}
```

#### ç¤ºä¾‹Bï¼šäº¤äº’ç®—æ³•ï¼ˆåŸºçº¿æ ¡æ­£ï¼‰

```cpp
// src/infrastructure/algorithm/baseline_correction_algorithm.cpp

bool BaselineCorrectionAlgorithm::executeWithContext(AlgorithmContext* context) {
    if (!context) return false;

    // æ‹‰å–è¾“å…¥
    auto curve = context->get<ThermalCurve*>("activeCurve").value();
    auto points = context->get<QVector<QPointF>>("selectedPoints").value();

    // æ‰§è¡ŒåŸºçº¿æ ¡æ­£
    QVector<ThermalDataPoint> correctedData = performCorrection(curve, points);

    // å†™å…¥å¤šä¸ªè¾“å‡º
    context->setValue("output.curve", QVariant::fromValue(correctedData), "BaselineCorrection");
    context->setValue("output.signalType", QVariant::fromValue(SignalType::Baseline), "BaselineCorrection");

    // é™„åŠ åŸºçº¿å‚æ•°ç”¨äºå¯è§†åŒ–
    context->setValue("output.baselinePoints", QVariant::fromValue(points), "BaselineCorrection");
    context->setValue("output.metadata.correctionType", "Linear", "BaselineCorrection");

    return true;
}
```

#### ç¤ºä¾‹Cï¼šå¤šè¾“å‡ºç®—æ³•ï¼ˆå³°é¢ç§¯ï¼‰

```cpp
// src/infrastructure/algorithm/peak_area_algorithm.cpp

bool PeakAreaAlgorithm::executeWithContext(AlgorithmContext* context) {
    if (!context) return false;

    auto curve = context->get<ThermalCurve*>("activeCurve").value();
    auto points = context->get<QVector<QPointF>>("selectedPoints").value();

    // è®¡ç®—å³°é¢ç§¯
    double area = calculateArea(curve, points);
    QVector<ThermalDataPoint> baselineCurve = generateBaseline(curve, points);

    // å†™å…¥å¤šä¸ªè¾“å‡º
    context->setValue("output.area", area, "PeakAreaAlgorithm");
    context->setValue("output.curve", QVariant::fromValue(baselineCurve), "PeakAreaAlgorithm");
    context->setValue("output.signalType", QVariant::fromValue(SignalType::PeakArea), "PeakAreaAlgorithm");

    // å†™å…¥å…ƒæ•°æ®
    context->setValue("output.metadata.unit", "J/g", "PeakAreaAlgorithm");
    context->setValue("output.metadata.integrationRange",
                      QString("%1 - %2").arg(points.first().x()).arg(points.last().x()),
                      "PeakAreaAlgorithm");

    // å†™å…¥æ³¨é‡Šï¼ˆç”¨äºå›¾è¡¨æ ‡æ³¨ï¼‰
    QVariantList annotations;
    annotations << QVariantMap{
        {"type", "area"},
        {"value", area},
        {"position", QPointF((points.first().x() + points.last().x()) / 2, 0)}
    };
    context->setValue("output.annotations", annotations, "PeakAreaAlgorithm");

    return true;
}
```

---

### 3ï¸âƒ£ ä¿®æ”¹ AlgorithmManager

```cpp
// src/application/algorithm/algorithm_manager.cpp

void AlgorithmManager::executeWithContext(const QString& name, AlgorithmContext* context) {
    // ... å‰ç½®æ£€æŸ¥ ...

    // æ‰§è¡Œç®—æ³•
    bool success = algorithm->executeWithContext(context);

    if (!success) {
        // è¯»å–é”™è¯¯ä¿¡æ¯
        QString error = context->get<QString>("output.error").value_or("æœªçŸ¥é”™è¯¯");
        qWarning() << "ç®—æ³•æ‰§è¡Œå¤±è´¥:" << name << "-" << error;
        emit algorithmExecutionFailed(name, error);
        return;
    }

    // å¤„ç†è¾“å‡º
    handleAlgorithmOutput(algorithm, curve, context);

    // å‘å‡ºæˆåŠŸä¿¡å·
    emit algorithmResultReady(name, algorithm->outputType());
}

void AlgorithmManager::handleAlgorithmOutput(
    IThermalAlgorithm* algorithm,
    ThermalCurve* parentCurve,
    AlgorithmContext* context)
{
    if (!algorithm || !parentCurve || !context) return;

    auto outputType = algorithm->outputType();

    switch (outputType) {
    case IThermalAlgorithm::OutputType::Curve: {
        // ä»ä¸Šä¸‹æ–‡è¯»å–è¾“å‡ºæ›²çº¿
        auto outputCurve = context->get<QVector<ThermalDataPoint>>("output.curve");
        if (!outputCurve.has_value() || outputCurve.value().isEmpty()) {
            qWarning() << "æœªæ‰¾åˆ°è¾“å‡ºæ›²çº¿æ•°æ®";
            return;
        }

        // è¯»å–ä¿¡å·ç±»å‹
        auto signalType = context->get<SignalType>("output.signalType")
                              .value_or(algorithm->getOutputSignalType(parentCurve->signalType()));

        // åˆ›å»ºæ–°æ›²çº¿
        createAndAddOutputCurve(algorithm, parentCurve, outputCurve.value(), signalType, true);
        break;
    }

    case IThermalAlgorithm::OutputType::Area: {
        // è¯»å–é¢ç§¯å€¼
        auto area = context->get<double>("output.area");
        if (!area.has_value()) {
            qWarning() << "æœªæ‰¾åˆ°é¢ç§¯è¾“å‡º";
            return;
        }

        // è¯»å–å•ä½
        QString unit = context->get<QString>("output.metadata.unit").value_or("");

        qDebug() << "å³°é¢ç§¯:" << area.value() << unit;

        // å¦‚æœåŒæ—¶è¾“å‡ºäº†æ›²çº¿ï¼Œä¹Ÿåˆ›å»ºå®ƒ
        auto outputCurve = context->get<QVector<ThermalDataPoint>>("output.curve");
        if (outputCurve.has_value()) {
            auto signalType = context->get<SignalType>("output.signalType")
                                  .value_or(SignalType::PeakArea);
            createAndAddOutputCurve(algorithm, parentCurve, outputCurve.value(), signalType, true);
        }

        // TODO: åˆ›å»ºé¢ç§¯ç»“æœå¯¹è±¡
        break;
    }

    case IThermalAlgorithm::OutputType::Annotation: {
        // è¯»å–æ³¨é‡Š
        auto annotations = context->get<QVariantList>("output.annotations");
        if (annotations.has_value()) {
            qDebug() << "æ ‡æ³¨æ•°é‡:" << annotations.value().size();
            // TODO: å‘é€ç»™ ChartView æ˜¾ç¤º
        }
        break;
    }

    // ... å…¶ä»–ç±»å‹ ...
    }
}
```

---

### 4ï¸âƒ£ æ‰©å±• CurveManagerï¼ˆæ”¯æŒå…ƒæ•°æ®ï¼‰

```cpp
// src/application/curve/curve_manager.h

class CurveManager : public QObject {
    // ...
public:
    /**
     * @brief åˆ›å»ºå¹¶æ·»åŠ è¾“å‡ºæ›²çº¿ï¼ˆä»ä¸Šä¸‹æ–‡è¯»å–å…ƒæ•°æ®ï¼‰
     */
    void createOutputCurveFromContext(
        ThermalCurve* parentCurve,
        const QString& curveName,
        AlgorithmContext* context);
};

// src/application/curve/curve_manager.cpp

void CurveManager::createOutputCurveFromContext(
    ThermalCurve* parentCurve,
    const QString& curveName,
    AlgorithmContext* context)
{
    if (!parentCurve || !context) return;

    // ä»ä¸Šä¸‹æ–‡è¯»å–æ›²çº¿æ•°æ®
    auto outputData = context->get<QVector<ThermalDataPoint>>("output.curve");
    if (!outputData.has_value() || outputData.value().isEmpty()) {
        qWarning() << "ä¸Šä¸‹æ–‡ä¸­æ²¡æœ‰æ›²çº¿æ•°æ®";
        return;
    }

    // åˆ›å»ºæ–°æ›²çº¿
    QString newId = QUuid::createUuid().toString();
    ThermalCurve newCurve(newId, curveName);

    // å¡«å……æ•°æ®
    newCurve.setProcessedData(outputData.value());
    newCurve.setParentId(parentCurve->id());
    newCurve.setProjectName(parentCurve->projectName());

    // ä»ä¸Šä¸‹æ–‡è¯»å–å¹¶è®¾ç½®å…ƒæ•°æ®
    auto signalType = context->get<SignalType>("output.signalType");
    if (signalType.has_value()) {
        newCurve.setSignalType(signalType.value());
    }

    auto unit = context->get<QString>("output.metadata.unit");
    if (unit.has_value()) {
        // TODO: å°†å•ä½å­˜å…¥æ›²çº¿å…ƒæ•°æ®
    }

    auto color = context->get<QColor>("output.metadata.color");
    if (color.has_value()) {
        // TODO: è®¾ç½®æ›²çº¿é¢œè‰²
    }

    // æ·»åŠ æ›²çº¿
    addCurve(newCurve);
    setActiveCurve(newId);
}
```

---

## ğŸ”„ è¿ç§»è·¯å¾„

### é˜¶æ®µ1ï¼šæ‰©å±•æ¥å£ï¼ˆå‘åå…¼å®¹ï¼‰
1. âœ… ä¿æŒ `executeWithContext()` è¿”å› `QVariant`
2. âœ… ç®—æ³•**åŒæ—¶å†™å…¥ä¸Šä¸‹æ–‡å’Œè¿”å›å€¼**
3. âœ… `AlgorithmManager` ä¼˜å…ˆè¯»å–ä¸Šä¸‹æ–‡ï¼Œfallback åˆ°è¿”å›å€¼

```cpp
// å…¼å®¹æ¨¡å¼ç¤ºä¾‹
QVariant DifferentiationAlgorithm::executeWithContext(AlgorithmContext* context) {
    // ... è®¡ç®— ...

    // æ–°æ–¹å¼ï¼šå†™å…¥ä¸Šä¸‹æ–‡
    context->setValue("output.curve", QVariant::fromValue(outputData));

    // æ—§æ–¹å¼ï¼šè¿”å›å€¼ï¼ˆä¿æŒå…¼å®¹ï¼‰
    return QVariant::fromValue(outputData);
}
```

### é˜¶æ®µ2ï¼šä¿®æ”¹æ¥å£ç­¾å
1. âœ… å°†è¿”å›ç±»å‹ä» `QVariant` æ”¹ä¸º `bool`
2. âœ… æ›´æ–°æ‰€æœ‰ç®—æ³•å®ç°
3. âœ… æ›´æ–° `AlgorithmManager` åªè¯»å–ä¸Šä¸‹æ–‡

### é˜¶æ®µ3ï¼šå®Œå…¨è¿ç§»
1. âœ… ç§»é™¤æ‰€æœ‰è¿”å›å€¼é€»è¾‘
2. âœ… æ‰€æœ‰è¾“å‡ºé€šè¿‡ä¸Šä¸‹æ–‡ä¼ é€’
3. âœ… éªŒè¯æ‰€æœ‰ç®—æ³•ç±»å‹

---

## ğŸ¯ æ ¸å¿ƒä¼˜åŠ¿

| ä¼˜åŠ¿ | è¯´æ˜ |
|------|------|
| âœ… **å®Œå…¨å¯¹ç§°** | è¾“å…¥è¾“å‡ºå‡ä½¿ç”¨ `AlgorithmContext`ï¼Œæ¶æ„ç»Ÿä¸€ |
| âœ… **å¤šè¾“å‡ºæ”¯æŒ** | ä¸€æ¬¡æ‰§è¡Œå¯è¾“å‡ºå¤šä¸ªç»“æœï¼ˆé¢ç§¯+æ›²çº¿+æ³¨é‡Šï¼‰ |
| âœ… **ç±»å‹å®‰å…¨** | `context->get<T>()` æä¾›ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥ |
| âœ… **å…ƒæ•°æ®ä¼ é€’** | å¯é™„åŠ å•ä½ã€æ ‡ç­¾ã€é¢œè‰²ç­‰ä¸°å¯Œä¿¡æ¯ |
| âœ… **å¯è¿½æº¯æ€§** | æ¯ä¸ªè¾“å‡ºéƒ½æœ‰æ—¶é—´æˆ³å’Œæ¥æºè®°å½• |
| âœ… **æ˜“äºæ‰©å±•** | æ·»åŠ æ–°è¾“å‡ºé”®æ— éœ€ä¿®æ”¹æ¥å£ç­¾å |
| âœ… **è°ƒè¯•å‹å¥½** | å¯æ‰“å°å®Œæ•´ä¸Šä¸‹æ–‡æŸ¥çœ‹æ‰€æœ‰è¾“å…¥è¾“å‡º |

---

## ğŸ“Š å¯¹æ¯”åˆ†æ

| ç»´åº¦ | å½“å‰æ–¹æ¡ˆï¼ˆQVariantè¿”å›ï¼‰ | æ–°æ–¹æ¡ˆï¼ˆä¸Šä¸‹æ–‡è¾“å‡ºï¼‰ |
|------|-------------------------|---------------------|
| **è¾“å…¥æ–¹å¼** | ä¸Šä¸‹æ–‡æ‹‰å– âœ… | ä¸Šä¸‹æ–‡æ‹‰å– âœ… |
| **è¾“å‡ºæ–¹å¼** | è¿”å›å€¼ âŒ | ä¸Šä¸‹æ–‡å†™å…¥ âœ… |
| **æ¶æ„å¯¹ç§°** | ä¸å¯¹ç§° âŒ | å®Œå…¨å¯¹ç§° âœ… |
| **å¤šè¾“å‡º** | ä¸æ”¯æŒ âŒ | å®Œå…¨æ”¯æŒ âœ… |
| **ç±»å‹å®‰å…¨** | å¼±ç±»å‹ âŒ | å¼ºç±»å‹ âœ… |
| **å…ƒæ•°æ®** | æ— æ³•ä¼ é€’ âŒ | å®Œæ•´æ”¯æŒ âœ… |
| **è°ƒè¯•æ€§** | å›°éš¾ âŒ | å‹å¥½ âœ… |

---

## ğŸš€ å®æ–½å»ºè®®

### ä¼˜å…ˆçº§
1. **é«˜ä¼˜å…ˆçº§**ï¼šä¿®æ”¹æ¥å£å®šä¹‰å’Œç®€å•ç®—æ³•ï¼ˆå¾®åˆ†ã€ç§¯åˆ†ã€æ»¤æ³¢ï¼‰
2. **ä¸­ä¼˜å…ˆçº§**ï¼šä¿®æ”¹äº¤äº’ç®—æ³•ï¼ˆåŸºçº¿æ ¡æ­£ï¼‰
3. **ä½ä¼˜å…ˆçº§**ï¼šå®ç°å¤šè¾“å‡ºç®—æ³•ï¼ˆå³°é¢ç§¯ã€æ³¨é‡Šï¼‰

### é£é™©è¯„ä¼°
| é£é™© | ç¼“è§£æªæ–½ |
|------|---------|
| ç ´åç°æœ‰ä»£ç  | åˆ†é˜¶æ®µè¿ç§»ï¼Œä¿æŒå‘åå…¼å®¹ |
| æ€§èƒ½å¼€é”€ | `AlgorithmContext` å·²é«˜åº¦ä¼˜åŒ– |
| å­¦ä¹ æ›²çº¿ | æä¾›è¯¦ç»†ç¤ºä¾‹å’Œæ–‡æ¡£ |

---

## ğŸ“š ç›¸å…³æ–‡æ¡£
- `ğŸ“˜ AlgorithmContext ç±»è®¾è®¡æ–‡æ¡£.md` - ä¸Šä¸‹æ–‡å®¹å™¨è®¾è®¡
- `AlgorithmContext_æ•°æ®æ¸…å•.md` - æ ‡å‡†é”®åè§„èŒƒ
- `CLAUDE.md` - ä¸»æ¶æ„æ–‡æ¡£

---

**ç‰ˆæœ¬å†å²**
- v2.0 (2025-01-XX): ç»Ÿä¸€è¾“å‡ºåˆ°ä¸Šä¸‹æ–‡è®¾è®¡
- v1.0 (2025-01-XX): ç»Ÿä¸€è¾“å…¥åˆ°ä¸Šä¸‹æ–‡è®¾è®¡
