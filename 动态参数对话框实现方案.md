# 动态参数对话框实现方案

## 核心思想

**根据算法的自描述信息（AlgorithmDescriptor）动态创建 QDialog，无需为每个算法写单独的对话框类。**

---

## 一、Qt 官方推荐写法

### 基本示例

```cpp
// Qt 官方推荐：直接 new QDialog，用 FormLayout 摆控件
QDialog dlg;
QFormLayout form(&dlg);

QLineEdit *tempEdit = new QLineEdit(&dlg);
QLineEdit *timeEdit = new QLineEdit(&dlg);

form.addRow("温度：", tempEdit);
form.addRow("时间：", timeEdit);

QPushButton *btn = new QPushButton("确定", &dlg);
form.addRow(btn);

QObject::connect(btn, &QPushButton::clicked, &dlg, &QDialog::accept);

if (dlg.exec() == QDialog::Accepted) {
    QString temp = tempEdit->text();
    QString time = timeEdit->text();
    qDebug() << temp << time;
}
```

**优势**：
- ✅ 无需写单独的类
- ✅ 代码简洁，易于维护
- ✅ 符合 Qt 官方推荐
- ✅ 控件生命周期由对话框管理

---

## 二、配合算法自描述的完整实现

### 2.1 算法参数定义

首先，算法通过 `descriptor()` 定义参数：

```cpp
// 移动平均算法
class MovingAverageFilterAlgorithm : public IThermalAlgorithm {
public:
    AlgorithmDescriptor descriptor() const override {
        AlgorithmDescriptor desc;
        desc.name = "moving_average";
        desc.displayName = "移动平均滤波";
        desc.needsParameters = true;

        // ✅ 定义参数
        desc.parameters = {
            AlgorithmParameterDefinition{
                "windowSize",           // 参数名
                "窗口大小",             // 显示名称
                ParameterType::Integer, // 类型
                5,                      // 默认值
                1,                      // 最小值
                100                     // 最大值
            }
        };

        return desc;
    }
};
```

---

### 2.2 MainController 中的动态对话框生成

```cpp
// main_controller.cpp
void MainController::onRequestParameterDialog(
    const QString& algorithmName,
    const AlgorithmDescriptor& descriptor)
{
    // ==================== 创建对话框 ====================
    QDialog* dlg = new QDialog(m_mainWindow);
    dlg->setWindowTitle(descriptor.displayName + " - 参数设置");
    dlg->setMinimumWidth(400);

    QFormLayout* form = new QFormLayout(dlg);
    form->setLabelAlignment(Qt::AlignRight);
    form->setFormAlignment(Qt::AlignHCenter | Qt::AlignTop);

    // ==================== 存储控件引用 ====================
    // 键：参数名，值：控件指针
    QMap<QString, QWidget*> widgets;

    // ==================== 动态创建参数控件 ====================
    for (const auto& param : descriptor.parameters) {
        QWidget* widget = createParameterWidget(param, dlg);

        if (widget) {
            form->addRow(param.displayName + ":", widget);
            widgets[param.name] = widget;
        }
    }

    // ==================== 添加按钮 ====================
    QDialogButtonBox* buttonBox = new QDialogButtonBox(
        QDialogButtonBox::Ok | QDialogButtonBox::Cancel, dlg);
    form->addRow(buttonBox);

    connect(buttonBox, &QDialogButtonBox::accepted, dlg, &QDialog::accept);
    connect(buttonBox, &QDialogButtonBox::rejected, dlg, &QDialog::reject);

    // ==================== 显示对话框并提取参数 ====================
    if (dlg->exec() == QDialog::Accepted) {
        // 提取参数值
        QVariantMap parameters = extractParameters(widgets, descriptor.parameters);

        // 提交给 Coordinator
        m_algorithmCoordinator->submitParameters(parameters);
    } else {
        // 用户取消
        m_algorithmCoordinator->cancel();
    }

    // ==================== 清理 ====================
    dlg->deleteLater();
}
```

---

### 2.3 辅助方法：创建参数控件

```cpp
// main_controller.cpp (private 方法)
QWidget* MainController::createParameterWidget(
    const AlgorithmParameterDefinition& param,
    QWidget* parent)
{
    switch (param.type) {

    // ==================== 整数类型 ====================
    case ParameterType::Integer:
        {
            QSpinBox* spinBox = new QSpinBox(parent);
            spinBox->setMinimum(param.minValue.toInt());
            spinBox->setMaximum(param.maxValue.toInt());
            spinBox->setValue(param.defaultValue.toInt());
            spinBox->setSuffix(param.unit.isEmpty() ? "" : " " + param.unit);
            return spinBox;
        }

    // ==================== 浮点类型 ====================
    case ParameterType::Double:
        {
            QDoubleSpinBox* spinBox = new QDoubleSpinBox(parent);
            spinBox->setMinimum(param.minValue.toDouble());
            spinBox->setMaximum(param.maxValue.toDouble());
            spinBox->setValue(param.defaultValue.toDouble());
            spinBox->setDecimals(3);
            spinBox->setSuffix(param.unit.isEmpty() ? "" : " " + param.unit);
            return spinBox;
        }

    // ==================== 字符串类型 ====================
    case ParameterType::String:
        {
            QLineEdit* lineEdit = new QLineEdit(parent);
            lineEdit->setText(param.defaultValue.toString());
            lineEdit->setPlaceholderText(param.description);
            return lineEdit;
        }

    // ==================== 布尔类型 ====================
    case ParameterType::Boolean:
        {
            QCheckBox* checkBox = new QCheckBox(parent);
            checkBox->setChecked(param.defaultValue.toBool());
            checkBox->setText(param.description);
            return checkBox;
        }

    // ==================== 枚举类型 ====================
    case ParameterType::Enum:
        {
            QComboBox* comboBox = new QComboBox(parent);
            comboBox->addItems(param.enumOptions);
            comboBox->setCurrentIndex(param.defaultValue.toInt());
            return comboBox;
        }

    default:
        qWarning() << "未知的参数类型：" << static_cast<int>(param.type);
        return nullptr;
    }
}
```

---

### 2.4 辅助方法：提取参数值

```cpp
// main_controller.cpp (private 方法)
QVariantMap MainController::extractParameters(
    const QMap<QString, QWidget*>& widgets,
    const QVector<AlgorithmParameterDefinition>& paramDefs)
{
    QVariantMap parameters;

    for (const auto& param : paramDefs) {
        if (!widgets.contains(param.name)) {
            qWarning() << "参数控件不存在：" << param.name;
            continue;
        }

        QWidget* widget = widgets[param.name];
        QVariant value;

        // 根据参数类型提取值
        switch (param.type) {
        case ParameterType::Integer:
            if (QSpinBox* spinBox = qobject_cast<QSpinBox*>(widget)) {
                value = spinBox->value();
            }
            break;

        case ParameterType::Double:
            if (QDoubleSpinBox* spinBox = qobject_cast<QDoubleSpinBox*>(widget)) {
                value = spinBox->value();
            }
            break;

        case ParameterType::String:
            if (QLineEdit* lineEdit = qobject_cast<QLineEdit*>(widget)) {
                value = lineEdit->text();
            }
            break;

        case ParameterType::Boolean:
            if (QCheckBox* checkBox = qobject_cast<QCheckBox*>(widget)) {
                value = checkBox->isChecked();
            }
            break;

        case ParameterType::Enum:
            if (QComboBox* comboBox = qobject_cast<QComboBox*>(widget)) {
                value = comboBox->currentIndex();
            }
            break;
        }

        if (value.isValid()) {
            parameters[param.name] = value;
        }
    }

    return parameters;
}
```

---

## 三、完整的使用示例

### 3.1 简单算法（单个参数）

```cpp
// 移动平均算法
AlgorithmDescriptor descriptor() const override {
    desc.parameters = {
        {"windowSize", "窗口大小", ParameterType::Integer, 5, 1, 100}
    };
    return desc;
}
```

**生成的对话框**：
```
┌─────────────────────────────────┐
│  移动平均滤波 - 参数设置         │
├─────────────────────────────────┤
│                                 │
│  窗口大小：  [  5  ] ▼          │
│                                 │
│           [ 确定 ] [ 取消 ]     │
└─────────────────────────────────┘
```

---

### 3.2 复杂算法（多个参数）

```cpp
// 基线校正算法（假设需要参数）
AlgorithmDescriptor descriptor() const override {
    desc.parameters = {
        {"method", "校正方法", ParameterType::Enum,
         0, {"线性", "多项式", "样条"}},

        {"polynomialDegree", "多项式次数", ParameterType::Integer,
         3, 1, 10},

        {"smoothing", "平滑系数", ParameterType::Double,
         0.5, 0.0, 1.0},

        {"autoDetect", "自动检测基线点", ParameterType::Boolean,
         true}
    };
    return desc;
}
```

**生成的对话框**：
```
┌─────────────────────────────────┐
│  基线校正 - 参数设置             │
├─────────────────────────────────┤
│                                 │
│  校正方法：      [线性      ▼]  │
│  多项式次数：    [  3  ] ▼      │
│  平滑系数：      [ 0.500 ] ▼    │
│  自动检测基线点： [✓]           │
│                                 │
│           [ 确定 ] [ 取消 ]     │
└─────────────────────────────────┘
```

---

## 四、与算法自描述的完整流程

### 4.1 执行流程

```
用户点击"移动平均"按钮
  ↓
MainController::onAlgorithmTriggered("moving_average")
  ↓
AlgorithmCoordinator::run("moving_average")
  ↓
读取算法的 descriptor()
  ↓
发现 needsParameters = true
  ↓
发出信号 requestParameterDialog(name, descriptor)
  ↓
MainController::onRequestParameterDialog()
  ↓
动态创建 QDialog + QFormLayout
  ↓
根据 descriptor.parameters 创建控件
  ↓
用户输入参数，点击"确定"
  ↓
提取参数值 → QVariantMap
  ↓
调用 coordinator->submitParameters(params)
  ↓
Coordinator 继续下一步（点选或直接执行）
```

---

### 4.2 代码流程示例

```cpp
// 1. 算法定义参数
class MovingAverageFilterAlgorithm {
    AlgorithmDescriptor descriptor() const override {
        desc.needsParameters = true;
        desc.parameters = {
            {"windowSize", "窗口大小", ParameterType::Integer, 5, 1, 100}
        };
        return desc;
    }
};

// 2. Coordinator 请求参数对话框
void AlgorithmCoordinator::run(const QString& algorithmName) {
    auto descriptor = getDescriptor(algorithmName);

    if (descriptor.needsParameters) {
        emit requestParameterDialog(algorithmName, descriptor);
    }
}

// 3. MainController 动态创建对话框
void MainController::onRequestParameterDialog(
    const QString& algorithmName,
    const AlgorithmDescriptor& descriptor)
{
    QDialog* dlg = new QDialog(m_mainWindow);
    QFormLayout* form = new QFormLayout(dlg);

    // 动态创建控件
    QMap<QString, QWidget*> widgets;
    for (const auto& param : descriptor.parameters) {
        QWidget* widget = createParameterWidget(param, dlg);
        form->addRow(param.displayName + ":", widget);
        widgets[param.name] = widget;
    }

    // 添加按钮
    QDialogButtonBox* buttonBox = new QDialogButtonBox(
        QDialogButtonBox::Ok | QDialogButtonBox::Cancel, dlg);
    form->addRow(buttonBox);
    connect(buttonBox, &QDialogButtonBox::accepted, dlg, &QDialog::accept);
    connect(buttonBox, &QDialogButtonBox::rejected, dlg, &QDialog::reject);

    // 显示并提取参数
    if (dlg->exec() == QDialog::Accepted) {
        QVariantMap parameters = extractParameters(widgets, descriptor.parameters);
        m_algorithmCoordinator->submitParameters(parameters);
    } else {
        m_algorithmCoordinator->cancel();
    }

    dlg->deleteLater();
}

// 4. Coordinator 继续执行
void AlgorithmCoordinator::submitParameters(const QVariantMap& parameters) {
    m_pending->parameters = parameters;
    m_pending->currentStepIndex++;
    processNextStep();  // 继续下一步（点选或执行）
}
```

---

## 五、关键优势

### 5.1 无需写对话框类

```cpp
// ❌ 旧方式：为每个算法写一个对话框类
class MovingAverageDialog : public QDialog {
    Q_OBJECT
public:
    MovingAverageDialog(QWidget* parent);
    int getWindowSize() const;
private:
    QSpinBox* m_windowSizeSpinBox;
};

// ✅ 新方式：动态生成，无需写类
void MainController::onRequestParameterDialog(...) {
    QDialog* dlg = new QDialog(parent);
    // 根据 descriptor 动态创建
}
```

---

### 5.2 完美配合算法自描述

```cpp
// 算法定义参数
desc.parameters = {
    {"param1", "参数1", ParameterType::Integer, ...},
    {"param2", "参数2", ParameterType::Double, ...}
};

// 对话框自动生成对应的控件
// 无需手动编写 UI 代码
```

---

### 5.3 易于扩展

```cpp
// 添加新参数类型：只需在 createParameterWidget() 中添加 case
case ParameterType::Color:
    {
        QColorDialog* colorDialog = new QColorDialog(parent);
        return colorDialog;
    }

// 添加新算法：只需在 descriptor() 中定义参数
desc.parameters = {
    {"color", "颜色", ParameterType::Color, QColor(Qt::red)}
};
```

---

## 六、注意事项

### 6.1 内存管理

```cpp
// ✅ 正确：使用 deleteLater()
QDialog* dlg = new QDialog(parent);
// ...
dlg->deleteLater();  // 安全删除

// ❌ 错误：立即 delete
delete dlg;  // 可能导致崩溃（如果还有信号在队列中）
```

---

### 6.2 控件类型转换

```cpp
// ✅ 正确：使用 qobject_cast
if (QSpinBox* spinBox = qobject_cast<QSpinBox*>(widget)) {
    value = spinBox->value();
}

// ❌ 错误：使用 static_cast
QSpinBox* spinBox = static_cast<QSpinBox*>(widget);  // 不安全
```

---

### 6.3 参数验证

```cpp
// 提取参数后，验证有效性
QVariantMap parameters = extractParameters(widgets, descriptor.parameters);

// 验证必需参数
for (const auto& param : descriptor.parameters) {
    if (param.required && !parameters.contains(param.name)) {
        QMessageBox::warning(parent, "参数错误",
            QString("缺少必需参数：%1").arg(param.displayName));
        return;
    }
}
```

---

## 七、完整的 MainController 声明

```cpp
// main_controller.h
class MainController : public QObject {
    Q_OBJECT

private slots:
    /**
     * @brief 处理参数对话框请求
     * @param algorithmName 算法名称
     * @param descriptor 算法描述符（包含参数定义）
     */
    void onRequestParameterDialog(
        const QString& algorithmName,
        const AlgorithmDescriptor& descriptor);

private:
    /**
     * @brief 根据参数定义创建对应的控件
     * @param param 参数定义
     * @param parent 父控件
     * @return 创建的控件指针
     */
    QWidget* createParameterWidget(
        const AlgorithmParameterDefinition& param,
        QWidget* parent);

    /**
     * @brief 从控件中提取参数值
     * @param widgets 控件映射表（参数名 → 控件指针）
     * @param paramDefs 参数定义列表
     * @return 参数值映射表（参数名 → 值）
     */
    QVariantMap extractParameters(
        const QMap<QString, QWidget*>& widgets,
        const QVector<AlgorithmParameterDefinition>& paramDefs);
};
```

---

## 八、总结

### 核心优势

✅ **无需写对话框类** - 减少约 50-100 行代码/算法
✅ **完美配合算法自描述** - 算法定义参数，对话框自动生成
✅ **符合 Qt 官方推荐** - 简洁、高效、易维护
✅ **易于扩展** - 添加新参数类型只需修改一处
✅ **类型安全** - 使用 qobject_cast 进行类型转换

### 代码减少量

| 组件 | 传统方式 | 动态生成方式 | 减少 |
|------|---------|-------------|------|
| 对话框类 | 每个算法 50-100 行 | 0 行 | 100% |
| MainController | 需要处理每个对话框 | 统一处理 | 80% |
| 维护成本 | 每个算法单独维护 | 统一维护 | 90% |

### 推荐指数

⭐⭐⭐⭐⭐ **强烈推荐！**

这种方案完美配合算法自描述机制，是最优雅、最高效的实现方式。

---

**文档版本**: v1.0
**创建日期**: 2025-11-18
**作者**: Claude Code
