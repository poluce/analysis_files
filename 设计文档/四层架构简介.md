# 四层架构简介

这个热分析软件用的是四层架构，参考了分层架构和领域驱动设计(DDD)的思想，主要目的是把不同的关注点分离开，让依赖关系更清晰。

## 架构总览

```
┌──────────────────────────────────────────┐
│       表示层 (Presentation)              │  用户界面与交互
│   MainWindow, ChartView, Controllers    │
├──────────────────────────────────────────┤
│       应用层 (Application)               │  业务流程协调
│   Managers, Coordinators, Services      │
├──────────────────────────────────────────┤
│        领域层 (Domain)                   │  核心业务规则
│   ThermalCurve, Algorithm Interface     │
├──────────────────────────────────────────┤
│     基础设施层 (Infrastructure)          │  技术实现
│   FileIO, Algorithm Implementations     │
└──────────────────────────────────────────┘
      ↑                ↑                ↑
    依赖方向：上层依赖下层，下层不依赖上层
```

依赖规则很简单：
- 上层可以依赖下层
- 下层不能依赖上层
- 同层之间通过接口来依赖

---

## 一、基础设施层 (Infrastructure Layer)

代码位置在 `src/infrastructure/`，这一层主要提供技术支持，不包含业务逻辑。

### 1.1 文件IO (`io/`)

| 组件 | 职责 | 文件 |
|------|------|------|
| `IFileReader` | 文件读取接口 | `i_file_reader.h` |
| `TextFileReader` | 文本文件读取器 | `text_file_reader.h/cpp` |

主要功能：
- 智能识别列（温度、时间、测量值）
- 自动检测分隔符（逗号、制表符、空格）
- 支持 .txt, .csv 格式

### 1.2 算法实现 (`algorithm/`)

| 算法 | 类名 | 特点 |
|------|------|------|
| 微分 | `DifferentiationAlgorithm` | 大窗口平滑中心差分法 |
| 积分 | `IntegrationAlgorithm` | 梯形法则 |
| 移动平均 | `MovingAverageFilterAlgorithm` | 滑动窗口平滑 |
| 基线校正 | `BaselineCorrectionAlgorithm` | 交互式线性基线拟合 |

所有算法都实现了 `IThermalAlgorithm` 接口，这样就统一了。

---

## 二、领域层 (Domain Layer)

代码位置在 `src/domain/`，这一层定义业务规则和核心模型，不依赖任何技术实现。

### 2.1 数据模型 (`model/`)

#### ThermalCurve（热分析曲线）

这是核心的业务对象，维护了两份数据：
- `rawData`：原始数据，不可变的，支持撤销
- `processedData`：处理后的数据，可以修改，用于显示

#### 双枚举分离设计

```cpp
enum class InstrumentType { TGA, DSC, ARC };        // 仪器类型
enum class SignalType {                             // 信号类型
    Raw,          // 原始信号
    Derivative,   // 微分信号
    Baseline,     // 基线
    PeakArea      // 峰面积
};
enum class PlotStyle { Line, Scatter, Both };       // 显示样式
```

这样设计的好处：
- 概念清晰，不会混淆（TGA 是仪器，DTG 是微分信号，不是一回事）
- 算法可以通用，不用针对特定仪器做特殊处理
- 以后要扩展新类型也方便

### 2.2 算法接口 (`algorithm/`)

#### IThermalAlgorithm

定义了算法的标准接口：

```cpp
class IThermalAlgorithm {
public:
    // 基础信息
    virtual QString name() const = 0;                  // 内部标识
    virtual QString displayName() const = 0;           // 显示名称
    virtual QString category() const = 0;              // 算法分类

    // 信号类型转换
    virtual SignalType getOutputSignalType(SignalType input) const = 0;

    // 上下文驱动执行
    virtual bool prepareContext(AlgorithmContext* context);
    virtual QVariant executeWithContext(AlgorithmContext* context) = 0;

    // 曲线特性
    virtual bool isAuxiliaryCurve() const { return false; }
    virtual bool isStronglyBound() const { return false; }
};
```

#### AlgorithmContext（算法上下文）

这是算法运行时的数据容器，统一管理：
- 算法参数
- 曲线引用
- 用户选择的点
- 提供类型安全的访问接口（`get<T>()`）
- 记录时间戳和数据来源

---

## 三、应用层 (Application Layer)

代码位置在 `src/application/`，这一层负责协调业务流程，把UI和领域逻辑连接起来。

### 3.1 曲线管理 (`curve/`)

#### CurveManager

负责管理曲线的生命周期：
- 曲线的增删改查
- 管理当前活动的曲线
- 发送数据变化的信号

核心方法：
```cpp
void addCurve(ThermalCurve curve);           // 添加曲线
ThermalCurve* getCurve(QString id);          // 获取曲线
void setActiveCurve(QString id);             // 设置活动曲线
```

### 3.2 算法服务 (`algorithm/`)

#### AlgorithmManager

管理所有算法：
- 维护算法注册表
- 执行算法并创建新曲线
- 自动设置父子关系

#### AlgorithmCoordinator

编排算法的执行流程：
- 收集参数
- 处理点选交互
- 协调上下文数据

执行流程大概是这样：
```
用户触发算法
  → 收集参数（如果需要）
  → 请求选点（如果需要）
  → 准备上下文
  → 执行算法
  → 处理结果
```

### 3.3 项目管理 (`project/`)

#### ProjectTreeManager

管理项目树：
- 管理曲线的树形结构
- 维护父子关系层级
- 为项目浏览器提供数据模型

### 3.4 历史管理 (`history/`)

#### HistoryManager

实现撤销/重做功能：
- 用命令模式实现的
- 管理命令栈
- 限制历史深度

### 3.5 统一初始化 (`ApplicationContext`)

按照正确的依赖顺序创建所有实例：
1. 核心数据管理（CurveManager）
2. 算法服务（AlgorithmManager, Context, Coordinator）
3. 项目管理（ProjectTreeManager）
4. UI组件（MainWindow, ChartView, ProjectExplorerView）
5. 控制器（MainController, CurveViewController）

---

## 四、表示层 (Presentation Layer)

代码位置在 `src/ui/`，这一层负责用户交互，只发射信号，不包含业务逻辑。

### 4.1 UI组件 (`ui/`)

#### MainWindow

主窗口，负责：
- 窗口布局管理
- 菜单、工具栏、停靠面板
- 信号转发

#### ChartView

图表组件：
- 基于 Qt Charts
- 支持多曲线显示、缩放、交互
- 内置活动算法状态机，管理用户与算法的交互流程

状态机的流程：
```
Idle（空闲）
  ↓ startAlgorithmInteraction()
WaitingForPoints（等待选点）
  ↓ 用户点击图表
PointsCompleted（选点完成）
  ↓ 自动触发执行
Idle（回到空闲）
```

#### ProjectExplorerView

项目浏览器：
- 树形视图
- 显示曲线及其衍生关系

### 4.2 控制器 (`ui/controller/`)

#### MainController

主控制器：
- 协调UI和业务逻辑
- 处理应用级事件

#### CurveViewController

负责协调多个组件的状态：
- 协调 CurveManager、ProjectTreeManager、ChartView、ProjectExplorerView
- 同步状态，实现双向视觉反馈

双向视觉反馈的效果：
- 图表中：选中的曲线会加粗（线宽从 1 变成 3）
- 项目树中：选中项会高亮显示

---

## 核心设计模式

### 1. 双枚举分离设计

把仪器类型和信号类型分开，避免概念混淆：
- `InstrumentType`：描述硬件（TGA/DSC/ARC）
- `SignalType`：描述数据处理状态（Raw/Derivative/Baseline/PeakArea）
- `PlotStyle`：描述显示方式（Line/Scatter/Both）

### 2. 上下文驱动执行

算法从 `AlgorithmContext` 里拉取数据，不用到处传参数：
```cpp
// 算法内部
auto curve = context->get<ThermalCurve*>("activeCurve");
int windowSize = context->get<int>("param.windowSize").value_or(50);
```

### 3. 活动算法状态机

ChartView 维护当前活动算法的状态，管理交互流程：
- 跟踪用户选点的进度
- 选够点后自动触发算法执行
- 支持随时取消

### 4. 信号槽通信

用 Qt 的信号槽实现松耦合：
- UI 发信号给 Controller：用户操作
- Manager 发信号给 Controller：状态变化通知
- Controller 发信号给 UI：更新界面

### 5. 命令模式（撤销/重做）

所有修改操作都封装成命令：
- `AlgorithmCommand`：算法执行
- `BaselineCommand`：基线校正
- `AddCurveCommand`：添加曲线

### 6. 依赖注入（ApplicationContext）

统一管理对象的生命周期：
- 依赖关系清晰
- 方便测试（可以替换成 Mock）
- 配置都在一个地方

---

## 关键数据流向

### 导入数据流

```
用户选择文件
  → DataImportWidget（预览）
  → TextFileReader（读取）
  → ThermalCurve（创建）
  → CurveManager（管理）
  → 发信号: curveAdded
  → ├─ ProjectTreeManager（更新树）
    └─ ChartView（显示图表）
```

### 算法执行流

```
用户选择算法
  → MainController
  → AlgorithmCoordinator
  → ├─ 收集参数（如果需要）
    ├─ 请求选点（如果需要）
    │   → ChartView 状态机
    │   → 用户在图表上选点
    │   → algorithmInteractionCompleted（自动）
    └─ executeAlgorithm
      → 准备 AlgorithmContext
      → AlgorithmManager::executeWithContext
      → 算法拉取数据并执行
      → 创建新曲线
      → CurveManager::addCurve
  → 发信号: curveAdded
  → ├─ ProjectTreeManager（添加为子节点）
    ├─ ChartView（显示新曲线）
    └─ CurveViewController（同步状态）
```

### 曲线选择流（双向视觉反馈）

```
用户点击项目树中的曲线
  → ProjectExplorerView::curveItemClicked
  → CurveViewController::onTreeItemClicked
  → CurveManager::setActiveCurve
  → CurveManager::activeCurveChanged（信号）
  → CurveViewController::onActiveCurveChanged
  → ├─ ChartView::highlightCurve（加粗）
    └─ ProjectTreeManager::setActiveCurve（高亮）
```

---

## 架构演进

已经完成的优化：
- 统一初始化机制（ApplicationContext）
- 算法上下文容器（AlgorithmContext）
- 算法流程协调器（AlgorithmCoordinator）
- 活动算法状态机（ChartView）
- 项目树管理器（ProjectTreeManager）
- 命令模式框架（HistoryManager + Commands）
- 双枚举扩展（SignalType 支持 Baseline/PeakArea）
- 代码重构优化（函数拆分，复杂度降低了 50%）
- 纯上下文驱动执行（executeWithContext）
- 双向视觉反馈（图表加粗 + 项目树高亮）

---

文档版本：简化版 v1.1
对应详细版：`02_四层架构详解.md`
最后更新：2025-11-07
