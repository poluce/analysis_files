# 热分析数据处理工具 - 四周架构开发计划

## 项目概述

本文档规划了从零开始构建一个基于 Qt 5.14.2 的热分析数据处理工具的四周开发计划。项目采用四层架构（DDD）设计，最终实现约 8,669 行代码，64 个源文件，支持 TGA/DSC/ARC 数据分析。

**目标架构**:
- 🏗️ 四层分层架构（表示层、应用层、领域层、基础设施层）
- 🔥 双枚举分离设计（InstrumentType + SignalType）
- 🧠 纯上下文驱动执行模式
- 🎯 命令模式实现撤销/重做
- 📊 Qt Charts 图表交互系统

**项目规模预估**:
- 📦 64 个源文件 (.cpp + .h)
- 📝 约 8,669 行 C++ 代码
- 🔬 5 种核心算法
- 🖼️ 3 个主要 UI 组件

---

## Week 1: 领域层与基础设施层基础 (Foundation)

**目标**: 建立项目框架，实现核心数据模型和基础文件 IO

### Day 1-2: 项目初始化与领域层设计

**任务清单**:
- [ ] 创建 Qt 项目结构 (`Analysis.pro`)
  - 配置 Qt 5.14.2 + MinGW 7.3.0
  - 添加 Qt Charts 模块依赖
  - 配置 UTF-8 编码支持
  - 设置 C++17 标准

- [ ] 设计目录结构
  ```
  Analysis/
  ├── src/
  │   ├── domain/           # 领域层
  │   │   ├── model/
  │   │   └── algorithm/
  │   ├── infrastructure/   # 基础设施层
  │   │   ├── io/
  │   │   └── algorithm/
  │   ├── application/      # 应用层
  │   └── ui/               # 表示层
  └── build.bat             # 构建脚本
  ```

- [ ] 实现领域层核心模型
  - `ThermalDataPoint` 结构体（温度、时间、测量值、元数据）
  - `InstrumentType` 枚举（TGA、DSC、ARC）
  - `SignalType` 枚举（Raw、Derivative、Baseline、PeakArea）
  - `PlotStyle` 枚举（Line、Scatter、Area）

**交付物**:
- ✅ 可编译的空项目
- ✅ `ThermalDataPoint.h` 完成
- ✅ 三个核心枚举定义

---

### Day 3-4: ThermalCurve 核心业务对象

**任务清单**:
- [ ] 实现 `ThermalCurve` 类 (`src/domain/model/ThermalCurve.h/cpp`)
  - 双数据设计：`rawData` 和 `processedData`
  - 曲线属性：ID、名称、颜色、仪器类型、信号类型
  - 父子关系：`parentId`、`isMainCurve`、`isAuxiliaryCurve`、`isStronglyBound`
  - 图表样式：`PlotStyle`
  - 动态单位推断：`getYAxisLabel()` 方法

- [ ] 实现曲线数据操作方法
  - `getRawData()` / `getProcessedData()`
  - `setProcessedData()` / `resetProcessedData()`
  - `getXRange()` / `getYRange()` - 数据边界计算

**交付物**:
- ✅ `ThermalCurve` 类完整实现（约 300 行）
- ✅ 单元测试（可选）

---

### Day 5-6: 文件 IO 与算法接口

**任务清单**:
- [ ] 定义算法接口 (`src/domain/algorithm/IThermalAlgorithm.h`)
  - `name()`、`displayName()`、`category()` 基本信息
  - `executeWithContext(AlgorithmContext*)` 纯虚函数
  - `prepareContext(AlgorithmContext*)` 验证方法
  - `getOutputSignalType(SignalType)` 信号类型转换
  - `inputType()` / `outputType()` 交互类型

- [ ] 实现文件读取器 (`src/infrastructure/io/`)
  - `IFileReader` 接口（`canRead()`, `read()`）
  - `TextFileReader` 实现（支持 .txt, .csv）
  - 智能列识别（温度、时间、测量值）
  - 元数据解析（仪器类型、样品信息）

- [ ] 实现第一个简单算法：移动平均滤波
  - `MovingAverageFilterAlgorithm` (`src/infrastructure/algorithm/`)
  - 实现 `executeWithContext()` 方法
  - 窗口大小参数从上下文获取

**交付物**:
- ✅ `IThermalAlgorithm` 接口定义
- ✅ `TextFileReader` 完成（约 200 行）
- ✅ `MovingAverageFilterAlgorithm` 完成（约 150 行）
- ✅ 能够加载 .txt 文件并转换为 `ThermalCurve`

---

### Day 7: Week 1 总结与代码审查

**任务清单**:
- [ ] 编写 Week 1 进度报告
- [ ] 代码审查：检查依赖方向（领域层不依赖其他层）
- [ ] 编写 `CLAUDE.md` 初始版本（架构说明）
- [ ] 构建脚本测试（`build.bat` / `rebuild.bat`）

**Week 1 里程碑**:
- ✅ 领域层完成（约 500 行代码）
- ✅ 基础设施层 IO 完成（约 300 行代码）
- ✅ 第一个算法实现
- ✅ 项目可编译运行（控制台程序，无 GUI）

---

## Week 2: 应用层服务与基础 UI

**目标**: 实现曲线管理服务、算法管理服务，搭建主窗口和图表显示

### Day 8-9: 应用层核心服务

**任务清单**:
- [ ] 实现 `CurveManager` (`src/application/curve/CurveManager.h/cpp`)
  - 曲线生命周期管理（增删改查）
  - 活动曲线（Active Curve）管理
  - 信号：`curveAdded`, `curveRemoved`, `activeCurveChanged`
  - 线程安全（如需要）

- [ ] 实现 `AlgorithmContext` (`src/application/algorithm/AlgorithmContext.h/cpp`)
  - 键值对存储：`QMap<QString, ContextValue>`
  - `ContextValue` 结构体（值、时间戳、来源）
  - 类型安全访问：`get<T>(key)` 模板方法
  - 信号：`valueChanged(key)`

- [ ] 实现 `AlgorithmManager` (`src/application/algorithm/AlgorithmManager.h/cpp`)
  - 算法注册表：`QMap<QString, IThermalAlgorithm*>`
  - `executeWithContext(name, context)` 执行接口
  - 两阶段执行：`prepareContext()` → `executeWithContext()`
  - 结果处理：创建新曲线，设置父子关系
  - 信号：`algorithmResultReady`

**交付物**:
- ✅ `CurveManager` 完成（约 300 行）
- ✅ `AlgorithmContext` 完成（约 200 行）
- ✅ `AlgorithmManager` 完成（约 400 行）

---

### Day 10-11: 主窗口与项目浏览器

**任务清单**:
- [ ] 实现 `MainWindow` (`src/ui/MainWindow.h/cpp`)
  - 菜单栏：文件、编辑、算法、视图、帮助
  - 工具栏：导入、保存、撤销/重做、算法快捷按钮
  - 停靠面板布局：左侧项目浏览器、中央图表区域
  - 状态栏：显示当前活动曲线、点坐标

- [ ] 实现 `ProjectExplorerView` (`src/ui/ProjectExplorerView.h/cpp`)
  - 基于 `QTreeView`
  - 树形结构显示曲线及其派生关系
  - 右键菜单：删除曲线、重命名、导出
  - 双击切换活动曲线

- [ ] 实现 `ProjectTreeManager` (`src/application/project/ProjectTreeManager.h/cpp`)
  - 管理 `QStandardItemModel`
  - 维护曲线的父子关系层级
  - 监听 `CurveManager` 信号同步更新树

**交付物**:
- ✅ `MainWindow` 基本布局完成（约 400 行）
- ✅ `ProjectExplorerView` 完成（约 200 行）
- ✅ `ProjectTreeManager` 完成（约 250 行）
- ✅ 可以显示空白主窗口

---

### Day 12-13: Qt Charts 图表集成

**任务清单**:
- [ ] 实现 `ThermalChart` (`src/ui/charts/ThermalChart.h/cpp`)
  - 继承自 `QChart`
  - 曲线管理：`addCurve()`, `removeCurve()`
  - 多 Y 轴支持（每条曲线独立 Y 轴）
  - 横轴模式：`XAxisMode` (Temperature / Time)
  - 自动缩放：`autoScale()` 方法

- [ ] 实现 `ThermalChartView` (`src/ui/charts/ThermalChartView.h/cpp`)
  - 继承自 `QChartView`
  - 交互模式：`InteractionMode` (View / Pick)
  - 鼠标事件处理：右键拖动平移、Ctrl+滚轮缩放
  - 碰撞检测：`findNearestPoint()`、`findCurveAtPixel()`

- [ ] 实现 `ChartView` (`src/ui/ChartView.h/cpp`)
  - 容器层：持有 `ThermalChart` 和 `ThermalChartView`
  - 活动算法状态机：`InteractionState` (Idle / WaitingForPoints / PointsCompleted)
  - 信号：`algorithmInteractionCompleted`, `interactionStateChanged`

**交付物**:
- ✅ `ThermalChart` 完成（约 600 行）
- ✅ `ThermalChartView` 完成（约 400 行）
- ✅ `ChartView` 完成（约 300 行）
- ✅ 能够显示曲线，支持缩放平移

---

### Day 14: Week 2 总结与集成测试

**任务清单**:
- [ ] 实现 `DataImportWidget` (`src/ui/DataImportWidget.h/cpp`)
  - 文件选择对话框
  - 数据预览表格（前 10 行）
  - 列映射配置（温度、时间、测量值）
  - 确认导入

- [ ] 实现基本数据流
  - 用户导入文件 → `TextFileReader` → `ThermalCurve` → `CurveManager`
  - `CurveManager` 发射 `curveAdded` → `ChartView` 显示
  - `CurveManager` 发射 `curveAdded` → `ProjectTreeManager` 更新树

- [ ] 集成测试：端到端导入显示流程

**Week 2 里程碑**:
- ✅ 应用层服务完成（约 1,500 行代码）
- ✅ 基础 UI 完成（约 1,800 行代码）
- ✅ 可以导入数据并在图表中显示
- ✅ 累计约 4,100 行代码

---

## Week 3: 控制器与算法系统

**目标**: 实现 MVC 控制器、完成核心算法、建立算法执行流程

### Day 15-16: 控制器层与统一初始化

**任务清单**:
- [ ] 实现 `ApplicationContext` (`src/application/ApplicationContext.h/cpp`)
  - 统一初始化机制：按依赖顺序构造所有实例
  - 依赖注入：将实例注入到控制器和 UI 组件
  - 生命周期管理：统一销毁顺序
  - 初始化顺序：
    1. 核心数据管理（CurveManager）
    2. 算法服务（AlgorithmManager, AlgorithmContext）
    3. 项目管理（ProjectTreeManager）
    4. UI 组件（MainWindow, ChartView, ProjectExplorerView）
    5. 控制器（MainController, CurveViewController）

- [ ] 实现 `MainController` (`src/ui/controller/MainController.h/cpp`)
  - 协调 UI 和业务逻辑
  - 槽函数：`onImportData()`, `onAlgorithmRequested()`, `onUndo()`, `onRedo()`
  - 连接信号：MainWindow ↔ CurveManager ↔ AlgorithmManager

- [ ] 实现 `CurveViewController` (`src/ui/controller/CurveViewController.h/cpp`)
  - 协调 CurveManager、ProjectTreeManager、ChartView、ProjectExplorerView
  - 状态同步：活动曲线切换、曲线显示/隐藏

**交付物**:
- ✅ `ApplicationContext` 完成（约 200 行）
- ✅ `MainController` 完成（约 500 行）
- ✅ `CurveViewController` 完成（约 300 行）

---

### Day 17-18: 核心算法实现

**任务清单**:
- [ ] 实现 `DifferentiationAlgorithm` (`src/infrastructure/algorithm/`)
  - 大窗口平滑中心差分法
  - 参数：`param.halfWindowSize`, `param.deltaTime`
  - 调试输出支持（`enableDebug`）
  - 输出信号类型：`Raw → Derivative`

- [ ] 实现 `IntegrationAlgorithm` (`src/infrastructure/algorithm/`)
  - 梯形法则积分
  - 输出信号类型：`Raw → Integrated`

- [ ] 注册算法到 `AlgorithmManager`
  - 在 `ApplicationContext` 中统一注册
  - 菜单项绑定：MainWindow → MainController → AlgorithmManager

**交付物**:
- ✅ `DifferentiationAlgorithm` 完成（约 200 行）
- ✅ `IntegrationAlgorithm` 完成（约 150 行）
- ✅ 用户可以从菜单执行微分/积分算法

---

### Day 19-20: AlgorithmCoordinator 流程编排

**任务清单**:
- [ ] 实现 `AlgorithmDescriptor` (`src/domain/algorithm/AlgorithmDescriptor.h`)
  - 算法参数元数据定义
  - 输入类型：`InputType` (None / PointSelection / DualCurve / MultiPoint)
  - 输出类型：`OutputType` (Curve / Marker / Region / ScalarValue / Composite)

- [ ] 实现 `AlgorithmCoordinator` (`src/application/algorithm/AlgorithmCoordinator.h/cpp`)
  - 流程编排：`handleAlgorithmTriggered()`
  - 状态管理：`PendingRequest` 结构体（算法名、曲线ID、参数、点选结果）
  - 信号：`requestPointSelection`, `requestParameters`
  - 执行算法：`executeAlgorithm()`
    - 清空上下文旧数据
    - 设置 activeCurve、参数、selectedPoints 到上下文
    - 调用 `AlgorithmManager::executeWithContext()`

- [ ] 集成到 MainController
  - 连接 `AlgorithmCoordinator` 信号到 ChartView
  - 用户选点完成 → 自动触发算法执行

**交付物**:
- ✅ `AlgorithmDescriptor` 完成（约 100 行）
- ✅ `AlgorithmCoordinator` 完成（约 450 行）
- ✅ 算法执行流程完整打通

---

### Day 21: Week 3 总结与功能测试

**任务清单**:
- [ ] 功能测试：端到端算法执行流程
  - 导入数据 → 选择曲线 → 执行微分 → 查看结果曲线
  - 验证父子关系显示在项目树中
  - 验证 SignalType 转换正确（Raw → Derivative）

- [ ] 性能测试：大数据集（10,000+ 点）
  - 测试导入速度
  - 测试图表渲染性能
  - 测试算法执行速度

- [ ] Bug 修复与优化

**Week 3 里程碑**:
- ✅ 控制器层完成（约 1,000 行代码）
- ✅ 核心算法完成（约 700 行代码）
- ✅ 算法执行流程完整
- ✅ 累计约 6,800 行代码

---

## Week 4: 高级功能与交互工具

**目标**: 实现命令模式（撤销/重做）、交互式算法、浮动标签、测量工具

### Day 22-23: 命令模式与历史管理

**任务清单**:
- [ ] 实现 `ICommand` 接口 (`src/domain/algorithm/ICommand.h`)
  - `execute()`, `undo()`, `redo()` 纯虚函数
  - `canExecute()`, `canUndo()` 状态检查

- [ ] 实现 `HistoryManager` (`src/application/history/HistoryManager.h/cpp`)
  - 单例模式
  - 命令栈：`m_undoStack`, `m_redoStack`（限制深度 50）
  - O(1) 查询优化：当前状态缓存
  - 方法：`executeCommand()`, `undo()`, `redo()`, `clear()`
  - 信号：`historyChanged`, `canUndoChanged`, `canRedoChanged`

- [ ] 实现命令类
  - `AddCurveCommand` - 添加曲线命令
  - `RemoveCurveCommand` - 删除曲线命令
  - `AlgorithmCommand` - 算法执行命令

- [ ] 集成到 AlgorithmManager
  - `executeWithContext()` 中使用 `AddCurveCommand` 添加结果曲线
  - MainWindow 添加撤销/重做按钮和快捷键（Ctrl+Z / Ctrl+Y）

**交付物**:
- ✅ `ICommand` 接口完成
- ✅ `HistoryManager` 完成（约 200 行）
- ✅ 三个命令类完成（约 300 行）
- ✅ 撤销/重做功能可用

---

### Day 24-25: 交互式算法（基线校正与峰面积）

**任务清单**:
- [ ] 实现 `BaselineCorrectionAlgorithm` (`src/infrastructure/algorithm/`)
  - 需要用户选择 2+ 个基线点
  - `inputType()` 返回 `InputType::PointSelection`
  - `prepareContext()` 验证 `selectedPoints` 数量
  - 线性插值或多项式拟合
  - 输出信号类型：`Raw → Baseline`

- [ ] 实现 `AlgorithmResult` (`src/domain/algorithm/AlgorithmResult.h`)
  - 统一输出容器：结果类型、曲线、标注点、区域、数值
  - `ResultType` 枚举（Curve / Marker / Region / ScalarValue / Composite）
  - 方法：`setCurve()`, `addMarker()`, `addRegion()`, `setArea()`
  - 元数据：`meta` 字段（面积、峰高、单位等）

- [ ] 实现 `PeakAreaAlgorithm` (`src/infrastructure/algorithm/`)
  - 需要用户选择 2 个点（峰的起止点）
  - 梯形积分法计算面积
  - 输出类型：`ResultType::Composite`（数值 + 曲线 + 区域 + 标注）
  - 输出信号类型：`Raw → PeakArea`

- [ ] 活动算法状态机集成
  - ChartView 启动算法交互：`startAlgorithmInteraction()`
  - 用户选点完成 → 自动发射 `algorithmInteractionCompleted` 信号
  - MainController 接收信号 → 调用 `AlgorithmCoordinator::handlePointSelectionResult()`

**交付物**:
- ✅ `BaselineCorrectionAlgorithm` 完成（约 250 行）
- ✅ `AlgorithmResult` 完成（约 200 行）
- ✅ `PeakAreaAlgorithm` 完成（约 300 行）
- ✅ 交互式算法流程完整

---

### Day 26-27: 浮动标签与测量工具

**任务清单**:
- [ ] 实现 `FloatingLabel` (`src/ui/widgets/FloatingLabel.h/cpp`)
  - 继承自 `QWidget`
  - 锚定模式：`AnchorMode` (DataAnchored / ViewAnchored)
  - 数据锚定：跟随图表缩放移动
  - 视图锚定：HUD 固定位置
  - 拖动移动（鼠标左键）
  - 缩放（Ctrl+滚轮）
  - 关闭按钮、锁定按钮
  - 自定义样式（背景、边框、字体）

- [ ] 实现 `TrapezoidMeasureTool` (`src/ui/tools/TrapezoidMeasureTool.h/cpp`)
  - 继承自 `QGraphicsObject`
  - 直角梯形绘制（两条水平线 + 一条竖直线）
  - 两个可拖动端点（自动吸附曲线）
  - 实时显示垂直距离测量值
  - 支持横轴切换（温度/时间）同步
  - 关闭按钮

- [ ] 集成到 ChartView
  - `addFloatingLabel()` / `addFloatingLabelHUD()` 方法
  - `addMeasureTool()` 方法
  - PeakAreaAlgorithm 执行后自动创建 FloatingLabel 显示面积

**交付物**:
- ✅ `FloatingLabel` 完成（约 400 行）
- ✅ `TrapezoidMeasureTool` 完成（约 350 行）
- ✅ 用户可以在图表上添加标签和测量工具

---

### Day 28: Week 4 总结与最终优化

**任务清单**:
- [ ] 曲线级联删除功能
  - 主曲线保护（`isMainCurve = true` 不能删除）
  - 递归删除所有子曲线
  - 确认对话框显示将删除的曲线列表

- [ ] UI 优化
  - 修复多 Y 轴缩放导致曲线丢失的问题
  - 修复右键拖动 Y 方向相反的问题
  - 优化 FloatingLabel 关闭按钮位置（跟随工具移动）

- [ ] 文档完善
  - 编写 `CLAUDE.md` 完整版（架构说明、编码约定、使用指南）
  - 编写 `功能说明.md` (v0.1.0-alpha)
  - 编写 `ARCHITECTURE_OPTIMIZATION_PLAN.md`（后续开发路线图）
  - 编写 `FloatingLabel_使用示例.md`
  - 编写 `曲线级联删除功能说明.md`

- [ ] 最终测试
  - 端到端功能测试
  - 性能测试（10,000+ 数据点）
  - 内存泄漏检查
  - 跨平台编译测试（Windows）

**Week 4 里程碑**:
- ✅ 命令模式完成（约 500 行代码）
- ✅ 交互式算法完成（约 750 行代码）
- ✅ UI 交互工具完成（约 750 行代码）
- ✅ 文档完善
- ✅ **项目总计约 8,669 行代码，64 个源文件**

---

## 总体时间分配

| 周次 | 主要任务 | 代码量 | 累计代码 |
|------|---------|--------|---------|
| Week 1 | 领域层 + 基础设施层 | ~800 行 | 800 行 |
| Week 2 | 应用层 + 基础 UI | ~3,300 行 | 4,100 行 |
| Week 3 | 控制器 + 算法系统 | ~2,700 行 | 6,800 行 |
| Week 4 | 高级功能 + 优化 | ~2,000 行 | 8,800 行 |

---

## 技术债务管理

### 保留用于后续优化的功能

**Phase 2 - 项目管理**:
- ProjectManager 多项目支持
- 项目保存/加载功能（JSON 或 XML）
- 曲线导出（CSV、Excel）
- 图表导出（PNG、SVG、PDF）

**Phase 3 - 算法扩展**:
- 峰值检测算法
- 归一化算法
- 外推法（Onset/Endset 温度）
- 切线法

**Phase 4 - 高级功能**:
- 动力学分析（Kissinger、Ozawa、Flynn-Wall-Ozawa）
- 数据库支持
- 批处理和脚本系统
- 插件系统
- 报告生成系统

---

## 关键成功因素

### 架构设计原则

1. **严格分层**:
   - 表示层 → 应用层 → 领域层 → 基础设施层
   - 单向依赖，上层依赖下层
   - 领域层不依赖任何其他层

2. **依赖注入**:
   - 使用 ApplicationContext 统一初始化
   - 避免循环依赖
   - 易于单元测试（Mock 对象）

3. **信号槽解耦**:
   - UI 层只发射信号，不包含业务逻辑
   - 控制器负责协调 UI 和业务逻辑
   - Manager 通过信号通知状态变化

4. **命令模式**:
   - 所有修改数据的操作封装为 Command
   - 支持撤销/重做
   - 历史记录限制深度（防止内存溢出）

### 代码质量要求

- ✅ C++17 标准
- ✅ UTF-8 编码支持（中文注释友好）
- ✅ 命名规范：m_前缀、驼峰命名、语义化变量名
- ✅ 注释清晰：类职责、方法用途、参数说明
- ✅ 单一职责：每个类职责明确
- ✅ 接口驱动：定义抽象接口，易于扩展

### 性能优化策略

- ⚡ **O(1) 查询**: HistoryManager 当前状态缓存
- ⚡ **双数据设计**: rawData + processedData，避免重复计算
- ⚡ **按需更新**: 信号驱动更新，避免全局刷新
- ⚡ **大数据优化**: 使用 `QVector::reserve()` 预分配内存

---

## 风险管理

### 潜在风险

1. **Qt Charts 性能**:
   - **风险**: 超过 10,000 点可能卡顿
   - **缓解**: 使用 `QLineSeries::replace()` 批量更新，避免逐点添加

2. **多 Y 轴复杂度**:
   - **风险**: 每条曲线独立 Y 轴，布局复杂
   - **缓解**: ThermalChart 封装 Y 轴管理逻辑

3. **撤销栈内存占用**:
   - **风险**: 大数据集曲线占用大量内存
   - **缓解**: 限制历史深度（50 步），使用智能指针

4. **交互流程复杂**:
   - **风险**: AlgorithmCoordinator 状态机复杂，难以调试
   - **缓解**: 详细日志输出，状态转换清晰

### 应对策略

- **每周代码审查**: 检查架构是否符合设计原则
- **单元测试**: 核心算法、Manager 类编写单元测试
- **性能基准**: 建立性能基准测试，及时发现性能退化
- **文档先行**: 先写设计文档，再实现代码

---

## 总结

本计划将一个工业级热分析软件的架构开发分解为 4 周 28 天的可执行任务。按照此计划，团队可以从零开始构建出一个功能完善、架构清晰、易于扩展的桌面应用程序。

**核心价值**:
- 🏗️ **工业级架构**: 四层分层 + DDD，易维护、易测试
- 🔥 **创新设计模式**: 双枚举分离、纯上下文驱动、统一输出容器
- 🎯 **完整功能**: 数据导入、图表显示、算法执行、撤销重做、交互工具
- 📚 **详尽文档**: CLAUDE.md、设计文档、使用指南一应俱全

**最终交付**:
- ✅ 约 8,669 行 C++ 代码
- ✅ 64 个源文件
- ✅ 5 种算法实现
- ✅ 完整的 MVC 架构
- ✅ 可扩展的插件化算法系统

---

**文档版本**: v1.0
**创建日期**: 2025-11-11
**作者**: Claude Code
