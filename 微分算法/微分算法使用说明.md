# 微分算法函数库 - 使用说明

## 📚 文件清单

- **微分算法函数封装.h** - 头文件（函数声明）
- **微分算法函数封装.cpp** - 实现文件（函数定义）
- **微分算法使用说明.md** - 本文档
- **微分算法分析报告.md** - 算法原理分析

---

## 🚀 快速开始

### 1. 集成到项目

将以下文件添加到你的Qt项目中：

```cpp
// 在你的.pro文件中添加
HEADERS += 微分算法函数封装.h
SOURCES += 微分算法函数封装.cpp

// 在需要使用的源文件中引入
#include "微分算法函数封装.h"
```

### 2. 基础示例

```cpp
#include "微分算法函数封装.h"

// 准备数据
QList<double> temperature = {20, 25, 30, 35, ...};  // 温度数据
QList<double> mass = {100, 99.5, 98.8, 98.0, ...};  // 质量数据

// 计算DTG微分
QList<double> dtgX, dtgY;
if (calculateDTGDerivative(temperature, mass, 50, 0.1, dtgX, dtgY)) {
    qDebug() << "微分计算成功！";
    // dtgX和dtgY现在包含微分曲线数据
}
```

---

## 📖 函数详解

### 函数1: DTG微分算法 ⭐⭐⭐⭐⭐

**最常用的函数，适合大多数TG/DSC数据分析**

#### 函数签名

```cpp
bool calculateDTGDerivative(
    const QList<double>& xData,      // 输入: X轴数据（温度/时间）
    const QList<double>& yData,      // 输入: Y轴数据（质量/热流）
    int halfWin,                      // 输入: 半窗口大小
    double dt,                        // 输入: 时间步长
    QList<double>& outX,             // 输出: 微分曲线X坐标
    QList<double>& outY              // 输出: 微分曲线Y坐标（导数）
);
```

#### 参数详解

| 参数 | 类型 | 说明 | 推荐值 |
|------|------|------|--------|
| `xData` | const QList<double>& | 横坐标数据（温度/时间） | - |
| `yData` | const QList<double>& | 纵坐标数据（质量/热流） | - |
| `halfWin` | int | 半窗口大小（单侧点数） | 25-50 |
| `dt` | double | 虚拟时间步长 | 0.1 |
| `outX` | QList<double>& | 输出微分曲线X坐标 | - |
| `outY` | QList<double>& | 输出微分曲线Y坐标 | - |

#### 返回值

- `true`: 计算成功
- `false`: 计算失败（数据点不足或参数错误）

#### 使用示例

```cpp
// 示例1: 标准TG分析
QList<double> temp, mass, dtgX, dtgY;

// 假设已加载数据...
// temp << 25.0 << 26.0 << 27.0 << ...;
// mass << 100.0 << 99.8 << 99.6 << ...;

// 使用50点窗口计算微分
if (calculateDTGDerivative(temp, mass, 50, 0.1, dtgX, dtgY)) {
    qDebug() << "DTG计算成功，共" << dtgY.size() << "个点";

    // 绘制微分曲线
    QLineSeries* dtgSeries = new QLineSeries();
    for (int i = 0; i < dtgX.size(); ++i) {
        dtgSeries->append(dtgX[i], dtgY[i]);
    }
    dtgSeries->setName("DTG微分曲线");
}
```

#### 窗口大小选择指南

```cpp
// 低噪声数据（高质量仪器）
calculateDTGDerivative(x, y, 10, 0.1, outX, outY);  // 保留更多细节

// 中噪声数据（常规实验）
calculateDTGDerivative(x, y, 25, 0.1, outX, outY);  // 平衡模式

// 高噪声数据（老旧仪器/不稳定条件）
calculateDTGDerivative(x, y, 50, 0.1, outX, outY);  // 强平滑
```

---

### 函数2: 电化学微分算法 ⭐⭐⭐

**适合电化学数据分析**

#### 函数签名

```cpp
bool calculateElectrochemicalDerivative(
    const QList<double>& xData,
    const QList<double>& yData,
    int windowSize,                   // 窗口大小（默认25）
    double normFactor,                // 归一化系数（默认0.96）
    QList<double>& outX,
    QList<double>& outY
);
```

#### 使用示例

```cpp
// 计算电压对时间的导数
QList<double> time, voltage, dvX, dvY;

calculateElectrochemicalDerivative(time, voltage, 25, 0.96, dvX, dvY);
```

---

### 函数3: 移动平均平滑 ⭐⭐⭐⭐

**预处理噪声数据**

#### 函数签名

```cpp
QList<double> smoothWithMovingAverage(
    const QList<double>& data,        // 输入数据
    int windowSize                    // 窗口大小
);
```

#### 使用示例

```cpp
// 对原始数据进行平滑
QList<double> rawData = {1.2, 1.5, 1.3, 1.6, 1.4, ...};
QList<double> smoothedData = smoothWithMovingAverage(rawData, 10);

// 平滑后的数据更适合后续分析
```

---

### 函数4: 标准中心差分 ⭐⭐⭐

**适合低噪声、高精度数据**

#### 函数签名

```cpp
bool calculateCentralDifference(
    const QList<double>& xData,
    const QList<double>& yData,
    QList<double>& outX,
    QList<double>& outY
);
```

#### 使用示例

```cpp
// 高质量数据的快速微分
QList<double> x, y, derivX, derivY;

if (calculateCentralDifference(x, y, derivX, derivY)) {
    // 计算速度快，精度高
}
```

---

### 函数5: 五点模板差分 ⭐⭐⭐⭐

**四阶精度算法**

#### 函数签名

```cpp
bool calculateFivePointDifference(
    const QList<double>& xData,
    const QList<double>& yData,
    QList<double>& outX,
    QList<double>& outY
);
```

#### 使用示例

```cpp
// 比中心差分更精确
calculateFivePointDifference(xData, yData, outX, outY);
```

---

### 函数6: 自适应窗口微分 ⭐⭐⭐⭐⭐

**智能选择窗口大小，推荐新手使用**

#### 函数签名

```cpp
bool calculateAdaptiveDerivative(
    const QList<double>& xData,
    const QList<double>& yData,
    QList<double>& outX,
    QList<double>& outY,
    int* outWindowSize = nullptr      // 可选：返回使用的窗口大小
);
```

#### 使用示例

```cpp
QList<double> x, y, derivX, derivY;
int usedWindow;

// 自动分析数据噪声水平，选择最佳窗口
if (calculateAdaptiveDerivative(x, y, derivX, derivY, &usedWindow)) {
    qDebug() << "自动选择的窗口大小:" << usedWindow;
}
```

#### 自动选择逻辑

```
噪声水平 < 0.01  → 窗口 = 5   (低噪声)
噪声水平 < 0.1   → 窗口 = 25  (中噪声)
噪声水平 ≥ 0.1   → 窗口 = 50  (高噪声)
```

---

### 函数7: 先平滑再微分 ⭐⭐⭐⭐

**两步法处理极高噪声数据**

#### 函数签名

```cpp
bool calculateSmoothThenDifferentiate(
    const QList<double>& xData,
    const QList<double>& yData,
    int smoothWindow,                 // 平滑窗口大小
    QList<double>& outX,
    QList<double>& outY
);
```

#### 使用示例

```cpp
// 先用15点窗口平滑，再计算微分
calculateSmoothThenDifferentiate(xData, yData, 15, outX, outY);
```

---

### 函数8: Qt图表专用版本 ⭐⭐⭐⭐⭐

**直接处理QVector<QPointF>格式**

#### 函数签名

```cpp
QVector<QPointF> calculateDTGDerivativeFromPoints(
    const QVector<QPointF>& points,   // 输入点集
    int halfWin = 50,                 // 半窗口大小
    double dt = 0.1                   // 时间步长
);
```

#### 使用示例

```cpp
// 从Qt图表曲线直接计算微分
QLineSeries* originalSeries = ...; // 原始曲线

// 获取原始数据点
const QVector<QPointF>& points = originalSeries->pointsVector();

// 计算微分（一行代码搞定！）
QVector<QPointF> dtgPoints = calculateDTGDerivativeFromPoints(points);

// 创建微分曲线
QLineSeries* dtgSeries = new QLineSeries();
dtgSeries->replace(dtgPoints);
dtgSeries->setName("DTG");
chart->addSeries(dtgSeries);
```

---

### 函数9: 查找最大导数点 ⭐⭐⭐⭐⭐

**找出分解速率最快的温度点**

#### 函数签名

```cpp
bool findMaxDerivativePoint(
    const QList<double>& derivativeX,  // 微分曲线X坐标
    const QList<double>& derivativeY,  // 微分曲线Y坐标
    double& maxX,                      // 输出：最大导数点的X坐标
    double& maxY                       // 输出：最大导数值
);
```

#### 使用示例

```cpp
QList<double> dtgX, dtgY;
calculateDTGDerivative(temp, mass, 50, 0.1, dtgX, dtgY);

// 查找最大分解速率点
double maxTempAtMaxRate, maxRate;
if (findMaxDerivativePoint(dtgX, dtgY, maxTempAtMaxRate, maxRate)) {
    qDebug() << "最大分解速率温度:" << maxTempAtMaxRate << "°C";
    qDebug() << "最大分解速率:" << maxRate << "%/min";

    // 在图上标记这个点
    QScatterSeries* marker = new QScatterSeries();
    marker->append(maxTempAtMaxRate, maxRate);
    marker->setMarkerSize(15);
    marker->setColor(Qt::red);
}
```

---

### 函数10: 查找极值点（峰和谷） ⭐⭐⭐⭐

**分析多个分解阶段**

#### 函数签名

```cpp
void findDerivativeExtrema(
    const QList<double>& derivativeX,
    const QList<double>& derivativeY,
    double threshold,                  // 阈值（0.0-1.0）
    QList<double>& peakX,             // 输出：所有峰的X坐标
    QList<double>& peakY,             // 输出：所有峰的Y值
    QList<double>& valleyX,           // 输出：所有谷的X坐标
    QList<double>& valleyY            // 输出：所有谷的Y值
);
```

#### 使用示例

```cpp
QList<double> dtgX, dtgY;
calculateDTGDerivative(temp, mass, 50, 0.1, dtgX, dtgY);

// 查找所有显著的峰和谷
QList<double> peakX, peakY, valleyX, valleyY;
findDerivativeExtrema(dtgX, dtgY, 0.1, peakX, peakY, valleyX, valleyY);

qDebug() << "找到" << peakX.size() << "个分解阶段";

// 在图上标记所有峰
for (int i = 0; i < peakX.size(); ++i) {
    qDebug() << "第" << (i+1) << "阶段，温度:" << peakX[i]
             << "°C，速率:" << peakY[i] << "%/min";
}
```

---

## 🎯 使用场景与推荐

### 场景1: 标准TG分析

```cpp
// 读取TG数据
QList<double> temp, mass;
// ... 从文件加载数据 ...

// 计算DTG微分
QList<double> dtgX, dtgY;
calculateDTGDerivative(temp, mass, 50, 0.1, dtgX, dtgY);

// 查找最大分解速率
double tMax, rateMax;
findMaxDerivativePoint(dtgX, dtgY, tMax, rateMax);

qDebug() << "主要分解温度:" << tMax << "°C";
```

### 场景2: 多步分解分析

```cpp
// 计算微分
QList<double> dtgX, dtgY;
calculateDTGDerivative(temp, mass, 50, 0.1, dtgX, dtgY);

// 查找所有分解阶段
QList<double> peakX, peakY, valleyX, valleyY;
findDerivativeExtrema(dtgX, dtgY, 0.15, peakX, peakY, valleyX, valleyY);

// 分析每个阶段
for (int i = 0; i < peakX.size(); ++i) {
    qDebug() << "分解阶段" << (i+1);
    qDebug() << "  温度:" << peakX[i] << "°C";
    qDebug() << "  速率:" << peakY[i] << "%/min";
}
```

### 场景3: DSC热流分析

```cpp
// DSC数据通常噪声较大
QList<double> temp, heatFlow;
// ... 加载数据 ...

// 先平滑再微分
QList<double> derivX, derivY;
calculateSmoothThenDifferentiate(temp, heatFlow, 20, derivX, derivY);

// 或者使用自适应算法
int window;
calculateAdaptiveDerivative(temp, heatFlow, derivX, derivY, &window);
qDebug() << "自动选择窗口:" << window;
```

### 场景4: 电化学循环伏安

```cpp
QList<double> voltage, current;
// ... 加载CV数据 ...

// 计算电流对电压的导数
QList<double> dvX, dvY;
calculateElectrochemicalDerivative(voltage, current, 25, 0.96, dvX, dvY);
```

### 场景5: Qt图表集成

```cpp
void MainWindow::onCalculateDerivativeClicked()
{
    // 获取当前选中的曲线
    QXYSeries* activeSeries = getSelectedSeries();
    if (!activeSeries) return;

    // 直接从图表数据计算微分
    QVector<QPointF> dtgPoints = calculateDTGDerivativeFromPoints(
        activeSeries->pointsVector(), 50, 0.1);

    // 创建微分曲线
    QLineSeries* dtgSeries = new QLineSeries();
    dtgSeries->replace(dtgPoints);
    dtgSeries->setName("DTG");
    dtgSeries->setPen(QPen(Qt::blue, 2));

    // 添加到图表
    chart->addSeries(dtgSeries);
    dtgSeries->attachAxis(chart->axisX());

    // 创建新的Y轴用于微分曲线
    QValueAxis* dtgAxis = new QValueAxis();
    dtgAxis->setTitleText("DTG (mg/min)");
    chart->addAxis(dtgAxis, Qt::AlignLeft);
    dtgSeries->attachAxis(dtgAxis);
}
```

---

## ⚙️ 参数调优指南

### halfWin (半窗口大小)

**作用**: 控制平滑程度和时间分辨率

| 值 | 平滑度 | 分辨率 | 适用场景 |
|----|--------|--------|----------|
| 5-10 | 低 | 高 | 低噪声数据，需要保留快速变化 |
| 20-30 | 中 | 中 | 平衡模式，大多数情况适用 |
| 40-60 | 高 | 低 | 高噪声数据，需要平滑曲线 |
| 80-100 | 很高 | 很低 | 极高噪声，只关注主要趋势 |

**选择建议**:
```cpp
// 信噪比估算
double signalRange = maxY - minY;
double noiseLevel = estimateNoise(yData);
double SNR = signalRange / noiseLevel;

if (SNR > 100) {
    halfWin = 10;  // 高信噪比
} else if (SNR > 20) {
    halfWin = 25;  // 中信噪比
} else {
    halfWin = 50;  // 低信噪比
}
```

### dt (时间步长)

**作用**: 影响微分值的单位和数值大小

**常用设置**:
- `dt = 0.1`: 默认值，适合大多数情况
- `dt = 1.0`: 如果希望微分值更大
- `dt = 采样间隔`: 匹配实际时间单位

### smoothWindow (平滑窗口)

**作用**: 预处理平滑的强度

**选择规则**:
```
采样频率 10 Hz  → smoothWindow = 20-50
采样频率 1 Hz   → smoothWindow = 5-15
采样频率 0.1 Hz → smoothWindow = 3-8
```

### threshold (极值检测阈值)

**作用**: 控制峰谷检测的灵敏度

| 值 | 灵敏度 | 适用场景 |
|----|--------|----------|
| 0.05-0.1 | 高 | 找出所有可能的峰 |
| 0.1-0.3 | 中 | 标准检测（推荐） |
| 0.3-0.5 | 低 | 只找主要的峰 |

```cpp
// 宽松检测：找出所有小峰
findDerivativeExtrema(dtgX, dtgY, 0.05, peakX, peakY, valleyX, valleyY);

// 严格检测：只找主要峰
findDerivativeExtrema(dtgX, dtgY, 0.3, peakX, peakY, valleyX, valleyY);
```

---

## 🐛 常见问题与解决

### 问题1: 返回false，计算失败

**原因**: 数据点不足

```cpp
// 检查数据量
int minPoints = 2 * halfWin + 1;
if (yData.size() < minPoints) {
    qDebug() << "数据点不足！需要至少" << minPoints << "个点";
    qDebug() << "实际只有" << yData.size() << "个点";

    // 解决方案1：减小窗口
    halfWin = yData.size() / 3;

    // 解决方案2：使用自适应算法
    calculateAdaptiveDerivative(x, y, outX, outY);
}
```

### 问题2: 微分曲线太"毛刺"

**原因**: 窗口太小或噪声太大

```cpp
// 解决方案1：增大窗口
calculateDTGDerivative(x, y, 80, 0.1, outX, outY);  // 从50增到80

// 解决方案2：先平滑再微分
calculateSmoothThenDifferentiate(x, y, 20, outX, outY);

// 解决方案3：使用自适应算法
calculateAdaptiveDerivative(x, y, outX, outY);
```

### 问题3: 微分曲线太平滑，细节丢失

**原因**: 窗口太大

```cpp
// 减小窗口
calculateDTGDerivative(x, y, 15, 0.1, outX, outY);  // 从50减到15

// 或使用五点模板
calculateFivePointDifference(x, y, outX, outY);
```

### 问题4: 峰位置不准确

**原因**: 大窗口导致延迟

```cpp
// 解决方案：使用较小窗口
calculateDTGDerivative(x, y, 20, 0.1, outX, outY);

// 或使用中心差分（无延迟）
calculateCentralDifference(x, y, outX, outY);
```

### 问题5: 找不到峰

**原因**: 阈值设置太高

```cpp
// 降低阈值
findDerivativeExtrema(dtgX, dtgY, 0.05, peakX, peakY, valleyX, valleyY);

// 检查微分曲线范围
double minDeriv = *std::min_element(dtgY.begin(), dtgY.end());
double maxDeriv = *std::max_element(dtgY.begin(), dtgY.end());
qDebug() << "微分值范围:" << minDeriv << "到" << maxDeriv;
```

---

## 📊 性能优化建议

### 1. 数据量大时的优化

```cpp
// 对于超大数据集（>100,000点），考虑降采样
QList<double> downsampledX, downsampledY;
int step = yData.size() / 10000;  // 降采样到约10000点

for (int i = 0; i < yData.size(); i += step) {
    downsampledX.append(xData[i]);
    downsampledY.append(yData[i]);
}

// 在降采样数据上计算微分
calculateDTGDerivative(downsampledX, downsampledY, 50, 0.1, outX, outY);
```

### 2. 实时计算优化

```cpp
// 使用较小窗口加快计算
calculateDTGDerivative(x, y, 25, 0.1, outX, outY);  // 窗口25比50快一倍

// 或使用快速中心差分
calculateCentralDifference(x, y, outX, outY);  // 最快
```

### 3. 内存优化

```cpp
// 及时释放不需要的数据
{
    QList<double> tempX, tempY;
    calculateDTGDerivative(x, y, 50, 0.1, tempX, tempY);
    // 使用tempX和tempY...
}  // 自动释放内存
```

---

## 🔬 算法选择决策树

```
开始
  │
  ├─ 是否了解数据噪声水平？
  │   ├─ 否 → 使用 calculateAdaptiveDerivative() ⭐推荐
  │   └─ 是 ↓
  │
  ├─ 噪声水平如何？
  │   ├─ 低噪声（SNR > 100）
  │   │   └─ 使用 calculateCentralDifference() 或 calculateFivePointDifference()
  │   │
  │   ├─ 中噪声（SNR 20-100）
  │   │   └─ 使用 calculateDTGDerivative(x, y, 25, 0.1, ...)
  │   │
  │   └─ 高噪声（SNR < 20）
  │       ├─ 使用 calculateDTGDerivative(x, y, 50, 0.1, ...)
  │       └─ 或 calculateSmoothThenDifferentiate(x, y, 20, ...)
  │
  ├─ 是否使用Qt图表？
  │   └─ 是 → 使用 calculateDTGDerivativeFromPoints() ⭐推荐
  │
  └─ 是否需要查找特征点？
      └─ 是 → 先计算微分，再使用 findMaxDerivativePoint() 或 findDerivativeExtrema()
```

---

## 📝 完整应用示例

### 示例1: 完整的TG分析流程

```cpp
#include "微分算法函数封装.h"

void analyzeTGData(const QString& filename)
{
    // 1. 读取数据
    QList<double> temperature, mass;
    // ... 从文件读取数据的代码 ...

    // 2. 计算DTG微分
    QList<double> dtgX, dtgY;
    if (!calculateDTGDerivative(temperature, mass, 50, 0.1, dtgX, dtgY)) {
        qDebug() << "微分计算失败！";
        return;
    }

    // 3. 查找最大分解速率点
    double tMax, rateMax;
    if (findMaxDerivativePoint(dtgX, dtgY, tMax, rateMax)) {
        qDebug() << "=== 主要分解特征 ===";
        qDebug() << "最大分解温度:" << tMax << "°C";
        qDebug() << "最大分解速率:" << rateMax << "%/min";
    }

    // 4. 查找所有分解阶段
    QList<double> peakX, peakY, valleyX, valleyY;
    findDerivativeExtrema(dtgX, dtgY, 0.15, peakX, peakY, valleyX, valleyY);

    qDebug() << "\n=== 分解阶段分析 ===";
    qDebug() << "共发现" << peakX.size() << "个分解阶段:";
    for (int i = 0; i < peakX.size(); ++i) {
        qDebug() << "阶段" << (i+1) << ": 温度 =" << peakX[i]
                 << "°C, 速率 =" << peakY[i] << "%/min";
    }

    // 5. 绘制图表
    plotTGCurves(temperature, mass, dtgX, dtgY, peakX, peakY);
}
```

### 示例2: 不同噪声水平的处理

```cpp
void processWithDifferentNoises()
{
    QList<double> x, y;
    // ... 加载数据 ...

    // 估算噪声
    double noise = estimateNoiseLevel(y);

    QList<double> derivX, derivY;

    if (noise < 0.01) {
        // 低噪声：快速中心差分
        qDebug() << "检测到低噪声，使用中心差分";
        calculateCentralDifference(x, y, derivX, derivY);

    } else if (noise < 0.1) {
        // 中噪声：中等窗口DTG
        qDebug() << "检测到中等噪声，使用DTG(25点窗口)";
        calculateDTGDerivative(x, y, 25, 0.1, derivX, derivY);

    } else {
        // 高噪声：大窗口或两步法
        qDebug() << "检测到高噪声，使用DTG(50点窗口)";
        calculateDTGDerivative(x, y, 50, 0.1, derivX, derivY);
    }
}

// 辅助函数：估算噪声
double estimateNoiseLevel(const QList<double>& data)
{
    if (data.size() < 10) return 0.0;

    QList<double> diffs;
    for (int i = 1; i < std::min(100, data.size()); ++i) {
        diffs.append(std::abs(data[i] - data[i-1]));
    }

    std::sort(diffs.begin(), diffs.end());
    return diffs[diffs.size() / 2];  // 中位数
}
```

---

## 📚 参考资料

1. **算法原理**: 见"微分算法分析报告.md"
2. **源代码**: 见"微分算法函数封装.cpp"
3. **函数声明**: 见"微分算法函数封装.h"

---

## 📞 技术支持

如果遇到问题，请检查：

1. ✅ 数据点数是否足够（至少101点对于halfWin=50）
2. ✅ X和Y数据长度是否一致
3. ✅ 参数是否合理（halfWin > 0, dt > 0等）
4. ✅ 数据是否包含无效值（NaN, Inf）

---

**文档版本**: 1.0
**更新日期**: 2025-10-31
**适用范围**: Qt 5.x / Qt 6.x
