# 四层架构简介

热分析软件的四层架构设计，基于分层架构模式和领域驱动设计(DDD)，实现关注点分离和清晰的依赖控制。

## 架构总览

```
┌──────────────────────────────────────────┐
│       表示层 (Presentation)              │  用户界面与交互
│   MainWindow, ChartView, Controllers    │
├──────────────────────────────────────────┤
│       应用层 (Application)               │  业务流程协调
│   Managers, Coordinators, Services      │
├──────────────────────────────────────────┤
│        领域层 (Domain)                   │  核心业务规则
│   ThermalCurve, Algorithm Interface     │
├──────────────────────────────────────────┤
│     基础设施层 (Infrastructure)          │  技术实现
│   FileIO, Algorithm Implementations     │
└──────────────────────────────────────────┘
      ↑                ↑                ↑
    依赖方向：上层依赖下层，下层不依赖上层
```

**核心原则**：
- ✅ 上层可以依赖下层
- ❌ 下层不能依赖上层
- ✅ 同层通过接口依赖

---

## 一、基础设施层 (Infrastructure Layer)

**位置**：`src/infrastructure/`
**职责**：提供技术支持，不包含业务逻辑

### 1.1 文件IO (`io/`)

| 组件 | 职责 | 文件 |
|------|------|------|
| `IFileReader` | 文件读取接口 | `i_file_reader.h` |
| `TextFileReader` | 文本文件读取器 | `text_file_reader.h/cpp` |

**特性**：
- 智能列识别（温度、时间、测量值）
- 自动分隔符检测（逗号、制表符、空格）
- 支持 .txt, .csv 格式

### 1.2 算法实现 (`algorithm/`)

| 算法 | 类名 | 特点 |
|------|------|------|
| 微分 | `DifferentiationAlgorithm` | 大窗口平滑中心差分法 |
| 积分 | `IntegrationAlgorithm` | 梯形法则 |
| 移动平均 | `MovingAverageFilterAlgorithm` | 滑动窗口平滑 |
| 基线校正 | `BaselineCorrectionAlgorithm` | 交互式线性基线拟合 |

**统一接口**：所有算法实现 `IThermalAlgorithm` 接口

---

## 二、领域层 (Domain Layer)

**位置**：`src/domain/`
**职责**：定义业务规则和核心模型，不依赖任何技术实现

### 2.1 数据模型 (`model/`)

#### ThermalCurve（热分析曲线）
核心业务对象，维护双份数据：
- `rawData`：原始数据（不可变，支持撤销）
- `processedData`：处理数据（可修改，用于显示）

#### 双枚举分离设计
```cpp
enum class InstrumentType { TGA, DSC, ARC };        // 仪器类型
enum class SignalType {                             // 信号类型
    Raw,          // 原始信号
    Derivative,   // 微分信号
    Baseline,     // 基线
    PeakArea      // 峰面积
};
enum class PlotStyle { Line, Scatter, Both };       // 显示样式
```

**优势**：
- ✅ 概念清晰，避免混淆（TGA ≠ DTG）
- ✅ 算法通用化，无需特殊处理
- ✅ 易于扩展新类型

### 2.2 算法接口 (`algorithm/`)

#### IThermalAlgorithm
定义算法的标准契约：

```cpp
class IThermalAlgorithm {
public:
    // 基础信息
    virtual QString name() const = 0;                  // 内部标识
    virtual QString displayName() const = 0;           // 显示名称
    virtual QString category() const = 0;              // 算法分类

    // 信号类型转换
    virtual SignalType getOutputSignalType(SignalType input) const = 0;

    // 上下文驱动执行
    virtual bool prepareContext(AlgorithmContext* context);
    virtual QVariant executeWithContext(AlgorithmContext* context) = 0;

    // 曲线特性
    virtual bool isAuxiliaryCurve() const { return false; }
    virtual bool isStronglyBound() const { return false; }
};
```

#### AlgorithmContext（算法上下文）
统一的算法运行时数据容器：
- 存储算法参数、曲线引用、用户选点等
- 提供类型安全的访问接口（`get<T>()`）
- 记录时间戳和数据来源

---

## 三、应用层 (Application Layer)

**位置**：`src/application/`
**职责**：协调业务流程，连接UI和领域逻辑

### 3.1 曲线管理 (`curve/`)

#### CurveManager
- 曲线的增删改查
- 管理活动曲线
- 发射数据变化信号

**核心方法**：
```cpp
void addCurve(ThermalCurve curve);           // 添加曲线
ThermalCurve* getCurve(QString id);          // 获取曲线
void setActiveCurve(QString id);             // 设置活动曲线
```

### 3.2 算法服务 (`algorithm/`)

#### AlgorithmManager
- 管理算法注册表
- 执行算法并创建新曲线
- 自动设置父子关系

#### AlgorithmCoordinator
- 编排算法执行流程
- 处理参数收集、点选交互
- 协调上下文数据

**执行流程**：
```
用户触发算法
  → 收集参数（如需要）
  → 请求选点（如需要）
  → 准备上下文
  → 执行算法
  → 处理结果
```

### 3.3 项目管理 (`project/`)

#### ProjectTreeManager
- 管理曲线的树形结构
- 维护父子关系层级
- 提供项目浏览器数据模型

### 3.4 历史管理 (`history/`)

#### HistoryManager
- 实现撤销/重做功能（命令模式）
- 管理命令栈
- 限制历史深度

### 3.5 统一初始化 (`ApplicationContext`)

按正确的依赖顺序创建所有实例：
1. 核心数据管理（CurveManager）
2. 算法服务（AlgorithmManager, Context, Coordinator）
3. 项目管理（ProjectTreeManager）
4. UI组件（MainWindow, ChartView, ProjectExplorerView）
5. 控制器（MainController, CurveViewController）

---

## 四、表示层 (Presentation Layer)

**位置**：`src/ui/`
**职责**：用户交互，只发射信号，不包含业务逻辑

### 4.1 UI组件 (`ui/`)

#### MainWindow
- 主窗口布局管理
- 菜单、工具栏、停靠面板
- 信号转发

#### ChartView
- 基于 Qt Charts 的图表组件
- 多曲线显示、缩放、交互
- **活动算法状态机**：管理用户与算法的交互流程

**状态机流程**：
```
Idle（空闲）
  ↓ startAlgorithmInteraction()
WaitingForPoints（等待选点）
  ↓ 用户点击图表
PointsCompleted（选点完成）
  ↓ 自动触发执行
Idle（回到空闲）
```

#### ProjectExplorerView
- 项目浏览器树形视图
- 显示曲线及其衍生关系

### 4.2 控制器 (`ui/controller/`)

#### MainController
- 主控制器，协调UI和业务逻辑
- 处理应用级事件

#### CurveViewController
- 协调 CurveManager、ProjectTreeManager、ChartView、ProjectExplorerView
- 同步状态，实现双向视觉反馈

**双向视觉反馈**：
- 图表中：选中曲线加粗（线宽 1→3）
- 项目树中：选中项高亮显示

---

## 核心设计模式

### 1. 双枚举分离设计
分离仪器类型和信号类型，避免概念混淆：
- `InstrumentType`：描述硬件（TGA/DSC/ARC）
- `SignalType`：描述数据处理状态（Raw/Derivative/Baseline/PeakArea）
- `PlotStyle`：描述显示方式（Line/Scatter/Both）

### 2. 上下文驱动执行
算法从 `AlgorithmContext` 拉取数据，避免参数传递：
```cpp
// 算法内部
auto curve = context->get<ThermalCurve*>("activeCurve");
int windowSize = context->get<int>("param.windowSize").value_or(50);
```

### 3. 活动算法状态机
ChartView 维护当前活动算法状态，管理交互流程：
- 跟踪用户选点进度
- 自动触发算法执行
- 提供可取消性

### 4. 信号槽通信
松耦合的组件间通信：
- UI → Controller：用户操作信号
- Manager → Controller：状态变化通知
- Controller → UI：更新界面

### 5. 命令模式（撤销/重做）
所有修改操作封装为命令：
- `AlgorithmCommand`：算法执行
- `BaselineCommand`：基线校正
- `AddCurveCommand`：添加曲线

### 6. 依赖注入（ApplicationContext）
统一管理对象生命周期：
- 清晰的依赖关系
- 易于测试（可替换为 Mock）
- 配置集中

---

## 关键数据流向

### 导入数据流
```
用户选择文件
  → DataImportWidget（预览）
  → TextFileReader（读取）
  → ThermalCurve（创建）
  → CurveManager（管理）
  → 信号: curveAdded
  → ├─ ProjectTreeManager（更新树）
    └─ ChartView（显示图表）
```

### 算法执行流
```
用户选择算法
  → MainController
  → AlgorithmCoordinator
  → ├─ 收集参数（如需要）
    ├─ 请求选点（如需要）
    │   → ChartView 状态机
    │   → 用户在图表上选点
    │   → algorithmInteractionCompleted（自动）
    └─ executeAlgorithm
      → 准备 AlgorithmContext
      → AlgorithmManager::executeWithContext
      → 算法拉取数据并执行
      → 创建新曲线
      → CurveManager::addCurve
  → 信号: curveAdded
  → ├─ ProjectTreeManager（添加为子节点）
    ├─ ChartView（显示新曲线）
    └─ CurveViewController（同步状态）
```

### 曲线选择流（双向视觉反馈）
```
用户点击项目树中的曲线
  → ProjectExplorerView::curveItemClicked
  → CurveViewController::onTreeItemClicked
  → CurveManager::setActiveCurve
  → CurveManager::activeCurveChanged（信号）
  → CurveViewController::onActiveCurveChanged
  → ├─ ChartView::highlightCurve（加粗）
    └─ ProjectTreeManager::setActiveCurve（高亮）
```

---

## 架构优势

### 1. 可维护性
- ✅ 职责清晰，修改影响范围小
- ✅ 代码组织清晰，易于定位问题

### 2. 可测试性
- ✅ 依赖注入，易于替换为 Mock
- ✅ 领域层独立，可单独测试

### 3. 可扩展性
- ✅ 新算法只需实现接口并注册
- ✅ 新文件格式只需实现 Reader 接口
- ✅ 双枚举设计易于扩展新类型

### 4. 松耦合
- ✅ 信号槽机制，组件间不直接依赖
- ✅ 上下文驱动，避免参数传递
- ✅ 接口编程，依赖抽象而非实现

### 5. 代码质量
- ✅ 函数拆分优化，单一职责
- ✅ 消除重复代码，提取辅助函数
- ✅ 统计：减少 150+ 行代码，新增 14 个辅助函数

---

## 架构演进

### 已完成的优化 ✅
- ✅ 统一初始化机制（ApplicationContext）
- ✅ 算法上下文容器（AlgorithmContext）
- ✅ 算法流程协调器（AlgorithmCoordinator）
- ✅ 活动算法状态机（ChartView）
- ✅ 项目树管理器（ProjectTreeManager）
- ✅ 命令模式框架（HistoryManager + Commands）
- ✅ 双枚举扩展（SignalType 支持 Baseline/PeakArea）
- ✅ 代码重构优化（函数拆分，复杂度降低 50%）
- ✅ 纯上下文驱动执行（executeWithContext）
- ✅ 双向视觉反馈（图表加粗 + 项目树高亮）

### 后续计划
- **Phase 1**：完善历史管理和撤销/重做
- **Phase 2**：项目保存/加载，曲线导出
- **Phase 3**：算法参数对话框，峰值检测
- **Phase 4**：动力学分析，批处理，插件系统

---

## 快速参考

### 添加新算法
1. 在 `infrastructure/algorithm/` 实现 `IThermalAlgorithm`
2. 实现 `executeWithContext()` 和 `prepareContext()`
3. 定义 `getOutputSignalType()` 转换规则
4. 在 `AlgorithmManager` 中注册
5. 在 `MainWindow` 菜单中添加触发项

### 添加新文件格式
1. 在 `infrastructure/io/` 实现 `IFileReader`
2. 实现 `canRead()` 和 `read()` 方法
3. 在 `CurveManager::registerDefaultReaders()` 中注册

### 修改数据模型
- 保持 `rawData` 不可变性
- 修改只作用于 `processedData`
- 更新 `SignalType` 时同步修改算法的 `getOutputSignalType()`

---

## 总结

四层架构通过清晰的职责分离和依赖控制，构建了一个**可维护、可测试、可扩展**的热分析软件系统。

**核心特点**：
- 🏗️ **分层清晰**：每层职责明确，边界清楚
- 🔄 **依赖控制**：上层依赖下层，单向依赖流
- 🧩 **松耦合**：信号槽通信，接口编程
- 🎯 **领域驱动**：业务模型独立，核心稳定
- 🚀 **易于扩展**：双枚举设计，插件式算法

**设计亮点**：
- ✨ 双枚举分离设计（仪器类型 + 信号类型）
- ✨ 上下文驱动执行（AlgorithmContext）
- ✨ 活动算法状态机（自动触发交互）
- ✨ 统一初始化（ApplicationContext）
- ✨ 命令模式（撤销/重做）

---

**文档版本**：简化版 v1.0
**对应详细版**：`02_四层架构详解.md`
**最后更新**：2025-11-07
