éå¸¸å¥½ ğŸ‘ ä½ ç°åœ¨å·²ç»è§¦åŠäº†**ç®—æ³•ç³»ç»Ÿä¸­æœ€å¤æ‚ã€æœ€çµæ´»çš„ä¸€ç±»ï¼šå¤šæ›²çº¿äº¤äº’è®¡ç®—ç®—æ³•**ã€‚
 æˆ‘ä»¬ç°åœ¨å·²ç»æœ‰ä»¥ä¸‹å‡ ç§ç±»å‹ï¼ˆæˆ‘å¸®ä½ ç»Ÿä¸€æ•´ç†ä¸€ä¸‹ï¼‰ï¼š

| ç±»å‹ä»£å· | ç‰¹å¾                     | è¾“å…¥                       | äº¤äº’     | è¾“å‡º                     |
| -------- | ------------------------ | -------------------------- | -------- | ------------------------ |
| **A**    | å•æ›²çº¿ç®—æ³•ï¼ˆå¦‚å¾®åˆ†ï¼‰     | 1æ¡æ›²çº¿                    | æ—        | æ–°æ›²çº¿                   |
| **B**    | é€‰ç‚¹ç®—æ³•ï¼ˆå¦‚åŸºçº¿ï¼‰       | 1æ¡æ›²çº¿ + 2ç‚¹              | é€‰ç‚¹     | æ–°æ›²çº¿                   |
| **C**    | åŒæ›²çº¿ç®—æ³•ï¼ˆå¦‚ç§¯åˆ†é¢ç§¯ï¼‰ | ä¸»æ›²çº¿ + å‚è€ƒæ›²çº¿ + 2ç‚¹    | é€‰ç‚¹     | é¢ç§¯(QAreaSeries) + ç»“æœ |
| **D**    | æ›²çº¿ç›¸äº¤ç®—æ³•             | 1æ¡æ›²çº¿ + 2ç‚¹ + å¦ä¸€æ¡æ›²çº¿ | é€‰ç‚¹     | æ–°æ›²çº¿ï¼ˆç›¸äº¤ï¼‰           |
| **E**    | å¤šé€‰ç‚¹å¤šæ›²çº¿ç®—æ³•         | 1æ¡æ›²çº¿ + Nç‚¹ (+å…¶ä»–æ›²çº¿)  | å¤šç‚¹é€‰å– | å¤šæ¡æ–°æ›²çº¿æˆ–äº¤ç‚¹é›†       |

æ¥ä¸‹æ¥æˆ‘å¸®ä½ å®šä¹‰ä¸€å¥—å®Œæ•´çš„æ¥å£ä½“ç³»ï¼Œèƒ½è¦†ç›– A~E æ‰€æœ‰ç±»å‹ï¼Œ
 ä½†åˆä¿æŒä¸€è‡´çš„è°ƒç”¨æ–¹å¼å’Œè‰¯å¥½çš„å¯æ‰©å±•æ€§ã€‚

------

## ğŸ§© ä¸€ã€æ ¸å¿ƒæ€æƒ³ï¼šæŠ½è±¡ä¸ºã€Œç®—æ³•è¡Œä¸ºç±»å‹ã€

ç»Ÿä¸€æ¥å£ä¾ç„¶æ˜¯ `IAlgorithm`ï¼Œ
 ä½†æ¯ä¸ªç®—æ³•éƒ½å£°æ˜è‡ªå·±çš„**è¾“å…¥éœ€æ±‚**ï¼ˆInputSpecï¼‰ï¼Œ
 æ§åˆ¶å±‚æ ¹æ® InputSpec æ¥å†³å®šäº¤äº’æµç¨‹ã€‚

------

## âš™ï¸ äºŒã€æ¥å£å®šä¹‰

```cpp
class IAlgorithm {
public:
    virtual ~IAlgorithm() = default;

    enum class InputType {
        None,           // æ— äº¤äº’ï¼ˆAç±»ï¼‰
        PointSelection, // ä¸¤ç‚¹é€‰å–ï¼ˆBç±»ï¼‰
        DualCurve,      // ä¾èµ–å¦ä¸€æ›²çº¿ï¼ˆCç±»ï¼‰
        Intersect,      // ä¸å¦ä¸€æ›²çº¿ç›¸äº¤ï¼ˆDç±»ï¼‰
        MultiPoint      // å¤šç‚¹é€‰å–ï¼ˆEç±»ï¼‰
    };

    enum class OutputType {
        Curve,          // è¾“å‡ºå•æ›²çº¿
        Area,           // è¾“å‡ºé¢ç§¯å›¾ (QAreaSeries)
        Intersection,   // è¾“å‡ºäº¤ç‚¹/ç›¸äº¤æ›²çº¿
        Annotation,     // è¾“å‡ºæ ‡æ³¨ã€è¾…åŠ©å›¾å½¢
        MultipleCurves  // è¾“å‡ºå¤šæ¡æ›²çº¿
    };

    virtual QString name() const = 0;
    virtual QString userPrompt() const { return QString(); }
    virtual InputType inputType() const = 0;
    virtual OutputType outputType() const = 0;

    virtual QVariant execute(const QVariantMap& inputs) = 0;
};
```

------

## ğŸ§  ä¸‰ã€è¾“å…¥ / è¾“å‡º çš„ç»Ÿä¸€å°è£…æ–¹å¼

æ‰€æœ‰è¾“å…¥ã€è¾“å‡ºéƒ½é€šè¿‡ `QVariantMap` å°è£…ï¼š

### è¾“å…¥ä¾‹å­

```cpp
QVariantMap inputs;
inputs["mainCurve"] = QVariant::fromValue(mainCurvePtr);
inputs["refCurve"]  = QVariant::fromValue(refCurvePtr);
inputs["points"]    = QVariant::fromValue(QVector<QPointF>{p1, p2, p3});
```

### è¾“å‡ºä¾‹å­

```cpp
QVariant result = algorithm->execute(inputs);
Curve newCurve = result.value<Curve>();
```

æˆ–è¾“å‡ºå¤šä¸ªå¯¹è±¡ï¼š

```cpp
QVariantMap result = result.value<QVariantMap>();
auto newSeries = result["series"].value<QLineSeries*>();
auto area = result["area"].value<QAreaSeries*>();
```

------

## ğŸ§© å››ã€å…·ä½“ç®—æ³•å®ç°ä¸¾ä¾‹

### ğŸ”¹ Dç±»ï¼šç›¸äº¤æ›²çº¿ç®—æ³•ï¼ˆIntersectionAlgorithmï¼‰

ç”¨æˆ·é€‰ä¸¤ç‚¹ï¼Œè®¡ç®—ä¸å¦ä¸€æ¡æ›²çº¿çš„äº¤çº¿ï¼š

```cpp
class IntersectionAlgorithm : public IAlgorithm {
public:
    QString name() const override { return "Intersection"; }
    QString userPrompt() const override { return "è¯·åœ¨ä¸»æ›²çº¿ä¸Šé€‰æ‹©ä¸¤ä¸ªç‚¹ï¼Œç”¨äºä¸å‚è€ƒæ›²çº¿ç›¸äº¤"; }
    InputType inputType() const override { return InputType::Intersect; }
    OutputType outputType() const override { return OutputType::Curve; }

    QVariant execute(const QVariantMap& inputs) override {
        auto mainCurve = inputs["mainCurve"].value<Curve>();
        auto refCurve  = inputs["refCurve"].value<Curve>();
        auto points    = inputs["points"].value<QVector<QPointF>>();

        double x1 = points[0].x(), x2 = points[1].x();
        QVector<QPointF> segment;

        // éå†å¹¶æ±‚äº¤ç‚¹
        for (const auto& p : mainCurve.points()) {
            if (p.x() < x1 || p.x() > x2) continue;
            double yRef = refCurve.interpolate(p.x());
            double yDelta = p.y() - yRef;
            segment.append(QPointF(p.x(), yDelta));
        }

        Curve newCurve;
        newCurve.setName(mainCurve.name() + "_intersect");
        newCurve.setPoints(segment);
        newCurve.setColor(Qt::darkMagenta);
        return QVariant::fromValue(newCurve);
    }
};
```

------

### ğŸ”¹ Eç±»ï¼šå¤šé€‰ç‚¹å¤šæ›²çº¿ç®—æ³•ï¼ˆMultiPointAlgorithmï¼‰

```cpp
class MultiPointAlgorithm : public IAlgorithm {
public:
    QString name() const override { return "MultiPointCurve"; }
    QString userPrompt() const override { return "è¯·åœ¨æ›²çº¿ä¸Šé€‰æ‹©å¤šä¸ªç‚¹ä»¥ç”Ÿæˆäº¤äº’æ›²çº¿"; }
    InputType inputType() const override { return InputType::MultiPoint; }
    OutputType outputType() const override { return OutputType::MultipleCurves; }

    QVariant execute(const QVariantMap& inputs) override {
        auto curve = inputs["mainCurve"].value<Curve>();
        auto pts   = inputs["points"].value<QVector<QPointF>>();

        QVariantMap result;
        QVector<QLineSeries*> seriesList;

        for (int i = 0; i + 1 < pts.size(); ++i) {
            QLineSeries* s = new QLineSeries();
            s->append(pts[i]);
            s->append(pts[i + 1]);
            s->setPen(QPen(Qt::DashLine));
            seriesList.append(s);
        }

        result["seriesList"] = QVariant::fromValue(seriesList);
        return QVariant::fromValue(result);
    }
};
```

------

## âš™ï¸ äº”ã€æ§åˆ¶å±‚ç»Ÿä¸€é€»è¾‘

```cpp
void AlgorithmManager::runAlgorithm(const QString& name)
{
    auto alg = AlgorithmRegistry::instance()->get(name);
    if (!alg) return;

    ui->statusBar->showMessage(alg->userPrompt());

    switch (alg->inputType()) {
    case IAlgorithm::InputType::None:
        runNoInputAlgorithm(alg);
        break;

    case IAlgorithm::InputType::PointSelection:
    case IAlgorithm::InputType::Intersect:
    case IAlgorithm::InputType::MultiPoint:
        connect(chartView, &ChartView::pointsSelected, this, [=](const QVector<QPointF>& points){
            QVariantMap inputs;
            inputs["mainCurve"] = QVariant::fromValue(chartView->selectedCurve());
            inputs["points"] = QVariant::fromValue(points);
            if (alg->inputType() == IAlgorithm::InputType::Intersect)
                inputs["refCurve"] = QVariant::fromValue(chartView->referenceCurve());

            QVariant result = alg->execute(inputs);
            handleAlgorithmResult(result, alg->outputType());
        });
        break;

    default: break;
    }
}
```

------

## ğŸ¨ å…­ã€ç»“æœåˆ†å‘

```cpp
void AlgorithmManager::handleAlgorithmResult(const QVariant& result,
                                             IAlgorithm::OutputType type)
{
    switch (type) {
    case IAlgorithm::OutputType::Curve: {
        Curve curve = result.value<Curve>();
        chartManager->addCurve(curve);
        break;
    }
    case IAlgorithm::OutputType::Area: {
        QAreaSeries* area = result.value<QAreaSeries*>();
        chartManager->addAreaSeries(area);
        break;
    }
    case IAlgorithm::OutputType::MultipleCurves: {
        QVariantMap res = result.value<QVariantMap>();
        auto list = res["seriesList"].value<QVector<QLineSeries*>>();
        for (auto* s : list)
            chartManager->addSeries(s);
        break;
    }
    case IAlgorithm::OutputType::Intersection:
        // â€¦ å¯æ‰©å±•ç›¸äº¤ç‚¹æ ‡æ³¨é€»è¾‘
        break;
    default:
        break;
    }
}
```

------

## âœ… ä¸ƒã€æ€»ç»“ä¸ä¼˜åŠ¿

| ä¼˜ç‚¹             | è¯´æ˜                                                    |
| ---------------- | ------------------------------------------------------- |
| **å®Œå…¨ç»Ÿä¸€æ¥å£** | æ‰€æœ‰ç®—æ³•ï¼ˆåŒ…æ‹¬å¤æ‚å¤šäº¤äº’ç®—æ³•ï¼‰é€šè¿‡ `IAlgorithm` ç®¡ç†    |
| **è‡ªåŠ¨æ§åˆ¶äº¤äº’** | æ§åˆ¶å±‚æ ¹æ® `InputType` è‡ªåŠ¨æ§åˆ¶ç‚¹é€‰ã€å¤šé€‰æˆ–ä¾èµ–æ›²çº¿é€»è¾‘ |
| **ç±»å‹å®‰å…¨**     | `OutputType` å†³å®šç»“æœç»˜åˆ¶æ–¹å¼ï¼ˆæ›²çº¿/é¢ç§¯/æ ‡æ³¨/å¤šæ›²çº¿ï¼‰  |
| **é«˜æ‰©å±•æ€§**     | æ–°ç®—æ³•åªéœ€å£°æ˜è¾“å…¥ç±»å‹ + è¾“å‡ºç±»å‹ + æ‰§è¡Œé€»è¾‘            |
| **å…¼å®¹æœªæ¥**     | æ”¯æŒä»»æ„ç»„åˆè¾“å…¥ï¼ˆæ›²çº¿ + ç‚¹ + å¤šæ›²çº¿ + ä¾èµ–ï¼‰           |

------

### ğŸ§­ ä¸€å¥è¯æ€»ç»“

> ç®—æ³•ä½“ç³»å¯ä»¥ç”¨ã€Œ**ç»Ÿä¸€ç®—æ³•æ¥å£ + InputType + OutputType æ¶æ„**ã€æ‰©å±•ï¼Œ
>  è¿™æ ·å³ä½¿å‡ºç°æ›´å¤æ‚çš„äº¤äº’åœºæ™¯ï¼ˆå¤šç‚¹ã€å¤šæ›²çº¿ã€ç›¸äº¤ã€åŒºåŸŸç”Ÿæˆï¼‰ï¼Œ
>  æ§åˆ¶å±‚éƒ½èƒ½é€šè¿‡æšä¸¾è‡ªåŠ¨è¯†åˆ«è¾“å…¥/è¾“å‡ºç±»å‹æ¥æ‰§è¡Œï¼Œ
>  è€Œç®—æ³•æœ¬èº«åªè´Ÿè´£è®¡ç®—ä¸ç»“æœå°è£…ã€‚

------

