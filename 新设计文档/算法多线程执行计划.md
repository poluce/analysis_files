# 算法多线程执行计划

## 1. 项目概述

### 1.1 目标
将所有算法计算从UI线程移到工作线程，防止长时间计算阻塞界面。

### 1.2 设计原则
- ✅ **非阻塞执行**: 算法在后台线程执行，UI保持响应
- ✅ **进度反馈**: 支持显示计算进度（特别是长时间算法）
- ✅ **可取消性**: 用户可以中途取消计算
- ✅ **错误隔离**: 线程异常不影响主线程
- ✅ **保持架构一致性**: 不破坏现有的上下文驱动模式
- ✅ **向后兼容**: 保留同步执行接口（用于测试）

### 1.3 技术选型

**采用方案**: Qt Worker Object Pattern (推荐)

```
UI线程 (主线程)
  ↓
AlgorithmManager::executeAsync()
  ↓ 发送信号
AlgorithmWorker (在工作线程中)
  ↓ 执行算法
algorithm->executeWithContext(context)
  ↓ 发送结果信号
AlgorithmManager::onWorkerFinished()
  ↓ 处理结果
emit algorithmResultReady(...)
```

**为什么不继承QThread**:
- Qt官方推荐使用Worker Object模式
- 更灵活的线程复用（线程池）
- 更好的信号槽集成
- 避免QThread的生命周期管理问题

---

## 2. 架构设计

### 2.1 核心类设计

#### 2.1.1 AlgorithmTask (任务封装)

```cpp
// src/domain/algorithm/algorithm_task.h
#ifndef ALGORITHM_TASK_H
#define ALGORITHM_TASK_H

#include <QString>
#include <QUuid>
#include <QDateTime>
#include "algorithm_context.h"

/**
 * @brief 算法任务封装
 *
 * 封装单次算法执行的所有信息（算法名、上下文、任务ID）
 */
class AlgorithmTask {
public:
    AlgorithmTask(const QString& algorithmName, AlgorithmContext* context)
        : m_taskId(QUuid::createUuid().toString())
        , m_algorithmName(algorithmName)
        , m_context(context)
        , m_createdAt(QDateTime::currentDateTime())
        , m_isCancelled(false)
    {}

    QString taskId() const { return m_taskId; }
    QString algorithmName() const { return m_algorithmName; }
    AlgorithmContext* context() const { return m_context; }
    QDateTime createdAt() const { return m_createdAt; }

    bool isCancelled() const { return m_isCancelled; }
    void cancel() { m_isCancelled = true; }

private:
    QString m_taskId;           // 任务唯一ID
    QString m_algorithmName;    // 算法名称
    AlgorithmContext* m_context; // 上下文（数据容器）
    QDateTime m_createdAt;      // 创建时间
    bool m_isCancelled;         // 是否被取消
};

#endif // ALGORITHM_TASK_H
```

#### 2.1.2 IProgressReporter (进度报告接口)

```cpp
// src/domain/algorithm/i_progress_reporter.h
#ifndef I_PROGRESS_REPORTER_H
#define I_PROGRESS_REPORTER_H

#include <QString>

/**
 * @brief 进度报告接口
 *
 * 算法可以选择实现此接口来报告执行进度
 */
class IProgressReporter {
public:
    virtual ~IProgressReporter() = default;

    /**
     * @brief 报告进度
     * @param percentage 进度百分比 (0-100)
     * @param message 进度描述
     */
    virtual void reportProgress(int percentage, const QString& message = "") = 0;

    /**
     * @brief 检查是否被请求取消
     * @return true 如果应该取消执行
     */
    virtual bool isCancellationRequested() const = 0;
};

#endif // I_PROGRESS_REPORTER_H
```

#### 2.1.3 AlgorithmWorker (工作线程对象)

```cpp
// src/application/algorithm/algorithm_worker.h
#ifndef ALGORITHM_WORKER_H
#define ALGORITHM_WORKER_H

#include <QObject>
#include <QVariant>
#include "algorithm_task.h"
#include "i_thermal_algorithm.h"
#include "i_progress_reporter.h"

/**
 * @brief 算法工作线程对象
 *
 * 在独立线程中执行算法计算，通过信号槽返回结果
 */
class AlgorithmWorker : public QObject, public IProgressReporter {
    Q_OBJECT

public:
    explicit AlgorithmWorker(QObject* parent = nullptr);
    ~AlgorithmWorker() override;

    // IProgressReporter 接口实现
    void reportProgress(int percentage, const QString& message = "") override;
    bool isCancellationRequested() const override;

public slots:
    /**
     * @brief 执行算法任务
     * @param task 任务封装
     * @param algorithm 算法实例（必须是线程安全的）
     */
    void executeTask(AlgorithmTask* task, IThermalAlgorithm* algorithm);

    /**
     * @brief 请求取消当前任务
     */
    void requestCancellation();

signals:
    /**
     * @brief 任务开始执行
     * @param taskId 任务ID
     * @param algorithmName 算法名称
     */
    void taskStarted(QString taskId, QString algorithmName);

    /**
     * @brief 任务执行进度
     * @param taskId 任务ID
     * @param percentage 进度百分比 (0-100)
     * @param message 进度描述
     */
    void taskProgress(QString taskId, int percentage, QString message);

    /**
     * @brief 任务执行完成
     * @param taskId 任务ID
     * @param result 执行结果
     * @param elapsedMs 执行时长（毫秒）
     */
    void taskFinished(QString taskId, QVariant result, qint64 elapsedMs);

    /**
     * @brief 任务执行失败
     * @param taskId 任务ID
     * @param errorMessage 错误信息
     */
    void taskFailed(QString taskId, QString errorMessage);

private:
    AlgorithmTask* m_currentTask;  // 当前执行的任务
    bool m_cancellationRequested;  // 是否请求取消
};

#endif // ALGORITHM_WORKER_H
```

```cpp
// src/application/algorithm/algorithm_worker.cpp
#include "algorithm_worker.h"
#include <QElapsedTimer>
#include <QDebug>

AlgorithmWorker::AlgorithmWorker(QObject* parent)
    : QObject(parent)
    , m_currentTask(nullptr)
    , m_cancellationRequested(false)
{}

AlgorithmWorker::~AlgorithmWorker() {
    delete m_currentTask;
}

void AlgorithmWorker::executeTask(AlgorithmTask* task, IThermalAlgorithm* algorithm) {
    if (!task || !algorithm) {
        emit taskFailed(task ? task->taskId() : "", "Invalid task or algorithm");
        return;
    }

    m_currentTask = task;
    m_cancellationRequested = false;

    QString taskId = task->taskId();
    QString algorithmName = task->algorithmName();

    qDebug() << "[Worker] Starting task" << taskId << "algorithm:" << algorithmName;
    emit taskStarted(taskId, algorithmName);

    QElapsedTimer timer;
    timer.start();

    try {
        // 两阶段执行
        // 阶段1: 验证数据完整性（应该在主线程已做，此处再检查一次）
        if (!algorithm->prepareContext(task->context())) {
            emit taskFailed(taskId, "Context preparation failed");
            delete m_currentTask;
            m_currentTask = nullptr;
            return;
        }

        // 检查取消请求
        if (isCancellationRequested()) {
            emit taskFailed(taskId, "Task cancelled before execution");
            delete m_currentTask;
            m_currentTask = nullptr;
            return;
        }

        // 阶段2: 执行算法
        QVariant result = algorithm->executeWithContext(task->context());

        // 再次检查取消请求
        if (isCancellationRequested()) {
            emit taskFailed(taskId, "Task cancelled during execution");
            delete m_currentTask;
            m_currentTask = nullptr;
            return;
        }

        qint64 elapsed = timer.elapsed();
        qDebug() << "[Worker] Task" << taskId << "completed in" << elapsed << "ms";
        emit taskFinished(taskId, result, elapsed);

    } catch (const std::exception& e) {
        qWarning() << "[Worker] Task" << taskId << "failed with exception:" << e.what();
        emit taskFailed(taskId, QString("Exception: %1").arg(e.what()));
    } catch (...) {
        qWarning() << "[Worker] Task" << taskId << "failed with unknown exception";
        emit taskFailed(taskId, "Unknown exception");
    }

    delete m_currentTask;
    m_currentTask = nullptr;
}

void AlgorithmWorker::requestCancellation() {
    qDebug() << "[Worker] Cancellation requested";
    m_cancellationRequested = true;
    if (m_currentTask) {
        m_currentTask->cancel();
    }
}

void AlgorithmWorker::reportProgress(int percentage, const QString& message) {
    if (m_currentTask) {
        emit taskProgress(m_currentTask->taskId(), percentage, message);
    }
}

bool AlgorithmWorker::isCancellationRequested() const {
    return m_cancellationRequested || (m_currentTask && m_currentTask->isCancelled());
}
```

#### 2.1.4 AlgorithmThreadManager (线程池管理器)

```cpp
// src/application/algorithm/algorithm_thread_manager.h
#ifndef ALGORITHM_THREAD_MANAGER_H
#define ALGORITHM_THREAD_MANAGER_H

#include <QObject>
#include <QThread>
#include <QMap>
#include "algorithm_worker.h"

/**
 * @brief 算法线程池管理器
 *
 * 单例模式，管理工作线程的创建、复用和销毁
 */
class AlgorithmThreadManager : public QObject {
    Q_OBJECT

public:
    static AlgorithmThreadManager* instance();

    /**
     * @brief 获取空闲的Worker
     * @return Worker对象和其所在的线程
     */
    QPair<AlgorithmWorker*, QThread*> acquireWorker();

    /**
     * @brief 释放Worker（标记为空闲）
     * @param worker 要释放的Worker
     */
    void releaseWorker(AlgorithmWorker* worker);

    /**
     * @brief 关闭所有线程（应用退出时调用）
     */
    void shutdown();

signals:
    void workerCountChanged(int activeCount, int totalCount);

private:
    explicit AlgorithmThreadManager(QObject* parent = nullptr);
    ~AlgorithmThreadManager() override;

    struct WorkerInfo {
        QThread* thread;
        AlgorithmWorker* worker;
        bool isBusy;
    };

    QList<WorkerInfo> m_workers;
    static AlgorithmThreadManager* s_instance;

    const int MAX_THREADS = 4; // 最大线程数
};

#endif // ALGORITHM_THREAD_MANAGER_H
```

```cpp
// src/application/algorithm/algorithm_thread_manager.cpp
#include "algorithm_thread_manager.h"
#include <QDebug>

AlgorithmThreadManager* AlgorithmThreadManager::s_instance = nullptr;

AlgorithmThreadManager* AlgorithmThreadManager::instance() {
    if (!s_instance) {
        s_instance = new AlgorithmThreadManager();
    }
    return s_instance;
}

AlgorithmThreadManager::AlgorithmThreadManager(QObject* parent)
    : QObject(parent)
{}

AlgorithmThreadManager::~AlgorithmThreadManager() {
    shutdown();
}

QPair<AlgorithmWorker*, QThread*> AlgorithmThreadManager::acquireWorker() {
    // 1. 查找空闲Worker
    for (WorkerInfo& info : m_workers) {
        if (!info.isBusy) {
            info.isBusy = true;
            qDebug() << "[ThreadManager] Reusing worker" << info.worker;
            emit workerCountChanged(activeWorkerCount(), m_workers.size());
            return {info.worker, info.thread};
        }
    }

    // 2. 如果没有空闲Worker且未达到最大线程数，创建新Worker
    if (m_workers.size() < MAX_THREADS) {
        QThread* thread = new QThread(this);
        AlgorithmWorker* worker = new AlgorithmWorker();
        worker->moveToThread(thread);

        // 线程结束时清理
        connect(thread, &QThread::finished, worker, &QObject::deleteLater);

        thread->start();

        WorkerInfo info{thread, worker, true};
        m_workers.append(info);

        qDebug() << "[ThreadManager] Created new worker" << worker << "total:" << m_workers.size();
        emit workerCountChanged(activeWorkerCount(), m_workers.size());

        return {worker, thread};
    }

    // 3. 所有Worker都忙且达到最大线程数，等待第一个空闲（简单策略）
    qWarning() << "[ThreadManager] All workers busy, waiting for first available";
    return {nullptr, nullptr}; // 调用者需要处理nullptr
}

void AlgorithmThreadManager::releaseWorker(AlgorithmWorker* worker) {
    for (WorkerInfo& info : m_workers) {
        if (info.worker == worker) {
            info.isBusy = false;
            qDebug() << "[ThreadManager] Released worker" << worker;
            emit workerCountChanged(activeWorkerCount(), m_workers.size());
            return;
        }
    }
    qWarning() << "[ThreadManager] Attempted to release unknown worker" << worker;
}

void AlgorithmThreadManager::shutdown() {
    qDebug() << "[ThreadManager] Shutting down all threads";
    for (const WorkerInfo& info : m_workers) {
        info.thread->quit();
        info.thread->wait(3000); // 等待最多3秒
        if (info.thread->isRunning()) {
            qWarning() << "[ThreadManager] Thread did not quit gracefully, terminating";
            info.thread->terminate();
        }
        delete info.thread;
    }
    m_workers.clear();
}

int AlgorithmThreadManager::activeWorkerCount() const {
    int count = 0;
    for (const WorkerInfo& info : m_workers) {
        if (info.isBusy) ++count;
    }
    return count;
}
```

---

### 2.2 修改现有类

#### 2.2.1 AlgorithmManager (添加异步接口)

```cpp
// algorithm_manager.h (新增方法)
public:
    /**
     * @brief 异步执行算法（推荐使用）
     * @param algorithmName 算法名称
     * @param context 上下文
     * @return 任务ID
     */
    QString executeAsync(const QString& algorithmName, AlgorithmContext* context);

    /**
     * @brief 取消正在执行的任务
     * @param taskId 任务ID
     */
    void cancelTask(const QString& taskId);

signals:
    void algorithmStarted(QString taskId, QString algorithmName);
    void algorithmProgress(QString taskId, int percentage, QString message);
    void algorithmFinished(QString taskId, qint64 elapsedMs);
    void algorithmFailed(QString taskId, QString errorMessage);

private slots:
    void onWorkerStarted(QString taskId, QString algorithmName);
    void onWorkerProgress(QString taskId, int percentage, QString message);
    void onWorkerFinished(QString taskId, QVariant result, qint64 elapsedMs);
    void onWorkerFailed(QString taskId, QString errorMessage);

private:
    QMap<QString, AlgorithmTask*> m_activeTasks;  // 正在执行的任务
    QMap<QString, AlgorithmWorker*> m_taskWorkers; // 任务ID -> Worker映射
```

```cpp
// algorithm_manager.cpp (实现异步执行)
QString AlgorithmManager::executeAsync(const QString& algorithmName, AlgorithmContext* context) {
    // 1. 获取算法实例
    IThermalAlgorithm* algorithm = getAlgorithm(algorithmName);
    if (!algorithm) {
        qWarning() << "[AlgorithmManager] Algorithm not found:" << algorithmName;
        return QString();
    }

    // 2. 验证上下文（阶段1：prepareContext）
    if (!algorithm->prepareContext(context)) {
        qWarning() << "[AlgorithmManager] Context preparation failed for" << algorithmName;
        return QString();
    }

    // 3. 创建任务
    AlgorithmTask* task = new AlgorithmTask(algorithmName, context);
    QString taskId = task->taskId();

    // 4. 获取Worker
    auto [worker, thread] = AlgorithmThreadManager::instance()->acquireWorker();
    if (!worker) {
        qWarning() << "[AlgorithmManager] Failed to acquire worker";
        delete task;
        return QString();
    }

    // 5. 连接信号
    connect(worker, &AlgorithmWorker::taskStarted, this, &AlgorithmManager::onWorkerStarted);
    connect(worker, &AlgorithmWorker::taskProgress, this, &AlgorithmManager::onWorkerProgress);
    connect(worker, &AlgorithmWorker::taskFinished, this, &AlgorithmManager::onWorkerFinished);
    connect(worker, &AlgorithmWorker::taskFailed, this, &AlgorithmManager::onWorkerFailed);

    // 6. 记录任务
    m_activeTasks[taskId] = task;
    m_taskWorkers[taskId] = worker;

    // 7. 触发执行（跨线程调用，通过信号槽）
    QMetaObject::invokeMethod(worker, "executeTask", Qt::QueuedConnection,
                              Q_ARG(AlgorithmTask*, task),
                              Q_ARG(IThermalAlgorithm*, algorithm));

    qDebug() << "[AlgorithmManager] Submitted task" << taskId << "algorithm:" << algorithmName;
    return taskId;
}

void AlgorithmManager::onWorkerFinished(QString taskId, QVariant result, qint64 elapsedMs) {
    qDebug() << "[AlgorithmManager] Task" << taskId << "finished in" << elapsedMs << "ms";

    // 1. 获取任务信息
    if (!m_activeTasks.contains(taskId)) {
        qWarning() << "[AlgorithmManager] Unknown task finished:" << taskId;
        return;
    }

    AlgorithmTask* task = m_activeTasks[taskId];
    IThermalAlgorithm* algorithm = getAlgorithm(task->algorithmName());
    ThermalCurve* curve = task->context()->get<ThermalCurve*>("activeCurve").value();

    // 2. 处理结果（和同步版本相同）
    handleAlgorithmResult(algorithm, curve, result);

    // 3. 发出完成信号
    emit algorithmFinished(taskId, elapsedMs);
    emit algorithmResultReady(task->algorithmName(), curve, result);

    // 4. 清理
    AlgorithmWorker* worker = m_taskWorkers.take(taskId);
    if (worker) {
        AlgorithmThreadManager::instance()->releaseWorker(worker);
    }

    delete m_activeTasks.take(taskId);
}
```

#### 2.2.2 IThermalAlgorithm (添加可选的进度支持)

```cpp
// i_thermal_algorithm.h (添加方法)
public:
    /**
     * @brief 设置进度报告器（可选）
     * @param reporter 进度报告器
     *
     * 算法可以选择性地使用此接口报告执行进度
     */
    virtual void setProgressReporter(IProgressReporter* reporter) {
        Q_UNUSED(reporter);
        // 默认实现：不做任何事（算法不支持进度报告）
    }

protected:
    /**
     * @brief 报告进度的便捷方法
     * @param percentage 进度百分比 (0-100)
     * @param message 进度描述
     */
    void reportProgress(int percentage, const QString& message = "") {
        if (m_progressReporter) {
            m_progressReporter->reportProgress(percentage, message);
        }
    }

    /**
     * @brief 检查是否应该取消执行
     * @return true 如果应该取消
     */
    bool shouldCancel() const {
        return m_progressReporter && m_progressReporter->isCancellationRequested();
    }

private:
    IProgressReporter* m_progressReporter = nullptr;
```

---

## 3. 实施计划

### Phase 1: 分析当前架构并设计线程方案 ✅

**任务**:
- ✅ 分析现有算法执行流程
- ✅ 确定技术方案（Worker Object Pattern）
- ✅ 设计核心类（AlgorithmTask、IProgressReporter、AlgorithmWorker、AlgorithmThreadManager）
- ✅ 编写设计文档

**验收标准**:
- 设计文档完成
- 类职责清晰
- 信号槽流程明确

---

### Phase 2: 实现核心线程基础设施

**任务**:
1. 实现 `AlgorithmTask` 类（任务封装）
2. 实现 `IProgressReporter` 接口
3. 实现 `AlgorithmWorker` 类（工作线程对象）
4. 实现 `AlgorithmThreadManager` 类（线程池管理器）

**文件清单**:
- `src/domain/algorithm/algorithm_task.h`
- `src/domain/algorithm/i_progress_reporter.h`
- `src/application/algorithm/algorithm_worker.h`
- `src/application/algorithm/algorithm_worker.cpp`
- `src/application/algorithm/algorithm_thread_manager.h`
- `src/application/algorithm/algorithm_thread_manager.cpp`

**验收标准**:
- 所有类编译通过
- 线程池能够创建和复用Worker
- Worker能够在独立线程中运行

---

### Phase 3: 修改 AlgorithmManager 支持异步执行

**任务**:
1. 添加 `executeAsync()` 方法
2. 添加 `cancelTask()` 方法
3. 添加信号：`algorithmStarted`, `algorithmProgress`, `algorithmFinished`, `algorithmFailed`
4. 实现槽函数：`onWorkerStarted`, `onWorkerProgress`, `onWorkerFinished`, `onWorkerFailed`
5. 管理活动任务映射 (`m_activeTasks`, `m_taskWorkers`)

**修改文件**:
- `src/application/algorithm/algorithm_manager.h`
- `src/application/algorithm/algorithm_manager.cpp`

**验收标准**:
- 异步执行接口可用
- 结果回调正确处理
- 任务生命周期管理正确

---

### Phase 4: 适配算法接口支持进度报告

**任务**:
1. 修改 `IThermalAlgorithm` 添加 `setProgressReporter()` 方法
2. 添加 `reportProgress()` 和 `shouldCancel()` 便捷方法
3. 在长时间算法中添加进度报告（如微分、积分）

**示例**:
```cpp
// DifferentiationAlgorithm::executeWithContext() 中添加
QVariant DifferentiationAlgorithm::executeWithContext(AlgorithmContext* context) {
    // ... 前置代码 ...

    for (int i = 0; i < data.size(); ++i) {
        // 每处理10%报告一次进度
        if (i % (data.size() / 10) == 0) {
            reportProgress(i * 100 / data.size(), QString("已处理 %1/%2 点").arg(i).arg(data.size()));
        }

        // 检查取消请求
        if (shouldCancel()) {
            qDebug() << "[Differentiation] Execution cancelled by user";
            return QVariant();
        }

        // ... 算法逻辑 ...
    }

    reportProgress(100, "微分计算完成");
    return QVariant::fromValue(result);
}
```

**修改文件**:
- `src/domain/algorithm/i_thermal_algorithm.h`
- `src/infrastructure/algorithm/differentiation_algorithm.cpp`
- `src/infrastructure/algorithm/integration_algorithm.cpp`
- `src/infrastructure/algorithm/moving_average_filter_algorithm.cpp`

**验收标准**:
- 算法能够报告进度
- 算法能够响应取消请求
- 不支持进度的算法不受影响

---

### Phase 5: 集成到 AlgorithmCoordinator

**任务**:
1. 修改 `AlgorithmCoordinator::executeAlgorithm()` 调用异步接口
2. 保存 taskId 到 PendingRequest
3. 处理异步回调信号

**修改文件**:
- `src/application/algorithm/algorithm_coordinator.h`
- `src/application/algorithm/algorithm_coordinator.cpp`

**代码示例**:
```cpp
void AlgorithmCoordinator::executeAlgorithm(const QString& algorithmName) {
    // ... 前置代码 ...

    // 调用异步执行
    QString taskId = m_algorithmManager->executeAsync(algorithmName, m_context);
    if (taskId.isEmpty()) {
        qWarning() << "[AlgorithmCoordinator] Failed to submit task";
        return;
    }

    // 保存taskId到待处理请求
    if (m_pendingRequests.contains(algorithmName)) {
        m_pendingRequests[algorithmName].taskId = taskId;
    }

    qDebug() << "[AlgorithmCoordinator] Submitted algorithm" << algorithmName << "taskId:" << taskId;
}
```

**验收标准**:
- AlgorithmCoordinator 能够触发异步执行
- 结果回调能够正确处理

---

### Phase 6: UI 层添加进度反馈

**任务**:
1. MainWindow 添加进度对话框 (`QProgressDialog`)
2. MainController 连接进度信号
3. 显示进度百分比和消息
4. 支持取消按钮

**修改文件**:
- `src/ui/main_window.h`
- `src/ui/main_window.cpp`
- `src/ui/controller/main_controller.h`
- `src/ui/controller/main_controller.cpp`

**代码示例**:
```cpp
// main_controller.cpp
void MainController::onAlgorithmStarted(QString taskId, QString algorithmName) {
    qDebug() << "[MainController] Algorithm started:" << algorithmName << "taskId:" << taskId;

    // 显示进度对话框
    m_progressDialog = new QProgressDialog(
        QString("正在执行: %1").arg(algorithmName),
        "取消",
        0, 100,
        m_mainWindow
    );
    m_progressDialog->setWindowModality(Qt::WindowModal);
    m_progressDialog->setMinimumDuration(500); // 500ms后才显示
    m_progressDialog->setValue(0);

    // 连接取消信号
    connect(m_progressDialog, &QProgressDialog::canceled, this, [this, taskId]() {
        qDebug() << "[MainController] User requested cancellation for task" << taskId;
        m_algorithmManager->cancelTask(taskId);
    });

    m_currentTaskId = taskId;
}

void MainController::onAlgorithmProgress(QString taskId, int percentage, QString message) {
    if (taskId != m_currentTaskId || !m_progressDialog) return;

    m_progressDialog->setValue(percentage);
    if (!message.isEmpty()) {
        m_progressDialog->setLabelText(message);
    }
}

void MainController::onAlgorithmFinished(QString taskId, qint64 elapsedMs) {
    if (taskId != m_currentTaskId) return;

    qDebug() << "[MainController] Algorithm finished in" << elapsedMs << "ms";

    if (m_progressDialog) {
        m_progressDialog->close();
        delete m_progressDialog;
        m_progressDialog = nullptr;
    }

    m_currentTaskId.clear();
}
```

**验收标准**:
- 进度对话框能够显示
- 进度百分比实时更新
- 取消按钮能够中止计算
- 计算完成后对话框自动关闭

---

### Phase 7: 测试和优化

**任务**:
1. 单元测试（AlgorithmWorker、AlgorithmThreadManager）
2. 集成测试（完整算法执行流程）
3. 压力测试（多任务并发）
4. 性能测试（对比同步执行）
5. 内存泄漏检查
6. 优化线程池策略

**测试场景**:
- ✅ 简单算法（微分、积分）异步执行
- ✅ 长时间算法（大数据集）进度报告
- ✅ 用户取消执行
- ✅ 多个算法并发执行
- ✅ 线程池复用验证
- ✅ 异常情况（算法抛出异常、上下文无效等）

**性能指标**:
- UI响应时间 < 100ms（即使算法执行中）
- 线程开销 < 10% CPU（空闲时）
- 内存占用 < 50MB（4个线程）

**验收标准**:
- 所有测试通过
- 无内存泄漏
- UI始终保持响应

---

## 4. 技术细节

### 4.1 线程安全考虑

**安全的**:
- ✅ `AlgorithmContext`: 仅在算法执行期间被单个线程访问
- ✅ `ThermalCurve`: 只读访问（`getProcessedData()`）
- ✅ `QVariant`: 值类型，自动拷贝

**需要注意的**:
- ⚠️ `CurveManager`: 添加曲线时需要回到主线程（通过信号槽）
- ⚠️ `AlgorithmDescriptor`: 只读访问，无需担心
- ⚠️ `IThermalAlgorithm`: 算法实例应该是无状态的（或使用线程局部存储）

**解决方案**:
- 所有UI更新和数据修改都通过信号槽回到主线程
- 算法实例使用注册的单例（只读访问成员变量）
- 上下文数据在提交任务前深拷贝（如需要）

### 4.2 取消机制

**实现方式**:
1. 用户点击取消按钮
2. MainController 调用 `AlgorithmManager::cancelTask(taskId)`
3. AlgorithmManager 调用 `AlgorithmWorker::requestCancellation()`
4. Worker 设置 `m_cancellationRequested = true`
5. 算法在循环中定期检查 `shouldCancel()`
6. 如果返回true，算法立即返回 `QVariant()`
7. Worker 发出 `taskFailed` 信号

**要求**:
- 算法必须定期检查取消请求（每100次迭代或每100ms）
- 算法不能在循环外长时间阻塞（如IO操作）
- 取消后应该快速返回（< 1秒）

### 4.3 错误处理

**异常捕获**:
- Worker 在 `executeTask()` 中使用 `try-catch` 捕获所有异常
- 发出 `taskFailed` 信号并附带错误信息
- 主线程显示错误对话框

**数据验证**:
- 在主线程中验证上下文（`prepareContext()`）
- 避免在工作线程中发现数据问题

### 4.4 性能优化

**线程池策略**:
- 最大线程数：`QThread::idealThreadCount()`（通常是CPU核心数）
- 线程复用：空闲Worker保留在池中，避免频繁创建/销毁
- 任务队列：如果所有Worker忙，新任务进入队列等待

**数据拷贝优化**:
- 使用 `QSharedPointer` 共享大数据（如 ThermalCurve）
- 上下文中存储指针而非值（避免拷贝）
- 结果返回使用 `QVariant::fromValue` 避免多次拷贝

---

## 5. 向后兼容性

### 5.1 保留同步接口

为了测试和调试，保留同步执行接口：

```cpp
// AlgorithmManager (保留)
void executeWithContext(const QString& algorithmName, AlgorithmContext* context);
```

### 5.2 渐进式迁移

**第一阶段**: 实现异步基础设施，但主要使用同步接口
**第二阶段**: 在 MainController 中启用异步执行，添加进度对话框
**第三阶段**: 废弃同步接口（标记为 `[[deprecated]]`）
**第四阶段**: 完全移除同步接口

---

## 6. 文档和注释

### 6.1 代码注释

- 每个新类都需要详细的类级注释（职责、用法）
- 每个公共方法都需要文档注释（参数、返回值、注意事项）
- 复杂的线程交互需要流程图注释

### 6.2 更新 CLAUDE.md

在 `CLAUDE.md` 中添加章节：

```markdown
## 算法多线程执行

### 概述
所有算法计算在独立线程中执行，避免阻塞UI。

### 核心类
- **AlgorithmTask**: 任务封装
- **AlgorithmWorker**: 工作线程对象
- **AlgorithmThreadManager**: 线程池管理器

### 执行流程
1. AlgorithmCoordinator 调用 `AlgorithmManager::executeAsync()`
2. AlgorithmManager 获取空闲Worker并提交任务
3. Worker 在独立线程中执行算法
4. Worker 通过信号返回结果
5. AlgorithmManager 在主线程处理结果

### 进度报告
算法可以选择实现进度报告：
- 调用 `reportProgress(percentage, message)` 报告进度
- 调用 `shouldCancel()` 检查取消请求

### 取消执行
用户可以在进度对话框中点击"取消"按钮中止计算。
```

---

## 7. 风险和缓解

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|----------|
| 线程死锁 | 高 | 低 | 使用信号槽避免直接锁，代码审查 |
| 内存泄漏 | 高 | 中 | 使用智能指针，Valgrind检测 |
| 竞态条件 | 高 | 低 | 所有UI操作在主线程，代码审查 |
| 性能下降 | 中 | 低 | 性能测试对比，优化线程池 |
| 兼容性问题 | 低 | 低 | 保留同步接口，渐进式迁移 |

---

## 8. 总结

### 8.1 预期收益

- ✅ **UI响应性**: 即使算法执行中UI也保持流畅
- ✅ **用户体验**: 实时进度反馈，可取消操作
- ✅ **并发能力**: 支持多个算法同时执行（未来扩展）
- ✅ **架构优化**: 清晰的异步执行模式

### 8.2 工作量估算

| 阶段 | 工作量 | 说明 |
|------|--------|------|
| Phase 1 | 0.5天 | 设计和文档（✅ 已完成） |
| Phase 2 | 1.5天 | 实现核心类 |
| Phase 3 | 1天 | 修改 AlgorithmManager |
| Phase 4 | 1天 | 适配算法接口 |
| Phase 5 | 0.5天 | 集成到 Coordinator |
| Phase 6 | 1天 | UI进度反馈 |
| Phase 7 | 1.5天 | 测试和优化 |
| **总计** | **7天** | 约1.5周 |

### 8.3 下一步行动

1. ✅ 审查设计文档
2. 开始 Phase 2：实现核心线程基础设施
3. 编写单元测试框架
4. 准备性能测试基准

---

## 附录

### A. 参考资料

- [Qt Threading Basics](https://doc.qt.io/qt-5/thread-basics.html)
- [QThread Documentation](https://doc.qt.io/qt-5/qthread.html)
- [Worker Object Pattern](https://doc.qt.io/qt-5/threads-technologies.html#worker-object)

### B. 代码示例

详见各阶段的代码片段。

### C. 测试计划

详见 Phase 7。

---

**文档版本**: v1.0
**创建日期**: 2025-11-10
**作者**: Claude
**状态**: Phase 1 完成 ✅
