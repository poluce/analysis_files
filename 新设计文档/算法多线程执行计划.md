# ç®—æ³•å¤šçº¿ç¨‹æ‰§è¡Œè®¡åˆ’

## 1. é¡¹ç›®æ¦‚è¿°

### 1.0 è®¾è®¡å®¡æŸ¥å’Œé—®é¢˜ä¿®å¤ ğŸ”§

**åˆå§‹è®¾è®¡ä¸­çš„ä¸¥é‡é—®é¢˜** (å·²åœ¨ v1.1 ä¿®å¤):

| é—®é¢˜ | ä¼˜å…ˆçº§ | å½±å“ | ä¿®å¤æ–¹æ¡ˆ |
|------|--------|------|----------|
| AlgorithmTask åŒé‡é‡Šæ”¾ | ğŸ”´ é«˜ | å´©æºƒã€åŒé‡åˆ é™¤ | ä½¿ç”¨ QSharedPointerï¼Œæ˜ç¡®æ‰€æœ‰æƒ |
| prepareContext() é‡å¤æ‰§è¡Œ | ğŸ”´ é«˜ | éçº¿ç¨‹å®‰å…¨çš„æ•°æ®ä¿®æ”¹ | åªåœ¨ä¸»çº¿ç¨‹è°ƒç”¨ï¼ŒWorker è·³è¿‡ |
| çº¿ç¨‹æ± æ»¡æ—¶ä»»åŠ¡ä¸¢å¤± | ğŸŸ¡ ä¸­ | ç”¨æˆ·è¯·æ±‚é™é»˜å¤±è´¥ | æ·»åŠ ä»»åŠ¡é˜Ÿåˆ—æœºåˆ¶ |
| ProgressReporter æœªè®¾ç½® | ğŸŸ¡ ä¸­ | è¿›åº¦æŠ¥å‘Šæ— æ³•å·¥ä½œ | Worker è°ƒç”¨ setProgressReporter |
| AlgorithmContext å¹¶å‘è®¿é—® | ğŸŸ¡ ä¸­ | ç«æ€æ¡ä»¶ | ä¸ºæ¯ä¸ªä»»åŠ¡åˆ›å»ºä¸Šä¸‹æ–‡å¿«ç…§ |

**æ„Ÿè°¢**: æ„Ÿè°¢ä»£ç å®¡æŸ¥å‘ç°è¿™äº›å…³é”®é—®é¢˜ï¼

---

### 1.1 ç›®æ ‡
å°†æ‰€æœ‰ç®—æ³•è®¡ç®—ä»UIçº¿ç¨‹ç§»åˆ°å·¥ä½œçº¿ç¨‹ï¼Œé˜²æ­¢é•¿æ—¶é—´è®¡ç®—é˜»å¡ç•Œé¢ã€‚

### 1.2 è®¾è®¡åŸåˆ™
- âœ… **éé˜»å¡æ‰§è¡Œ**: ç®—æ³•åœ¨åå°çº¿ç¨‹æ‰§è¡Œï¼ŒUIä¿æŒå“åº”
- âœ… **è¿›åº¦åé¦ˆ**: æ”¯æŒæ˜¾ç¤ºè®¡ç®—è¿›åº¦ï¼ˆç‰¹åˆ«æ˜¯é•¿æ—¶é—´ç®—æ³•ï¼‰
- âœ… **å¯å–æ¶ˆæ€§**: ç”¨æˆ·å¯ä»¥ä¸­é€”å–æ¶ˆè®¡ç®—
- âœ… **é”™è¯¯éš”ç¦»**: çº¿ç¨‹å¼‚å¸¸ä¸å½±å“ä¸»çº¿ç¨‹
- âœ… **ä¿æŒæ¶æ„ä¸€è‡´æ€§**: ä¸ç ´åç°æœ‰çš„ä¸Šä¸‹æ–‡é©±åŠ¨æ¨¡å¼
- âœ… **å‘åå…¼å®¹**: ä¿ç•™åŒæ­¥æ‰§è¡Œæ¥å£ï¼ˆç”¨äºæµ‹è¯•ï¼‰

### 1.3 æŠ€æœ¯é€‰å‹

**é‡‡ç”¨æ–¹æ¡ˆ**: Qt Worker Object Pattern (æ¨è)

```
UIçº¿ç¨‹ (ä¸»çº¿ç¨‹)
  â†“
AlgorithmManager::executeAsync()
  â†“ å‘é€ä¿¡å·
AlgorithmWorker (åœ¨å·¥ä½œçº¿ç¨‹ä¸­)
  â†“ æ‰§è¡Œç®—æ³•
algorithm->executeWithContext(context)
  â†“ å‘é€ç»“æœä¿¡å·
AlgorithmManager::onWorkerFinished()
  â†“ å¤„ç†ç»“æœ
emit algorithmResultReady(...)
```

**ä¸ºä»€ä¹ˆä¸ç»§æ‰¿QThread**:
- Qtå®˜æ–¹æ¨èä½¿ç”¨Worker Objectæ¨¡å¼
- æ›´çµæ´»çš„çº¿ç¨‹å¤ç”¨ï¼ˆçº¿ç¨‹æ± ï¼‰
- æ›´å¥½çš„ä¿¡å·æ§½é›†æˆ
- é¿å…QThreadçš„ç”Ÿå‘½å‘¨æœŸç®¡ç†é—®é¢˜

---

## 2. æ¶æ„è®¾è®¡

### 2.1 æ ¸å¿ƒç±»è®¾è®¡

#### 2.1.1 AlgorithmTask (ä»»åŠ¡å°è£…)

```cpp
// src/domain/algorithm/algorithm_task.h
#ifndef ALGORITHM_TASK_H
#define ALGORITHM_TASK_H

#include <QString>
#include <QUuid>
#include <QDateTime>
#include <QSharedPointer>
#include "algorithm_context.h"

/**
 * @brief ç®—æ³•ä»»åŠ¡å°è£…
 *
 * å°è£…å•æ¬¡ç®—æ³•æ‰§è¡Œçš„æ‰€æœ‰ä¿¡æ¯ï¼ˆç®—æ³•åã€ä¸Šä¸‹æ–‡ã€ä»»åŠ¡IDï¼‰
 *
 * ã€æ‰€æœ‰æƒç®¡ç†ã€‘ï¼š
 * - ä½¿ç”¨ QSharedPointer ç®¡ç†ä»»åŠ¡ç”Ÿå‘½å‘¨æœŸï¼Œé¿å…åŒé‡é‡Šæ”¾
 * - AlgorithmManager å’Œ AlgorithmWorker å…±äº«æ‰€æœ‰æƒ
 * - ä¸Šä¸‹æ–‡ä¸ºä»»åŠ¡ä¸“å±å¿«ç…§ï¼ˆæ·±æ‹·è´ï¼‰ï¼Œä¸ä¸å…¶ä»–ä»»åŠ¡å…±äº«
 */
class AlgorithmTask {
public:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param algorithmName ç®—æ³•åç§°
     * @param contextSnapshot ä¸Šä¸‹æ–‡å¿«ç…§ï¼ˆå¿…é¡»æ˜¯ç‹¬ç«‹æ‹·è´ï¼‰
     */
    AlgorithmTask(const QString& algorithmName, AlgorithmContext* contextSnapshot)
        : m_taskId(QUuid::createUuid().toString())
        , m_algorithmName(algorithmName)
        , m_contextSnapshot(contextSnapshot)
        , m_createdAt(QDateTime::currentDateTime())
        , m_isCancelled(false)
    {}

    ~AlgorithmTask() {
        // æ¸…ç†ä¸Šä¸‹æ–‡å¿«ç…§ï¼ˆå¦‚æœæœªè¢«å¤–éƒ¨ç®¡ç†ï¼‰
        delete m_contextSnapshot;
    }

    QString taskId() const { return m_taskId; }
    QString algorithmName() const { return m_algorithmName; }
    AlgorithmContext* context() const { return m_contextSnapshot; }
    QDateTime createdAt() const { return m_createdAt; }

    bool isCancelled() const { return m_isCancelled; }
    void cancel() { m_isCancelled = true; }

private:
    QString m_taskId;                      // ä»»åŠ¡å”¯ä¸€ID
    QString m_algorithmName;               // ç®—æ³•åç§°
    AlgorithmContext* m_contextSnapshot;   // ä¸Šä¸‹æ–‡å¿«ç…§ï¼ˆä»»åŠ¡ç‹¬å ï¼‰
    QDateTime m_createdAt;                 // åˆ›å»ºæ—¶é—´
    bool m_isCancelled;                    // æ˜¯å¦è¢«å–æ¶ˆ
};

// æ™ºèƒ½æŒ‡é’ˆç±»å‹å®šä¹‰
using AlgorithmTaskPtr = QSharedPointer<AlgorithmTask>;

#endif // ALGORITHM_TASK_H
```

#### 2.1.2 IProgressReporter (è¿›åº¦æŠ¥å‘Šæ¥å£)

```cpp
// src/domain/algorithm/i_progress_reporter.h
#ifndef I_PROGRESS_REPORTER_H
#define I_PROGRESS_REPORTER_H

#include <QString>

/**
 * @brief è¿›åº¦æŠ¥å‘Šæ¥å£
 *
 * ç®—æ³•å¯ä»¥é€‰æ‹©å®ç°æ­¤æ¥å£æ¥æŠ¥å‘Šæ‰§è¡Œè¿›åº¦
 */
class IProgressReporter {
public:
    virtual ~IProgressReporter() = default;

    /**
     * @brief æŠ¥å‘Šè¿›åº¦
     * @param percentage è¿›åº¦ç™¾åˆ†æ¯” (0-100)
     * @param message è¿›åº¦æè¿°
     */
    virtual void reportProgress(int percentage, const QString& message = "") = 0;

    /**
     * @brief æ£€æŸ¥æ˜¯å¦è¢«è¯·æ±‚å–æ¶ˆ
     * @return true å¦‚æœåº”è¯¥å–æ¶ˆæ‰§è¡Œ
     */
    virtual bool isCancellationRequested() const = 0;
};

#endif // I_PROGRESS_REPORTER_H
```

#### 2.1.3 AlgorithmWorker (å·¥ä½œçº¿ç¨‹å¯¹è±¡)

```cpp
// src/application/algorithm/algorithm_worker.h
#ifndef ALGORITHM_WORKER_H
#define ALGORITHM_WORKER_H

#include <QObject>
#include <QVariant>
#include "algorithm_task.h"
#include "i_thermal_algorithm.h"
#include "i_progress_reporter.h"

/**
 * @brief ç®—æ³•å·¥ä½œçº¿ç¨‹å¯¹è±¡
 *
 * åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­æ‰§è¡Œç®—æ³•è®¡ç®—ï¼Œé€šè¿‡ä¿¡å·æ§½è¿”å›ç»“æœ
 */
class AlgorithmWorker : public QObject, public IProgressReporter {
    Q_OBJECT

public:
    explicit AlgorithmWorker(QObject* parent = nullptr);
    ~AlgorithmWorker() override;

    // IProgressReporter æ¥å£å®ç°
    void reportProgress(int percentage, const QString& message = "") override;
    bool isCancellationRequested() const override;

public slots:
    /**
     * @brief æ‰§è¡Œç®—æ³•ä»»åŠ¡
     * @param task ä»»åŠ¡å°è£…ï¼ˆæ™ºèƒ½æŒ‡é’ˆï¼Œå…±äº«æ‰€æœ‰æƒï¼‰
     * @param algorithm ç®—æ³•å®ä¾‹ï¼ˆå¿…é¡»æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼‰
     *
     * ã€å…³é”®ä¿®å¤ã€‘ï¼š
     * 1. ä½¿ç”¨ AlgorithmTaskPtr é¿å…åŒé‡é‡Šæ”¾
     * 2. è°ƒç”¨ algorithm->setProgressReporter(this) å¯ç”¨è¿›åº¦æŠ¥å‘Š
     * 3. è·³è¿‡ prepareContextï¼ˆå·²åœ¨ä¸»çº¿ç¨‹æ‰§è¡Œï¼‰
     */
    void executeTask(AlgorithmTaskPtr task, IThermalAlgorithm* algorithm);

    /**
     * @brief è¯·æ±‚å–æ¶ˆå½“å‰ä»»åŠ¡
     */
    void requestCancellation();

signals:
    /**
     * @brief ä»»åŠ¡å¼€å§‹æ‰§è¡Œ
     * @param taskId ä»»åŠ¡ID
     * @param algorithmName ç®—æ³•åç§°
     */
    void taskStarted(QString taskId, QString algorithmName);

    /**
     * @brief ä»»åŠ¡æ‰§è¡Œè¿›åº¦
     * @param taskId ä»»åŠ¡ID
     * @param percentage è¿›åº¦ç™¾åˆ†æ¯” (0-100)
     * @param message è¿›åº¦æè¿°
     */
    void taskProgress(QString taskId, int percentage, QString message);

    /**
     * @brief ä»»åŠ¡æ‰§è¡Œå®Œæˆ
     * @param taskId ä»»åŠ¡ID
     * @param result æ‰§è¡Œç»“æœ
     * @param elapsedMs æ‰§è¡Œæ—¶é•¿ï¼ˆæ¯«ç§’ï¼‰
     */
    void taskFinished(QString taskId, QVariant result, qint64 elapsedMs);

    /**
     * @brief ä»»åŠ¡æ‰§è¡Œå¤±è´¥
     * @param taskId ä»»åŠ¡ID
     * @param errorMessage é”™è¯¯ä¿¡æ¯
     */
    void taskFailed(QString taskId, QString errorMessage);

private:
    AlgorithmTaskPtr m_currentTask;  // å½“å‰æ‰§è¡Œçš„ä»»åŠ¡ï¼ˆæ™ºèƒ½æŒ‡é’ˆï¼‰
    bool m_cancellationRequested;    // æ˜¯å¦è¯·æ±‚å–æ¶ˆ
};

#endif // ALGORITHM_WORKER_H
```

```cpp
// src/application/algorithm/algorithm_worker.cpp
#include "algorithm_worker.h"
#include <QElapsedTimer>
#include <QDebug>

AlgorithmWorker::AlgorithmWorker(QObject* parent)
    : QObject(parent)
    , m_currentTask(nullptr)
    , m_cancellationRequested(false)
{}

AlgorithmWorker::~AlgorithmWorker() {
    // ä¸éœ€è¦ delete m_currentTaskï¼Œç”± QSharedPointer è‡ªåŠ¨ç®¡ç†
}

void AlgorithmWorker::executeTask(AlgorithmTaskPtr task, IThermalAlgorithm* algorithm) {
    if (!task || !algorithm) {
        emit taskFailed(task ? task->taskId() : "", "Invalid task or algorithm");
        return;
    }

    m_currentTask = task;
    m_cancellationRequested = false;

    QString taskId = task->taskId();
    QString algorithmName = task->algorithmName();

    qDebug() << "[Worker] Starting task" << taskId << "algorithm:" << algorithmName;
    emit taskStarted(taskId, algorithmName);

    QElapsedTimer timer;
    timer.start();

    try {
        // ğŸ”§ ä¿®å¤ï¼šè®¾ç½®è¿›åº¦æŠ¥å‘Šå™¨ï¼ˆä¹‹å‰é—æ¼ï¼‰
        algorithm->setProgressReporter(this);

        // ğŸ”§ ä¿®å¤ï¼šè·³è¿‡ prepareContextï¼ˆå·²åœ¨ä¸»çº¿ç¨‹æ‰§è¡Œï¼‰
        // prepareContext åªåœ¨ä¸»çº¿ç¨‹è°ƒç”¨ä¸€æ¬¡ï¼Œé¿å…é‡å¤æ‰§è¡Œå’Œçº¿ç¨‹å®‰å…¨é—®é¢˜
        // ä¸Šä¸‹æ–‡å·²ç»è¿‡éªŒè¯ä¸”ä¸ºä»»åŠ¡ä¸“å±å¿«ç…§ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨

        // æ£€æŸ¥å–æ¶ˆè¯·æ±‚
        if (isCancellationRequested()) {
            algorithm->setProgressReporter(nullptr); // æ¸…ç†
            emit taskFailed(taskId, "Task cancelled before execution");
            m_currentTask.clear(); // é‡Šæ”¾å…±äº«æŒ‡é’ˆ
            return;
        }

        // æ‰§è¡Œç®—æ³•
        QVariant result = algorithm->executeWithContext(task->context());

        // æ¸…ç†è¿›åº¦æŠ¥å‘Šå™¨
        algorithm->setProgressReporter(nullptr);

        // å†æ¬¡æ£€æŸ¥å–æ¶ˆè¯·æ±‚
        if (isCancellationRequested()) {
            emit taskFailed(taskId, "Task cancelled during execution");
            m_currentTask.clear();
            return;
        }

        qint64 elapsed = timer.elapsed();
        qDebug() << "[Worker] Task" << taskId << "completed in" << elapsed << "ms";
        emit taskFinished(taskId, result, elapsed);

    } catch (const std::exception& e) {
        algorithm->setProgressReporter(nullptr); // æ¸…ç†
        qWarning() << "[Worker] Task" << taskId << "failed with exception:" << e.what();
        emit taskFailed(taskId, QString("Exception: %1").arg(e.what()));
    } catch (...) {
        algorithm->setProgressReporter(nullptr); // æ¸…ç†
        qWarning() << "[Worker] Task" << taskId << "failed with unknown exception";
        emit taskFailed(taskId, "Unknown exception");
    }

    m_currentTask.clear(); // é‡Šæ”¾å…±äº«æŒ‡é’ˆï¼ˆä¸æ˜¯ deleteï¼‰
}

void AlgorithmWorker::requestCancellation() {
    qDebug() << "[Worker] Cancellation requested";
    m_cancellationRequested = true;
    if (m_currentTask) {
        m_currentTask->cancel();
    }
}

void AlgorithmWorker::reportProgress(int percentage, const QString& message) {
    if (m_currentTask) {
        emit taskProgress(m_currentTask->taskId(), percentage, message);
    }
}

bool AlgorithmWorker::isCancellationRequested() const {
    return m_cancellationRequested || (m_currentTask && m_currentTask->isCancelled());
}
```

#### 2.1.4 AlgorithmThreadManager (çº¿ç¨‹æ± ç®¡ç†å™¨)

```cpp
// src/application/algorithm/algorithm_thread_manager.h
#ifndef ALGORITHM_THREAD_MANAGER_H
#define ALGORITHM_THREAD_MANAGER_H

#include <QObject>
#include <QThread>
#include <QMap>
#include <QQueue>
#include "algorithm_worker.h"
#include "algorithm_task.h"

/**
 * @brief ç®—æ³•çº¿ç¨‹æ± ç®¡ç†å™¨
 *
 * å•ä¾‹æ¨¡å¼ï¼Œç®¡ç†å·¥ä½œçº¿ç¨‹çš„åˆ›å»ºã€å¤ç”¨å’Œé”€æ¯
 *
 * ã€å…³é”®ä¿®å¤ã€‘ï¼š
 * - æ·»åŠ ä»»åŠ¡é˜Ÿåˆ—ï¼Œé˜²æ­¢çº¿ç¨‹æ± æ»¡æ—¶ä»»åŠ¡ä¸¢å¤±
 * - Worker é‡Šæ”¾æ—¶è‡ªåŠ¨å¤„ç†é˜Ÿåˆ—ä¸­çš„å¾…å¤„ç†ä»»åŠ¡
 */
class AlgorithmThreadManager : public QObject {
    Q_OBJECT

public:
    static AlgorithmThreadManager* instance();

    /**
     * @brief è·å–ç©ºé—²çš„Worker
     * @return Workerå¯¹è±¡å’Œå…¶æ‰€åœ¨çš„çº¿ç¨‹
     *
     * ã€ä¿®å¤ã€‘ï¼šæ°¸è¿œä¸è¿”å› nullptrï¼Œå¦‚æœæ‰€æœ‰Workerå¿™åˆ™åˆ›å»ºæ–°Workerï¼ˆç›´åˆ°MAX_THREADSï¼‰
     */
    QPair<AlgorithmWorker*, QThread*> acquireWorker();

    /**
     * @brief é‡Šæ”¾Workerï¼ˆæ ‡è®°ä¸ºç©ºé—²ï¼‰
     * @param worker è¦é‡Šæ”¾çš„Worker
     *
     * ã€ä¿®å¤ã€‘ï¼šé‡Šæ”¾åè‡ªåŠ¨æ£€æŸ¥ä»»åŠ¡é˜Ÿåˆ—ï¼Œå¦‚æœæœ‰å¾…å¤„ç†ä»»åŠ¡åˆ™ç»§ç»­åˆ†é…
     */
    void releaseWorker(AlgorithmWorker* worker);

    /**
     * @brief å°†ä»»åŠ¡åŠ å…¥é˜Ÿåˆ—ï¼ˆå¦‚æœæ‰€æœ‰Workerå¿™ï¼‰
     * @param task å¾…å¤„ç†ä»»åŠ¡
     * @param algorithm ç®—æ³•å®ä¾‹
     *
     * ã€æ–°å¢ã€‘ï¼šä»»åŠ¡æ’é˜Ÿæœºåˆ¶ï¼Œé˜²æ­¢ä»»åŠ¡ä¸¢å¤±
     */
    void enqueueTask(AlgorithmTaskPtr task, IThermalAlgorithm* algorithm);

    /**
     * @brief è·å–é˜Ÿåˆ—ä¸­å¾…å¤„ç†ä»»åŠ¡æ•°é‡
     */
    int queuedTaskCount() const { return m_taskQueue.size(); }

    /**
     * @brief å…³é—­æ‰€æœ‰çº¿ç¨‹ï¼ˆåº”ç”¨é€€å‡ºæ—¶è°ƒç”¨ï¼‰
     */
    void shutdown();

signals:
    void workerCountChanged(int activeCount, int totalCount);
    void queuedTaskCountChanged(int count); // æ–°å¢ï¼šé˜Ÿåˆ—ä»»åŠ¡æ•°å˜åŒ–

private:
    explicit AlgorithmThreadManager(QObject* parent = nullptr);
    ~AlgorithmThreadManager() override;

    struct WorkerInfo {
        QThread* thread;
        AlgorithmWorker* worker;
        bool isBusy;
    };

    struct QueuedTask {
        AlgorithmTaskPtr task;
        IThermalAlgorithm* algorithm;
    };

    QList<WorkerInfo> m_workers;
    QQueue<QueuedTask> m_taskQueue;  // æ–°å¢ï¼šä»»åŠ¡é˜Ÿåˆ—
    static AlgorithmThreadManager* s_instance;

    const int MAX_THREADS = 4; // æœ€å¤§çº¿ç¨‹æ•°

    /**
     * @brief ä»é˜Ÿåˆ—ä¸­å–å‡ºä»»åŠ¡å¹¶åˆ†é…ç»™ç©ºé—²Worker
     */
    void processQueue();

    /**
     * @brief è·å–æ´»åŠ¨Workeræ•°é‡
     */
    int activeWorkerCount() const;
};

#endif // ALGORITHM_THREAD_MANAGER_H
```

```cpp
// src/application/algorithm/algorithm_thread_manager.cpp
#include "algorithm_thread_manager.h"
#include <QDebug>

AlgorithmThreadManager* AlgorithmThreadManager::s_instance = nullptr;

AlgorithmThreadManager* AlgorithmThreadManager::instance() {
    if (!s_instance) {
        s_instance = new AlgorithmThreadManager();
    }
    return s_instance;
}

AlgorithmThreadManager::AlgorithmThreadManager(QObject* parent)
    : QObject(parent)
{}

AlgorithmThreadManager::~AlgorithmThreadManager() {
    shutdown();
}

QPair<AlgorithmWorker*, QThread*> AlgorithmThreadManager::acquireWorker() {
    // 1. æŸ¥æ‰¾ç©ºé—²Worker
    for (WorkerInfo& info : m_workers) {
        if (!info.isBusy) {
            info.isBusy = true;
            qDebug() << "[ThreadManager] Reusing worker" << info.worker;
            emit workerCountChanged(activeWorkerCount(), m_workers.size());
            return {info.worker, info.thread};
        }
    }

    // 2. å¦‚æœæ²¡æœ‰ç©ºé—²Workerä¸”æœªè¾¾åˆ°æœ€å¤§çº¿ç¨‹æ•°ï¼Œåˆ›å»ºæ–°Worker
    if (m_workers.size() < MAX_THREADS) {
        QThread* thread = new QThread(this);
        AlgorithmWorker* worker = new AlgorithmWorker();
        worker->moveToThread(thread);

        // çº¿ç¨‹ç»“æŸæ—¶æ¸…ç†
        connect(thread, &QThread::finished, worker, &QObject::deleteLater);

        thread->start();

        WorkerInfo info{thread, worker, true};
        m_workers.append(info);

        qDebug() << "[ThreadManager] Created new worker" << worker << "total:" << m_workers.size();
        emit workerCountChanged(activeWorkerCount(), m_workers.size());

        return {worker, thread};
    }

    // ğŸ”§ ä¿®å¤ï¼šæ‰€æœ‰Workeréƒ½å¿™ä¸”è¾¾åˆ°æœ€å¤§çº¿ç¨‹æ•°ï¼Œè¿”å› nullptr è¡¨ç¤ºéœ€è¦æ’é˜Ÿ
    qDebug() << "[ThreadManager] All workers busy (max threads reached), caller should enqueue";
    return {nullptr, nullptr};
}

void AlgorithmThreadManager::releaseWorker(AlgorithmWorker* worker) {
    for (WorkerInfo& info : m_workers) {
        if (info.worker == worker) {
            info.isBusy = false;
            qDebug() << "[ThreadManager] Released worker" << worker;
            emit workerCountChanged(activeWorkerCount(), m_workers.size());

            // ğŸ”§ ä¿®å¤ï¼šé‡Šæ”¾åç«‹å³å¤„ç†é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡
            processQueue();
            return;
        }
    }
    qWarning() << "[ThreadManager] Attempted to release unknown worker" << worker;
}

void AlgorithmThreadManager::enqueueTask(AlgorithmTaskPtr task, IThermalAlgorithm* algorithm) {
    QueuedTask queuedTask{task, algorithm};
    m_taskQueue.enqueue(queuedTask);

    qDebug() << "[ThreadManager] Task" << task->taskId() << "enqueued, queue size:" << m_taskQueue.size();
    emit queuedTaskCountChanged(m_taskQueue.size());
}

void AlgorithmThreadManager::processQueue() {
    if (m_taskQueue.isEmpty()) {
        return; // é˜Ÿåˆ—ä¸ºç©ºï¼Œæ— éœ€å¤„ç†
    }

    // å°è¯•åˆ†é…ä»»åŠ¡ç»™ç©ºé—²Worker
    auto [worker, thread] = acquireWorker();
    if (!worker) {
        // è¿˜æ˜¯æ²¡æœ‰ç©ºé—²Workerï¼Œç­‰å¾…ä¸‹æ¬¡é‡Šæ”¾
        qDebug() << "[ThreadManager] No idle worker for queued task, waiting...";
        return;
    }

    // å–å‡ºé˜Ÿåˆ—å¤´éƒ¨ä»»åŠ¡
    QueuedTask queuedTask = m_taskQueue.dequeue();
    qDebug() << "[ThreadManager] Processing queued task" << queuedTask.task->taskId()
             << "remaining:" << m_taskQueue.size();

    emit queuedTaskCountChanged(m_taskQueue.size());

    // åˆ†é…ä»»åŠ¡ç»™Workerï¼ˆè·¨çº¿ç¨‹è°ƒç”¨ï¼‰
    QMetaObject::invokeMethod(worker, "executeTask", Qt::QueuedConnection,
                              Q_ARG(AlgorithmTaskPtr, queuedTask.task),
                              Q_ARG(IThermalAlgorithm*, queuedTask.algorithm));
}

void AlgorithmThreadManager::shutdown() {
    qDebug() << "[ThreadManager] Shutting down all threads";

    // æ¸…ç©ºä»»åŠ¡é˜Ÿåˆ—
    if (!m_taskQueue.isEmpty()) {
        qWarning() << "[ThreadManager]" << m_taskQueue.size() << "queued tasks will be discarded";
        m_taskQueue.clear();
    }

    for (const WorkerInfo& info : m_workers) {
        info.thread->quit();
        info.thread->wait(3000); // ç­‰å¾…æœ€å¤š3ç§’
        if (info.thread->isRunning()) {
            qWarning() << "[ThreadManager] Thread did not quit gracefully, terminating";
            info.thread->terminate();
        }
        delete info.thread;
    }
    m_workers.clear();
}

int AlgorithmThreadManager::activeWorkerCount() const {
    int count = 0;
    for (const WorkerInfo& info : m_workers) {
        if (info.isBusy) ++count;
    }
    return count;
}
```

---

### 2.2 ä¿®æ”¹ç°æœ‰ç±»

#### 2.2.1 AlgorithmManager (æ·»åŠ å¼‚æ­¥æ¥å£)

```cpp
// algorithm_manager.h (æ–°å¢æ–¹æ³•)
public:
    /**
     * @brief å¼‚æ­¥æ‰§è¡Œç®—æ³•ï¼ˆæ¨èä½¿ç”¨ï¼‰
     * @param algorithmName ç®—æ³•åç§°
     * @param context ä¸Šä¸‹æ–‡
     * @return ä»»åŠ¡ID
     */
    QString executeAsync(const QString& algorithmName, AlgorithmContext* context);

    /**
     * @brief å–æ¶ˆæ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡
     * @param taskId ä»»åŠ¡ID
     */
    void cancelTask(const QString& taskId);

signals:
    void algorithmStarted(QString taskId, QString algorithmName);
    void algorithmProgress(QString taskId, int percentage, QString message);
    void algorithmFinished(QString taskId, qint64 elapsedMs);
    void algorithmFailed(QString taskId, QString errorMessage);
    void algorithmQueued(QString taskId, QString algorithmName); // æ–°å¢ï¼šä»»åŠ¡æ’é˜Ÿ

private slots:
    void onWorkerStarted(QString taskId, QString algorithmName);
    void onWorkerProgress(QString taskId, int percentage, QString message);
    void onWorkerFinished(QString taskId, QVariant result, qint64 elapsedMs);
    void onWorkerFailed(QString taskId, QString errorMessage);

private:
    QMap<QString, AlgorithmTaskPtr> m_activeTasks;  // æ­£åœ¨æ‰§è¡Œ/æ’é˜Ÿçš„ä»»åŠ¡ï¼ˆæ™ºèƒ½æŒ‡é’ˆï¼‰
    QMap<QString, AlgorithmWorker*> m_taskWorkers;  // ä»»åŠ¡ID -> Workeræ˜ å°„
    QSet<AlgorithmWorker*> m_connectedWorkers;      // å·²è¿æ¥ä¿¡å·çš„Workeré›†åˆ
```

```cpp
// algorithm_manager.cpp (å®ç°å¼‚æ­¥æ‰§è¡Œ)
QString AlgorithmManager::executeAsync(const QString& algorithmName, AlgorithmContext* context) {
    // 1. è·å–ç®—æ³•å®ä¾‹
    IThermalAlgorithm* algorithm = getAlgorithm(algorithmName);
    if (!algorithm) {
        qWarning() << "[AlgorithmManager] Algorithm not found:" << algorithmName;
        return QString();
    }

    // ğŸ”§ ä¿®å¤ï¼šåªåœ¨ä¸»çº¿ç¨‹è°ƒç”¨ä¸€æ¬¡ prepareContextï¼ŒéªŒè¯æ•°æ®å®Œæ•´æ€§
    if (!algorithm->prepareContext(context)) {
        qWarning() << "[AlgorithmManager] Context preparation failed for" << algorithmName;
        return QString();
    }

    // ğŸ”§ ä¿®å¤ï¼šåˆ›å»ºä¸Šä¸‹æ–‡å¿«ç…§ï¼ˆæ·±æ‹·è´ï¼‰ï¼Œé¿å…å¹¶å‘è®¿é—®
    // AlgorithmContext éœ€è¦å®ç° clone() æ–¹æ³•
    AlgorithmContext* contextSnapshot = context->clone();
    if (!contextSnapshot) {
        qWarning() << "[AlgorithmManager] Failed to create context snapshot";
        return QString();
    }

    // 3. åˆ›å»ºä»»åŠ¡ï¼ˆä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆï¼‰
    AlgorithmTaskPtr task = AlgorithmTaskPtr::create(algorithmName, contextSnapshot);
    QString taskId = task->taskId();

    // 4. è·å–Worker
    auto [worker, thread] = AlgorithmThreadManager::instance()->acquireWorker();
    if (!worker) {
        // ğŸ”§ ä¿®å¤ï¼šæ‰€æœ‰Workerå¿™ï¼Œå°†ä»»åŠ¡åŠ å…¥é˜Ÿåˆ—
        qDebug() << "[AlgorithmManager] All workers busy, enqueueing task" << taskId;
        AlgorithmThreadManager::instance()->enqueueTask(task, algorithm);

        // ä»ç„¶è®°å½•ä»»åŠ¡ï¼ˆç­‰å¾…é˜Ÿåˆ—å¤„ç†ï¼‰
        m_activeTasks[taskId] = task;
        // m_taskWorkers[taskId] æš‚ä¸è®¾ç½®ï¼Œç­‰é˜Ÿåˆ—åˆ†é…æ—¶å†è®¾ç½®

        emit algorithmQueued(taskId, algorithmName); // æ–°å¢ä¿¡å·ï¼šä»»åŠ¡å·²æ’é˜Ÿ
        return taskId;
    }

    // 5. è¿æ¥ä¿¡å·ï¼ˆä»…é¦–æ¬¡è¿æ¥ï¼‰
    if (!m_connectedWorkers.contains(worker)) {
        connect(worker, &AlgorithmWorker::taskStarted, this, &AlgorithmManager::onWorkerStarted);
        connect(worker, &AlgorithmWorker::taskProgress, this, &AlgorithmManager::onWorkerProgress);
        connect(worker, &AlgorithmWorker::taskFinished, this, &AlgorithmManager::onWorkerFinished);
        connect(worker, &AlgorithmWorker::taskFailed, this, &AlgorithmManager::onWorkerFailed);
        m_connectedWorkers.insert(worker);
    }

    // 6. è®°å½•ä»»åŠ¡
    m_activeTasks[taskId] = task;
    m_taskWorkers[taskId] = worker;

    // 7. è§¦å‘æ‰§è¡Œï¼ˆè·¨çº¿ç¨‹è°ƒç”¨ï¼Œé€šè¿‡ä¿¡å·æ§½ï¼‰
    QMetaObject::invokeMethod(worker, "executeTask", Qt::QueuedConnection,
                              Q_ARG(AlgorithmTaskPtr, task),
                              Q_ARG(IThermalAlgorithm*, algorithm));

    qDebug() << "[AlgorithmManager] Submitted task" << taskId << "algorithm:" << algorithmName;
    return taskId;
}

void AlgorithmManager::onWorkerFinished(QString taskId, QVariant result, qint64 elapsedMs) {
    qDebug() << "[AlgorithmManager] Task" << taskId << "finished in" << elapsedMs << "ms";

    // 1. è·å–ä»»åŠ¡ä¿¡æ¯
    if (!m_activeTasks.contains(taskId)) {
        qWarning() << "[AlgorithmManager] Unknown task finished:" << taskId;
        return;
    }

    AlgorithmTaskPtr task = m_activeTasks[taskId];
    IThermalAlgorithm* algorithm = getAlgorithm(task->algorithmName());
    ThermalCurve* curve = task->context()->get<ThermalCurve*>("activeCurve").value();

    // 2. å¤„ç†ç»“æœï¼ˆå’ŒåŒæ­¥ç‰ˆæœ¬ç›¸åŒï¼‰
    handleAlgorithmResult(algorithm, curve, result);

    // 3. å‘å‡ºå®Œæˆä¿¡å·
    emit algorithmFinished(taskId, elapsedMs);
    emit algorithmResultReady(task->algorithmName(), curve, result);

    // 4. æ¸…ç†ï¼ˆæ™ºèƒ½æŒ‡é’ˆè‡ªåŠ¨é‡Šæ”¾ï¼Œä¸éœ€è¦ deleteï¼‰
    AlgorithmWorker* worker = m_taskWorkers.take(taskId);
    if (worker) {
        AlgorithmThreadManager::instance()->releaseWorker(worker);
    }

    m_activeTasks.remove(taskId); // ç§»é™¤æ™ºèƒ½æŒ‡é’ˆå¼•ç”¨
}
```

#### 2.2.2 IThermalAlgorithm (æ·»åŠ å¯é€‰çš„è¿›åº¦æ”¯æŒ)

```cpp
// i_thermal_algorithm.h (æ·»åŠ æ–¹æ³•)
public:
    /**
     * @brief è®¾ç½®è¿›åº¦æŠ¥å‘Šå™¨ï¼ˆå¯é€‰ï¼‰
     * @param reporter è¿›åº¦æŠ¥å‘Šå™¨
     *
     * ç®—æ³•å¯ä»¥é€‰æ‹©æ€§åœ°ä½¿ç”¨æ­¤æ¥å£æŠ¥å‘Šæ‰§è¡Œè¿›åº¦
     */
    virtual void setProgressReporter(IProgressReporter* reporter) {
        Q_UNUSED(reporter);
        // é»˜è®¤å®ç°ï¼šä¸åšä»»ä½•äº‹ï¼ˆç®—æ³•ä¸æ”¯æŒè¿›åº¦æŠ¥å‘Šï¼‰
    }

protected:
    /**
     * @brief æŠ¥å‘Šè¿›åº¦çš„ä¾¿æ·æ–¹æ³•
     * @param percentage è¿›åº¦ç™¾åˆ†æ¯” (0-100)
     * @param message è¿›åº¦æè¿°
     */
    void reportProgress(int percentage, const QString& message = "") {
        if (m_progressReporter) {
            m_progressReporter->reportProgress(percentage, message);
        }
    }

    /**
     * @brief æ£€æŸ¥æ˜¯å¦åº”è¯¥å–æ¶ˆæ‰§è¡Œ
     * @return true å¦‚æœåº”è¯¥å–æ¶ˆ
     */
    bool shouldCancel() const {
        return m_progressReporter && m_progressReporter->isCancellationRequested();
    }

private:
    IProgressReporter* m_progressReporter = nullptr;
```

---

## 3. å®æ–½è®¡åˆ’

### Phase 1: åˆ†æå½“å‰æ¶æ„å¹¶è®¾è®¡çº¿ç¨‹æ–¹æ¡ˆ âœ…

**ä»»åŠ¡**:
- âœ… åˆ†æç°æœ‰ç®—æ³•æ‰§è¡Œæµç¨‹
- âœ… ç¡®å®šæŠ€æœ¯æ–¹æ¡ˆï¼ˆWorker Object Patternï¼‰
- âœ… è®¾è®¡æ ¸å¿ƒç±»ï¼ˆAlgorithmTaskã€IProgressReporterã€AlgorithmWorkerã€AlgorithmThreadManagerï¼‰
- âœ… ç¼–å†™è®¾è®¡æ–‡æ¡£

**éªŒæ”¶æ ‡å‡†**:
- è®¾è®¡æ–‡æ¡£å®Œæˆ
- ç±»èŒè´£æ¸…æ™°
- ä¿¡å·æ§½æµç¨‹æ˜ç¡®

---

### Phase 2: å®ç°æ ¸å¿ƒçº¿ç¨‹åŸºç¡€è®¾æ–½

**ä»»åŠ¡**:
1. å®ç° `AlgorithmTask` ç±»ï¼ˆä»»åŠ¡å°è£…ï¼‰
2. å®ç° `IProgressReporter` æ¥å£
3. å®ç° `AlgorithmWorker` ç±»ï¼ˆå·¥ä½œçº¿ç¨‹å¯¹è±¡ï¼‰
4. å®ç° `AlgorithmThreadManager` ç±»ï¼ˆçº¿ç¨‹æ± ç®¡ç†å™¨ï¼‰

**æ–‡ä»¶æ¸…å•**:
- `src/domain/algorithm/algorithm_task.h`
- `src/domain/algorithm/i_progress_reporter.h`
- `src/application/algorithm/algorithm_worker.h`
- `src/application/algorithm/algorithm_worker.cpp`
- `src/application/algorithm/algorithm_thread_manager.h`
- `src/application/algorithm/algorithm_thread_manager.cpp`

**éªŒæ”¶æ ‡å‡†**:
- æ‰€æœ‰ç±»ç¼–è¯‘é€šè¿‡
- çº¿ç¨‹æ± èƒ½å¤Ÿåˆ›å»ºå’Œå¤ç”¨Worker
- Workerèƒ½å¤Ÿåœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­è¿è¡Œ

---

### Phase 3: ä¿®æ”¹ AlgorithmManager æ”¯æŒå¼‚æ­¥æ‰§è¡Œ

**ä»»åŠ¡**:
1. æ·»åŠ  `executeAsync()` æ–¹æ³•
2. æ·»åŠ  `cancelTask()` æ–¹æ³•
3. æ·»åŠ ä¿¡å·ï¼š`algorithmStarted`, `algorithmProgress`, `algorithmFinished`, `algorithmFailed`
4. å®ç°æ§½å‡½æ•°ï¼š`onWorkerStarted`, `onWorkerProgress`, `onWorkerFinished`, `onWorkerFailed`
5. ç®¡ç†æ´»åŠ¨ä»»åŠ¡æ˜ å°„ (`m_activeTasks`, `m_taskWorkers`)

**ä¿®æ”¹æ–‡ä»¶**:
- `src/application/algorithm/algorithm_manager.h`
- `src/application/algorithm/algorithm_manager.cpp`

**éªŒæ”¶æ ‡å‡†**:
- å¼‚æ­¥æ‰§è¡Œæ¥å£å¯ç”¨
- ç»“æœå›è°ƒæ­£ç¡®å¤„ç†
- ä»»åŠ¡ç”Ÿå‘½å‘¨æœŸç®¡ç†æ­£ç¡®

---

### Phase 4: é€‚é…ç®—æ³•æ¥å£æ”¯æŒè¿›åº¦æŠ¥å‘Š

**ä»»åŠ¡**:
1. ä¿®æ”¹ `IThermalAlgorithm` æ·»åŠ  `setProgressReporter()` æ–¹æ³•
2. æ·»åŠ  `reportProgress()` å’Œ `shouldCancel()` ä¾¿æ·æ–¹æ³•
3. åœ¨é•¿æ—¶é—´ç®—æ³•ä¸­æ·»åŠ è¿›åº¦æŠ¥å‘Šï¼ˆå¦‚å¾®åˆ†ã€ç§¯åˆ†ï¼‰

**ç¤ºä¾‹**:
```cpp
// DifferentiationAlgorithm::executeWithContext() ä¸­æ·»åŠ 
QVariant DifferentiationAlgorithm::executeWithContext(AlgorithmContext* context) {
    // ... å‰ç½®ä»£ç  ...

    for (int i = 0; i < data.size(); ++i) {
        // æ¯å¤„ç†10%æŠ¥å‘Šä¸€æ¬¡è¿›åº¦
        if (i % (data.size() / 10) == 0) {
            reportProgress(i * 100 / data.size(), QString("å·²å¤„ç† %1/%2 ç‚¹").arg(i).arg(data.size()));
        }

        // æ£€æŸ¥å–æ¶ˆè¯·æ±‚
        if (shouldCancel()) {
            qDebug() << "[Differentiation] Execution cancelled by user";
            return QVariant();
        }

        // ... ç®—æ³•é€»è¾‘ ...
    }

    reportProgress(100, "å¾®åˆ†è®¡ç®—å®Œæˆ");
    return QVariant::fromValue(result);
}
```

**ä¿®æ”¹æ–‡ä»¶**:
- `src/domain/algorithm/i_thermal_algorithm.h`
- `src/infrastructure/algorithm/differentiation_algorithm.cpp`
- `src/infrastructure/algorithm/integration_algorithm.cpp`
- `src/infrastructure/algorithm/moving_average_filter_algorithm.cpp`

**éªŒæ”¶æ ‡å‡†**:
- ç®—æ³•èƒ½å¤ŸæŠ¥å‘Šè¿›åº¦
- ç®—æ³•èƒ½å¤Ÿå“åº”å–æ¶ˆè¯·æ±‚
- ä¸æ”¯æŒè¿›åº¦çš„ç®—æ³•ä¸å—å½±å“

---

### Phase 5: é›†æˆåˆ° AlgorithmCoordinator

**ä»»åŠ¡**:
1. ä¿®æ”¹ `AlgorithmCoordinator::executeAlgorithm()` è°ƒç”¨å¼‚æ­¥æ¥å£
2. ä¿å­˜ taskId åˆ° PendingRequest
3. å¤„ç†å¼‚æ­¥å›è°ƒä¿¡å·

**ä¿®æ”¹æ–‡ä»¶**:
- `src/application/algorithm/algorithm_coordinator.h`
- `src/application/algorithm/algorithm_coordinator.cpp`

**ä»£ç ç¤ºä¾‹**:
```cpp
void AlgorithmCoordinator::executeAlgorithm(const QString& algorithmName) {
    // ... å‰ç½®ä»£ç  ...

    // è°ƒç”¨å¼‚æ­¥æ‰§è¡Œ
    QString taskId = m_algorithmManager->executeAsync(algorithmName, m_context);
    if (taskId.isEmpty()) {
        qWarning() << "[AlgorithmCoordinator] Failed to submit task";
        return;
    }

    // ä¿å­˜taskIdåˆ°å¾…å¤„ç†è¯·æ±‚
    if (m_pendingRequests.contains(algorithmName)) {
        m_pendingRequests[algorithmName].taskId = taskId;
    }

    qDebug() << "[AlgorithmCoordinator] Submitted algorithm" << algorithmName << "taskId:" << taskId;
}
```

**éªŒæ”¶æ ‡å‡†**:
- AlgorithmCoordinator èƒ½å¤Ÿè§¦å‘å¼‚æ­¥æ‰§è¡Œ
- ç»“æœå›è°ƒèƒ½å¤Ÿæ­£ç¡®å¤„ç†

---

### Phase 6: UI å±‚æ·»åŠ è¿›åº¦åé¦ˆ

**ä»»åŠ¡**:
1. MainWindow æ·»åŠ è¿›åº¦å¯¹è¯æ¡† (`QProgressDialog`)
2. MainController è¿æ¥è¿›åº¦ä¿¡å·
3. æ˜¾ç¤ºè¿›åº¦ç™¾åˆ†æ¯”å’Œæ¶ˆæ¯
4. æ”¯æŒå–æ¶ˆæŒ‰é’®

**ä¿®æ”¹æ–‡ä»¶**:
- `src/ui/main_window.h`
- `src/ui/main_window.cpp`
- `src/ui/controller/main_controller.h`
- `src/ui/controller/main_controller.cpp`

**ä»£ç ç¤ºä¾‹**:
```cpp
// main_controller.cpp
void MainController::onAlgorithmStarted(QString taskId, QString algorithmName) {
    qDebug() << "[MainController] Algorithm started:" << algorithmName << "taskId:" << taskId;

    // æ˜¾ç¤ºè¿›åº¦å¯¹è¯æ¡†
    m_progressDialog = new QProgressDialog(
        QString("æ­£åœ¨æ‰§è¡Œ: %1").arg(algorithmName),
        "å–æ¶ˆ",
        0, 100,
        m_mainWindow
    );
    m_progressDialog->setWindowModality(Qt::WindowModal);
    m_progressDialog->setMinimumDuration(500); // 500msåæ‰æ˜¾ç¤º
    m_progressDialog->setValue(0);

    // è¿æ¥å–æ¶ˆä¿¡å·
    connect(m_progressDialog, &QProgressDialog::canceled, this, [this, taskId]() {
        qDebug() << "[MainController] User requested cancellation for task" << taskId;
        m_algorithmManager->cancelTask(taskId);
    });

    m_currentTaskId = taskId;
}

void MainController::onAlgorithmProgress(QString taskId, int percentage, QString message) {
    if (taskId != m_currentTaskId || !m_progressDialog) return;

    m_progressDialog->setValue(percentage);
    if (!message.isEmpty()) {
        m_progressDialog->setLabelText(message);
    }
}

void MainController::onAlgorithmFinished(QString taskId, qint64 elapsedMs) {
    if (taskId != m_currentTaskId) return;

    qDebug() << "[MainController] Algorithm finished in" << elapsedMs << "ms";

    if (m_progressDialog) {
        m_progressDialog->close();
        delete m_progressDialog;
        m_progressDialog = nullptr;
    }

    m_currentTaskId.clear();
}
```

**éªŒæ”¶æ ‡å‡†**:
- è¿›åº¦å¯¹è¯æ¡†èƒ½å¤Ÿæ˜¾ç¤º
- è¿›åº¦ç™¾åˆ†æ¯”å®æ—¶æ›´æ–°
- å–æ¶ˆæŒ‰é’®èƒ½å¤Ÿä¸­æ­¢è®¡ç®—
- è®¡ç®—å®Œæˆåå¯¹è¯æ¡†è‡ªåŠ¨å…³é—­

---

### Phase 7: æµ‹è¯•å’Œä¼˜åŒ–

**ä»»åŠ¡**:
1. å•å…ƒæµ‹è¯•ï¼ˆAlgorithmWorkerã€AlgorithmThreadManagerï¼‰
2. é›†æˆæµ‹è¯•ï¼ˆå®Œæ•´ç®—æ³•æ‰§è¡Œæµç¨‹ï¼‰
3. å‹åŠ›æµ‹è¯•ï¼ˆå¤šä»»åŠ¡å¹¶å‘ï¼‰
4. æ€§èƒ½æµ‹è¯•ï¼ˆå¯¹æ¯”åŒæ­¥æ‰§è¡Œï¼‰
5. å†…å­˜æ³„æ¼æ£€æŸ¥
6. ä¼˜åŒ–çº¿ç¨‹æ± ç­–ç•¥

**æµ‹è¯•åœºæ™¯**:
- âœ… ç®€å•ç®—æ³•ï¼ˆå¾®åˆ†ã€ç§¯åˆ†ï¼‰å¼‚æ­¥æ‰§è¡Œ
- âœ… é•¿æ—¶é—´ç®—æ³•ï¼ˆå¤§æ•°æ®é›†ï¼‰è¿›åº¦æŠ¥å‘Š
- âœ… ç”¨æˆ·å–æ¶ˆæ‰§è¡Œ
- âœ… å¤šä¸ªç®—æ³•å¹¶å‘æ‰§è¡Œ
- âœ… çº¿ç¨‹æ± å¤ç”¨éªŒè¯
- âœ… å¼‚å¸¸æƒ…å†µï¼ˆç®—æ³•æŠ›å‡ºå¼‚å¸¸ã€ä¸Šä¸‹æ–‡æ— æ•ˆç­‰ï¼‰

**æ€§èƒ½æŒ‡æ ‡**:
- UIå“åº”æ—¶é—´ < 100msï¼ˆå³ä½¿ç®—æ³•æ‰§è¡Œä¸­ï¼‰
- çº¿ç¨‹å¼€é”€ < 10% CPUï¼ˆç©ºé—²æ—¶ï¼‰
- å†…å­˜å ç”¨ < 50MBï¼ˆ4ä¸ªçº¿ç¨‹ï¼‰

**éªŒæ”¶æ ‡å‡†**:
- æ‰€æœ‰æµ‹è¯•é€šè¿‡
- æ— å†…å­˜æ³„æ¼
- UIå§‹ç»ˆä¿æŒå“åº”

---

## 4. æŠ€æœ¯ç»†èŠ‚

### 4.1 çº¿ç¨‹å®‰å…¨è€ƒè™‘

**âœ… å®‰å…¨çš„è®¾è®¡ï¼ˆv1.1 ä¿®å¤åï¼‰**:
- âœ… `AlgorithmContext`: æ¯ä¸ªä»»åŠ¡ä½¿ç”¨ç‹¬ç«‹å¿«ç…§ï¼ˆæ·±æ‹·è´ï¼‰ï¼Œæ— å…±äº«è®¿é—®
- âœ… `AlgorithmTask`: ä½¿ç”¨ QSharedPointer ç®¡ç†ï¼Œé¿å…åŒé‡é‡Šæ”¾
- âœ… `ThermalCurve`: åªè¯»è®¿é—®ï¼ˆ`getProcessedData()`ï¼‰
- âœ… `QVariant`: å€¼ç±»å‹ï¼Œè‡ªåŠ¨æ‹·è´

**âš ï¸ éœ€è¦æ³¨æ„çš„**:
- âš ï¸ `CurveManager`: æ·»åŠ æ›²çº¿æ—¶éœ€è¦å›åˆ°ä¸»çº¿ç¨‹ï¼ˆé€šè¿‡ä¿¡å·æ§½ï¼‰
- âš ï¸ `AlgorithmDescriptor`: åªè¯»è®¿é—®ï¼Œæ— éœ€æ‹…å¿ƒ
- âš ï¸ `IThermalAlgorithm`: ç®—æ³•å®ä¾‹åº”è¯¥æ˜¯æ— çŠ¶æ€çš„ï¼ˆæˆå‘˜å˜é‡ä»…ç”¨äºé»˜è®¤å‚æ•°ï¼‰

**ğŸ”§ ä¿®å¤æ–¹æ¡ˆ**:
1. **ä¸Šä¸‹æ–‡éš”ç¦»**: ä¸ºæ¯ä¸ªä»»åŠ¡åˆ›å»ºä¸Šä¸‹æ–‡å¿«ç…§
   ```cpp
   AlgorithmContext* contextSnapshot = context->clone();
   AlgorithmTaskPtr task = AlgorithmTaskPtr::create(algorithmName, contextSnapshot);
   ```

2. **æ™ºèƒ½æŒ‡é’ˆç®¡ç†**: ä½¿ç”¨ QSharedPointer é¿å…æ‰€æœ‰æƒé—®é¢˜
   ```cpp
   using AlgorithmTaskPtr = QSharedPointer<AlgorithmTask>;
   QMap<QString, AlgorithmTaskPtr> m_activeTasks;
   ```

3. **å•æ¬¡éªŒè¯**: prepareContext åªåœ¨ä¸»çº¿ç¨‹è°ƒç”¨ä¸€æ¬¡
   ```cpp
   // ä¸»çº¿ç¨‹ï¼ˆAlgorithmManager::executeAsyncï¼‰
   algorithm->prepareContext(context); // âœ… åªè°ƒç”¨ä¸€æ¬¡

   // å·¥ä½œçº¿ç¨‹ï¼ˆAlgorithmWorker::executeTaskï¼‰
   // è·³è¿‡ prepareContextï¼Œç›´æ¥æ‰§è¡Œ âœ…
   algorithm->executeWithContext(task->context());
   ```

4. **ä¿¡å·æ§½å›åˆ°ä¸»çº¿ç¨‹**: æ‰€æœ‰UIæ›´æ–°å’Œæ•°æ®ä¿®æ”¹é€šè¿‡ä¿¡å·æ§½
   ```cpp
   // å·¥ä½œçº¿ç¨‹å‘å‡ºä¿¡å·
   emit taskFinished(taskId, result, elapsed);

   // ä¸»çº¿ç¨‹å¤„ç†
   void AlgorithmManager::onWorkerFinished(...) {
       handleAlgorithmResult(...); // åœ¨ä¸»çº¿ç¨‹æ‰§è¡Œ
   }
   ```

**AlgorithmContext::clone() å®ç°è¦æ±‚**:
```cpp
// src/application/algorithm/algorithm_context.h
class AlgorithmContext : public QObject {
public:
    /**
     * @brief åˆ›å»ºä¸Šä¸‹æ–‡æ·±æ‹·è´
     * @return æ–°çš„ä¸Šä¸‹æ–‡å¯¹è±¡ï¼ˆè°ƒç”¨è€…è´Ÿè´£é‡Šæ”¾ï¼‰
     *
     * ã€å…³é”®ã€‘ï¼šå¿…é¡»æ·±æ‹·è´æ‰€æœ‰æ•°æ®ï¼Œé¿å…å…±äº«å¼•ç”¨
     */
    AlgorithmContext* clone() const {
        AlgorithmContext* copy = new AlgorithmContext();

        // æ·±æ‹·è´æ‰€æœ‰é”®å€¼å¯¹
        for (auto it = m_data.constBegin(); it != m_data.constEnd(); ++it) {
            const QString& key = it.key();
            const ContextValue& value = it.value();

            // ç‰¹æ®Šå¤„ç†ï¼šæŒ‡é’ˆç±»å‹éœ€è¦æ‹·è´å¼•ç”¨ï¼ˆåªè¯»è®¿é—®ï¼‰
            // å¦‚ ThermalCurve* ä¸éœ€è¦æ‹·è´æ•´ä¸ªæ›²çº¿ï¼Œåªæ‹·è´æŒ‡é’ˆ
            copy->m_data[key] = value; // æµ…æ‹·è´ç»“æ„ä½“ï¼ˆåŒ…å«QVariantï¼‰
        }

        return copy;
    }
};
```

### 4.2 å–æ¶ˆæœºåˆ¶

**å®ç°æ–¹å¼**:
1. ç”¨æˆ·ç‚¹å‡»å–æ¶ˆæŒ‰é’®
2. MainController è°ƒç”¨ `AlgorithmManager::cancelTask(taskId)`
3. AlgorithmManager è°ƒç”¨ `AlgorithmWorker::requestCancellation()`
4. Worker è®¾ç½® `m_cancellationRequested = true`
5. ç®—æ³•åœ¨å¾ªç¯ä¸­å®šæœŸæ£€æŸ¥ `shouldCancel()`
6. å¦‚æœè¿”å›trueï¼Œç®—æ³•ç«‹å³è¿”å› `QVariant()`
7. Worker å‘å‡º `taskFailed` ä¿¡å·

**è¦æ±‚**:
- ç®—æ³•å¿…é¡»å®šæœŸæ£€æŸ¥å–æ¶ˆè¯·æ±‚ï¼ˆæ¯100æ¬¡è¿­ä»£æˆ–æ¯100msï¼‰
- ç®—æ³•ä¸èƒ½åœ¨å¾ªç¯å¤–é•¿æ—¶é—´é˜»å¡ï¼ˆå¦‚IOæ“ä½œï¼‰
- å–æ¶ˆååº”è¯¥å¿«é€Ÿè¿”å›ï¼ˆ< 1ç§’ï¼‰

### 4.3 é”™è¯¯å¤„ç†

**å¼‚å¸¸æ•è·**:
- Worker åœ¨ `executeTask()` ä¸­ä½¿ç”¨ `try-catch` æ•è·æ‰€æœ‰å¼‚å¸¸
- å‘å‡º `taskFailed` ä¿¡å·å¹¶é™„å¸¦é”™è¯¯ä¿¡æ¯
- ä¸»çº¿ç¨‹æ˜¾ç¤ºé”™è¯¯å¯¹è¯æ¡†

**æ•°æ®éªŒè¯**:
- åœ¨ä¸»çº¿ç¨‹ä¸­éªŒè¯ä¸Šä¸‹æ–‡ï¼ˆ`prepareContext()`ï¼‰
- é¿å…åœ¨å·¥ä½œçº¿ç¨‹ä¸­å‘ç°æ•°æ®é—®é¢˜

### 4.4 æ€§èƒ½ä¼˜åŒ–

**çº¿ç¨‹æ± ç­–ç•¥**:
- æœ€å¤§çº¿ç¨‹æ•°ï¼š`QThread::idealThreadCount()`ï¼ˆé€šå¸¸æ˜¯CPUæ ¸å¿ƒæ•°ï¼‰
- çº¿ç¨‹å¤ç”¨ï¼šç©ºé—²Workerä¿ç•™åœ¨æ± ä¸­ï¼Œé¿å…é¢‘ç¹åˆ›å»º/é”€æ¯
- ä»»åŠ¡é˜Ÿåˆ—ï¼šå¦‚æœæ‰€æœ‰Workerå¿™ï¼Œæ–°ä»»åŠ¡è¿›å…¥é˜Ÿåˆ—ç­‰å¾…

**æ•°æ®æ‹·è´ä¼˜åŒ–**:
- ä½¿ç”¨ `QSharedPointer` å…±äº«å¤§æ•°æ®ï¼ˆå¦‚ ThermalCurveï¼‰
- ä¸Šä¸‹æ–‡ä¸­å­˜å‚¨æŒ‡é’ˆè€Œéå€¼ï¼ˆé¿å…æ‹·è´ï¼‰
- ç»“æœè¿”å›ä½¿ç”¨ `QVariant::fromValue` é¿å…å¤šæ¬¡æ‹·è´

---

## 5. å‘åå…¼å®¹æ€§

### 5.1 ä¿ç•™åŒæ­¥æ¥å£

ä¸ºäº†æµ‹è¯•å’Œè°ƒè¯•ï¼Œä¿ç•™åŒæ­¥æ‰§è¡Œæ¥å£ï¼š

```cpp
// AlgorithmManager (ä¿ç•™)
void executeWithContext(const QString& algorithmName, AlgorithmContext* context);
```

### 5.2 æ¸è¿›å¼è¿ç§»

**ç¬¬ä¸€é˜¶æ®µ**: å®ç°å¼‚æ­¥åŸºç¡€è®¾æ–½ï¼Œä½†ä¸»è¦ä½¿ç”¨åŒæ­¥æ¥å£
**ç¬¬äºŒé˜¶æ®µ**: åœ¨ MainController ä¸­å¯ç”¨å¼‚æ­¥æ‰§è¡Œï¼Œæ·»åŠ è¿›åº¦å¯¹è¯æ¡†
**ç¬¬ä¸‰é˜¶æ®µ**: åºŸå¼ƒåŒæ­¥æ¥å£ï¼ˆæ ‡è®°ä¸º `[[deprecated]]`ï¼‰
**ç¬¬å››é˜¶æ®µ**: å®Œå…¨ç§»é™¤åŒæ­¥æ¥å£

---

## 6. æ–‡æ¡£å’Œæ³¨é‡Š

### 6.1 ä»£ç æ³¨é‡Š

- æ¯ä¸ªæ–°ç±»éƒ½éœ€è¦è¯¦ç»†çš„ç±»çº§æ³¨é‡Šï¼ˆèŒè´£ã€ç”¨æ³•ï¼‰
- æ¯ä¸ªå…¬å…±æ–¹æ³•éƒ½éœ€è¦æ–‡æ¡£æ³¨é‡Šï¼ˆå‚æ•°ã€è¿”å›å€¼ã€æ³¨æ„äº‹é¡¹ï¼‰
- å¤æ‚çš„çº¿ç¨‹äº¤äº’éœ€è¦æµç¨‹å›¾æ³¨é‡Š

### 6.2 æ›´æ–° CLAUDE.md

åœ¨ `CLAUDE.md` ä¸­æ·»åŠ ç« èŠ‚ï¼š

```markdown
## ç®—æ³•å¤šçº¿ç¨‹æ‰§è¡Œ

### æ¦‚è¿°
æ‰€æœ‰ç®—æ³•è®¡ç®—åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­æ‰§è¡Œï¼Œé¿å…é˜»å¡UIã€‚

### æ ¸å¿ƒç±»
- **AlgorithmTask**: ä»»åŠ¡å°è£…
- **AlgorithmWorker**: å·¥ä½œçº¿ç¨‹å¯¹è±¡
- **AlgorithmThreadManager**: çº¿ç¨‹æ± ç®¡ç†å™¨

### æ‰§è¡Œæµç¨‹
1. AlgorithmCoordinator è°ƒç”¨ `AlgorithmManager::executeAsync()`
2. AlgorithmManager è·å–ç©ºé—²Workerå¹¶æäº¤ä»»åŠ¡
3. Worker åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­æ‰§è¡Œç®—æ³•
4. Worker é€šè¿‡ä¿¡å·è¿”å›ç»“æœ
5. AlgorithmManager åœ¨ä¸»çº¿ç¨‹å¤„ç†ç»“æœ

### è¿›åº¦æŠ¥å‘Š
ç®—æ³•å¯ä»¥é€‰æ‹©å®ç°è¿›åº¦æŠ¥å‘Šï¼š
- è°ƒç”¨ `reportProgress(percentage, message)` æŠ¥å‘Šè¿›åº¦
- è°ƒç”¨ `shouldCancel()` æ£€æŸ¥å–æ¶ˆè¯·æ±‚

### å–æ¶ˆæ‰§è¡Œ
ç”¨æˆ·å¯ä»¥åœ¨è¿›åº¦å¯¹è¯æ¡†ä¸­ç‚¹å‡»"å–æ¶ˆ"æŒ‰é’®ä¸­æ­¢è®¡ç®—ã€‚
```

---

## 7. é£é™©å’Œç¼“è§£

| é£é™© | å½±å“ | æ¦‚ç‡ | ç¼“è§£æªæ–½ |
|------|------|------|----------|
| çº¿ç¨‹æ­»é” | é«˜ | ä½ | ä½¿ç”¨ä¿¡å·æ§½é¿å…ç›´æ¥é”ï¼Œä»£ç å®¡æŸ¥ |
| å†…å­˜æ³„æ¼ | é«˜ | ä¸­ | ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆï¼ŒValgrindæ£€æµ‹ |
| ç«æ€æ¡ä»¶ | é«˜ | ä½ | æ‰€æœ‰UIæ“ä½œåœ¨ä¸»çº¿ç¨‹ï¼Œä»£ç å®¡æŸ¥ |
| æ€§èƒ½ä¸‹é™ | ä¸­ | ä½ | æ€§èƒ½æµ‹è¯•å¯¹æ¯”ï¼Œä¼˜åŒ–çº¿ç¨‹æ±  |
| å…¼å®¹æ€§é—®é¢˜ | ä½ | ä½ | ä¿ç•™åŒæ­¥æ¥å£ï¼Œæ¸è¿›å¼è¿ç§» |

---

## 8. æ€»ç»“

### 8.1 é¢„æœŸæ”¶ç›Š

- âœ… **UIå“åº”æ€§**: å³ä½¿ç®—æ³•æ‰§è¡Œä¸­UIä¹Ÿä¿æŒæµç•…
- âœ… **ç”¨æˆ·ä½“éªŒ**: å®æ—¶è¿›åº¦åé¦ˆï¼Œå¯å–æ¶ˆæ“ä½œ
- âœ… **å¹¶å‘èƒ½åŠ›**: æ”¯æŒå¤šä¸ªç®—æ³•åŒæ—¶æ‰§è¡Œï¼ˆæœªæ¥æ‰©å±•ï¼‰
- âœ… **æ¶æ„ä¼˜åŒ–**: æ¸…æ™°çš„å¼‚æ­¥æ‰§è¡Œæ¨¡å¼

### 8.2 å·¥ä½œé‡ä¼°ç®—

| é˜¶æ®µ | å·¥ä½œé‡ | è¯´æ˜ |
|------|--------|------|
| Phase 1 | 0.5å¤© | è®¾è®¡å’Œæ–‡æ¡£ï¼ˆâœ… å·²å®Œæˆï¼‰ |
| Phase 2 | 1.5å¤© | å®ç°æ ¸å¿ƒç±» |
| Phase 3 | 1å¤© | ä¿®æ”¹ AlgorithmManager |
| Phase 4 | 1å¤© | é€‚é…ç®—æ³•æ¥å£ |
| Phase 5 | 0.5å¤© | é›†æˆåˆ° Coordinator |
| Phase 6 | 1å¤© | UIè¿›åº¦åé¦ˆ |
| Phase 7 | 1.5å¤© | æµ‹è¯•å’Œä¼˜åŒ– |
| **æ€»è®¡** | **7å¤©** | çº¦1.5å‘¨ |

### 8.3 ä¸‹ä¸€æ­¥è¡ŒåŠ¨

1. âœ… å®¡æŸ¥è®¾è®¡æ–‡æ¡£
2. å¼€å§‹ Phase 2ï¼šå®ç°æ ¸å¿ƒçº¿ç¨‹åŸºç¡€è®¾æ–½
3. ç¼–å†™å•å…ƒæµ‹è¯•æ¡†æ¶
4. å‡†å¤‡æ€§èƒ½æµ‹è¯•åŸºå‡†

---

## é™„å½•

### A. å‚è€ƒèµ„æ–™

- [Qt Threading Basics](https://doc.qt.io/qt-5/thread-basics.html)
- [QThread Documentation](https://doc.qt.io/qt-5/qthread.html)
- [Worker Object Pattern](https://doc.qt.io/qt-5/threads-technologies.html#worker-object)

### B. ä»£ç ç¤ºä¾‹

è¯¦è§å„é˜¶æ®µçš„ä»£ç ç‰‡æ®µã€‚

### C. æµ‹è¯•è®¡åˆ’

è¯¦è§ Phase 7ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.1 (ä¿®å¤ç‰ˆ) ğŸ”§
**åˆ›å»ºæ—¥æœŸ**: 2025-11-10
**æœ€åæ›´æ–°**: 2025-11-10
**ä½œè€…**: Claude
**çŠ¶æ€**: Phase 1 å®Œæˆ âœ…ï¼Œè®¾è®¡ç¼ºé™·å·²ä¿®å¤ âœ…

**æ›´æ–°æ—¥å¿—**:
- v1.1 (2025-11-10): ä¿®å¤5ä¸ªå…³é”®è®¾è®¡ç¼ºé™·ï¼ˆåŒé‡é‡Šæ”¾ã€é‡å¤æ‰§è¡Œã€ä»»åŠ¡ä¸¢å¤±ã€è¿›åº¦æŠ¥å‘Šã€å¹¶å‘è®¿é—®ï¼‰
- v1.0 (2025-11-10): åˆå§‹è®¾è®¡æ–¹æ¡ˆ
