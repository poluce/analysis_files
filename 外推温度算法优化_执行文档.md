# 外推温度算法优化 - 执行文档

## 文档信息

| 项目 | 内容 |
|------|------|
| **版本** | v1.0 |
| **日期** | 2025-11-20 |
| **分支** | `claude/switch-simple-code-01LGQUobtCjAiZqVoUcq1tQ5` |
| **基于** | `simple_code` |

---

## 1. 项目概述

### 1.1 目标

优化 TGA/DSC 分析中的"外推起始温度" (Extrapolated Onset Temperature) 算法，使其符合 **ISO 11358-1 / ASTM E2550** 标准，提高准确性和易用性。

### 1.2 核心改进

| 改进项 | 现状 | 优化后 |
|--------|------|--------|
| **切线确定** | 手动选择两点拟合 | 自动拐点检测 |
| **基线获取** | 强制先运行基线校正 | 混合策略（优先现有/降级局部拟合） |
| **交互方式** | 选择切线区域 | 选择反应特征区域 |
| **用户体验** | 流程中断，步骤繁琐 | 一次选择，自动计算 |

---

## 2. 技术设计

### 2.1 算法核心逻辑

#### 2.1.1 标准定义

**外推起始温度** = 外推基线 $L_{baseline}$ 与最大斜率切线 $L_{tangent}$ 的交点

#### 2.1.2 计算流程

```
输入: 用户选择的两个点 P₁(T₁, y₁) 和 P₂(T₂, y₂)
      其中 T₁ < T₂

步骤 1: 基线拟合 (Baseline Fitting)
        ├─ 优先: 搜索现有基线曲线 (SignalType::Baseline)
        └─ 降级: 取 T₁ 左侧数据进行线性拟合
        → 得到 L_baseline: y = a₁x + b₁

步骤 2: 拐点检测 (Inflection Point Detection)
        ├─ 在 [T₁, T₂] 范围内计算一阶微分 dy/dx
        └─ 找到 |dy/dx|_max 对应的点 P_inf
        → 得到拐点坐标 (T_inf, y_inf)

步骤 3: 切线计算 (Tangent Line Calculation)
        ├─ 斜率 k = dy/dx 在 P_inf 处的值
        └─ 截距 b = y_inf - k * T_inf
        → 得到 L_tangent: y = kx + b

步骤 4: 交点计算 (Intersection Calculation)
        ├─ 解方程: a₁x + b₁ = kx + b
        └─ x = (b - b₁) / (a₁ - k)
        → 得到外推温度 T_onset

输出: AlgorithmResult (Composite)
      ├─ Curves: 切线曲线, 基线延长线
      ├─ Markers: 外推点, 拐点
      └─ ScalarValue: T_onset
```

### 2.2 混合基线策略

```cpp
// 伪代码
ThermalCurve* findOrFitBaseline(ThermalCurve* sourceCurve, double T1) {
    // 策略 1: 搜索现有基线
    for (auto* child : sourceCurve->getChildren()) {
        if (child->signalType() == SignalType::Baseline) {
            if (child->coversTemperature(T1)) {
                return child;  // 使用现有基线
            }
        }
    }

    // 策略 2: 局部拟合
    // 取 T1 左侧一段数据 (如 10-20 个点)
    auto baselineData = extractDataBefore(sourceCurve, T1, pointCount);
    return fitLinearBaseline(baselineData);
}
```

### 2.3 交互设计

#### 2.3.1 两点选择语义

| 点 | 位置 | 用途 |
|----|------|------|
| **P₁ (左侧)** | 反应台阶开始前的平坦基线处 | 定义基线拟合区域 |
| **P₂ (右侧)** | 反应台阶结束后或反应变缓处 | 定义拐点搜索区域 |

#### 2.3.2 操作流程

```
1. 用户选择菜单: 算法 → 外推温度
2. 系统进入 Pick 模式 (十字光标)
3. 用户点击 P₁ (基线位置)
4. 用户点击 P₂ (反应区域结束)
5. 系统自动计算并显示结果
```

### 2.4 可视化输出

| 元素 | 类型 | 样式 | 说明 |
|------|------|------|------|
| **切线** | ThermalCurve | 虚线，红色 | 显示最大斜率切线 |
| **基线延长线** | ThermalCurve | 虚线，蓝色 | 显示外推基线 |
| **外推点** | Marker | 实心圆，标签 | "Onset: xxx.x°C" |
| **拐点** | Marker | 空心圆 | 最大斜率位置 |

---

## 3. 实现计划

### Phase 1: 探索现有代码结构 (预计 30 分钟)

#### 任务 1.1: 查找现有外推温度算法实现

**目标**: 定位现有算法代码，了解当前实现

**操作**:
```bash
# 搜索算法文件
grep -r "extrapolat" Analysis/src/
grep -r "onset" Analysis/src/
```

**关注点**:
- 算法类名和位置
- 现有参数定义
- 输出类型

#### 任务 1.2: 分析 AlgorithmResult 的 Composite 输出处理

**目标**: 了解混合结果如何被处理

**关键代码位置**:
- `Analysis/src/application/algorithm/algorithm_manager.cpp`
- 方法: `handleCompositeResult()`

**关注点**:
- Curves 如何添加到 CurveManager
- Markers 如何渲染
- ScalarValue 如何显示

#### 任务 1.3: 分析辅助曲线创建和父子关系机制

**目标**: 了解辅助曲线的生命周期管理

**关键属性**:
```cpp
// ThermalCurve 属性
bool isAuxiliaryCurve;   // 继承父曲线Y轴
bool isStronglyBound;    // 随父曲线隐藏
QString parentId;        // 父曲线ID
```

---

### Phase 2: 算法核心实现 (预计 2-3 小时)

#### 任务 2.1: 实现 fitInitialBaseline - 初始基线拟合

**位置**: `temperature_extrapolation_algorithm.cpp`

**函数签名**:
```cpp
struct LinearFit {
    double slope;      // 斜率 a
    double intercept;  // 截距 b
    double r2;         // R² 拟合优度
};

LinearFit fitInitialBaseline(
    const QVector<ThermalDataPoint>& data,
    double T_end,      // 拟合区域右边界
    int pointCount     // 使用的数据点数
);
```

**算法**: 最小二乘法线性回归
```cpp
// 计算均值
double sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
for (const auto& pt : baselinePoints) {
    sumX += pt.temperature;
    sumY += pt.value;
    sumXY += pt.temperature * pt.value;
    sumX2 += pt.temperature * pt.temperature;
}
int n = baselinePoints.size();
double slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
double intercept = (sumY - slope * sumX) / n;
```

#### 任务 2.2: 实现拐点检测 - 在范围内找最大斜率点

**位置**: `temperature_extrapolation_algorithm.cpp`

**函数签名**:
```cpp
struct InflectionPoint {
    int index;         // 数据点索引
    double temperature;
    double value;
    double slope;      // 该点的斜率
};

InflectionPoint detectInflectionPoint(
    const QVector<ThermalDataPoint>& data,
    double T_start,    // 搜索范围起点
    double T_end       // 搜索范围终点
);
```

**算法**: 中心差分法计算一阶微分
```cpp
// 在范围内计算每个点的斜率
double maxAbsSlope = 0;
int inflectionIndex = -1;

for (int i = startIdx + 1; i < endIdx; ++i) {
    // 中心差分
    double dx = data[i+1].temperature - data[i-1].temperature;
    double dy = data[i+1].value - data[i-1].value;
    double slope = dy / dx;

    if (qAbs(slope) > maxAbsSlope) {
        maxAbsSlope = qAbs(slope);
        inflectionIndex = i;
        // 保存斜率值（保留符号）
    }
}
```

#### 任务 2.3: 实现切线计算 - 在拐点处计算切线方程

**位置**: `temperature_extrapolation_algorithm.cpp`

**函数签名**:
```cpp
LinearFit calculateTangentLine(
    const InflectionPoint& inflection
);
```

**算法**:
```cpp
// 切线方程: y = kx + b
// 斜率 k = inflection.slope
// 截距 b = y_inf - k * T_inf
double k = inflection.slope;
double b = inflection.value - k * inflection.temperature;
return {k, b, 1.0};  // R² = 1.0 (精确)
```

#### 任务 2.4: 实现 calculateIntersection - 切线与基线交点

**位置**: `temperature_extrapolation_algorithm.cpp`

**函数签名**:
```cpp
QPointF calculateIntersection(
    const LinearFit& baseline,    // y = a₁x + b₁
    const LinearFit& tangent      // y = kx + b
);
```

**算法**:
```cpp
// 解方程: a₁x + b₁ = kx + b
// x = (b - b₁) / (a₁ - k)
double a1 = baseline.slope;
double b1 = baseline.intercept;
double k = tangent.slope;
double b = tangent.intercept;

// 检查平行
if (qAbs(a1 - k) < 1e-10) {
    return QPointF();  // 无交点
}

double x = (b - b1) / (a1 - k);
double y = a1 * x + b1;
return QPointF(x, y);
```

#### 任务 2.5: 实现混合基线策略 - 优先搜索现有基线

**位置**: `temperature_extrapolation_algorithm.cpp`

**函数签名**:
```cpp
LinearFit getBaseline(
    ThermalCurve* sourceCurve,
    CurveManager* curveManager,
    double T1,
    int fallbackPointCount
);
```

**算法**:
```cpp
// 1. 搜索现有基线曲线
auto childIds = curveManager->getChildCurveIds(sourceCurve->id());
for (const auto& childId : childIds) {
    auto* child = curveManager->getCurve(childId);
    if (child && child->signalType() == SignalType::Baseline) {
        // 检查范围覆盖
        auto range = child->getTemperatureRange();
        if (range.first <= T1 && range.second >= T1) {
            // 从基线曲线数据拟合
            return fitFromCurve(child, T1);
        }
    }
}

// 2. 降级: 局部拟合
return fitInitialBaseline(
    sourceCurve->getProcessedData(),
    T1,
    fallbackPointCount
);
```

---

### Phase 3: 重写 executeWithContext (预计 1-2 小时)

#### 任务 3.1: 获取用户选定范围并验证

**代码**:
```cpp
QVariant TemperatureExtrapolationAlgorithm::executeWithContext(
    AlgorithmContext* context
) {
    // 1. 验证上下文
    if (!context) {
        return QVariant::fromValue(
            AlgorithmResult::failure(name(), "Invalid context")
        );
    }

    // 2. 获取活动曲线
    auto curve = context->get<ThermalCurve*>("activeCurve");
    if (!curve.has_value() || !curve.value()) {
        return QVariant::fromValue(
            AlgorithmResult::failure(name(), "No active curve")
        );
    }

    // 3. 获取用户选点
    auto points = context->get<QVector<QPointF>>("selectedPoints");
    if (!points.has_value() || points.value().size() < 2) {
        return QVariant::fromValue(
            AlgorithmResult::failure(name(), "Need 2 points")
        );
    }

    QPointF p1 = points.value()[0];
    QPointF p2 = points.value()[1];

    // 确保 T1 < T2
    double T1 = qMin(p1.x(), p2.x());
    double T2 = qMax(p1.x(), p2.x());

    // 验证范围
    auto data = curve.value()->getProcessedData();
    if (data.isEmpty()) {
        return QVariant::fromValue(
            AlgorithmResult::failure(name(), "Empty curve data")
        );
    }

    // ... 继续执行
}
```

#### 任务 3.2: 组合基线拟合、拐点检测、切线计算流程

**代码**:
```cpp
    // 4. 基线拟合 (混合策略)
    auto curveManager = context->get<CurveManager*>("curveManager");
    LinearFit baseline = getBaseline(
        curve.value(),
        curveManager.value_or(nullptr),
        T1,
        20  // fallback 使用 20 个点
    );

    // 5. 拐点检测
    InflectionPoint inflection = detectInflectionPoint(data, T1, T2);
    if (inflection.index < 0) {
        return QVariant::fromValue(
            AlgorithmResult::failure(name(), "No inflection point found")
        );
    }

    // 6. 切线计算
    LinearFit tangent = calculateTangentLine(inflection);

    // 7. 交点计算
    QPointF onsetPoint = calculateIntersection(baseline, tangent);
    if (onsetPoint.isNull()) {
        return QVariant::fromValue(
            AlgorithmResult::failure(name(), "Parallel lines - no intersection")
        );
    }

    double T_onset = onsetPoint.x();
```

#### 任务 3.3: 构建 AlgorithmResult 输出 (曲线+标记点)

**代码**:
```cpp
    // 8. 构建结果
    AlgorithmResult result = AlgorithmResult::success(
        name(),
        curve.value()->id(),
        ResultType::Composite
    );

    // 8.1 添加切线曲线
    auto tangentCurve = createTangentCurve(
        curve.value(),
        tangent,
        T1, T2
    );
    result.addCurve(tangentCurve);

    // 8.2 添加基线延长线
    auto baselineCurve = createBaselineExtensionCurve(
        curve.value(),
        baseline,
        T1, T_onset
    );
    result.addCurve(baselineCurve);

    // 8.3 添加外推点 Marker
    result.addMarker(
        onsetPoint,
        QString("Onset: %1°C").arg(T_onset, 0, 'f', 1)
    );

    // 8.4 添加拐点 Marker
    result.addMarker(
        QPointF(inflection.temperature, inflection.value),
        "Inflection"
    );

    // 8.5 设置数值结果
    result.setMeta("onset_temperature", T_onset);
    result.setMeta("inflection_temperature", inflection.temperature);
    result.setMeta("inflection_slope", inflection.slope);

    return QVariant::fromValue(result);
```

---

### Phase 4: 辅助曲线创建 (预计 1 小时)

#### 任务 4.1: 创建切线 ThermalCurve

**函数**:
```cpp
ThermalCurve* TemperatureExtrapolationAlgorithm::createTangentCurve(
    ThermalCurve* parent,
    const LinearFit& tangent,
    double T_start,
    double T_end
) {
    // 生成切线数据点
    QVector<ThermalDataPoint> tangentData;
    int numPoints = 100;
    double step = (T_end - T_start) / (numPoints - 1);

    for (int i = 0; i < numPoints; ++i) {
        double T = T_start + i * step;
        double y = tangent.slope * T + tangent.intercept;

        ThermalDataPoint pt;
        pt.temperature = T;
        pt.time = 0;  // 切线无时间信息
        pt.value = y;
        tangentData.append(pt);
    }

    // 创建曲线
    auto* curve = new ThermalCurve();
    curve->setName(parent->name() + " - Tangent");
    curve->setInstrumentType(parent->instrumentType());
    curve->setSignalType(SignalType::Raw);  // 或新增类型
    curve->setRawData(tangentData);
    curve->setProcessedData(tangentData);

    // 设置辅助曲线属性
    curve->setIsAuxiliaryCurve(true);
    curve->setIsStronglyBound(true);
    curve->setParentId(parent->id());

    // 设置样式 (虚线，红色)
    curve->setPlotStyle(PlotStyle::Line);
    curve->setColor(QColor(255, 0, 0));  // 红色
    curve->setLineStyle(Qt::DashLine);   // 虚线

    return curve;
}
```

#### 任务 4.2: 创建基线延长线 ThermalCurve

**函数**:
```cpp
ThermalCurve* TemperatureExtrapolationAlgorithm::createBaselineExtensionCurve(
    ThermalCurve* parent,
    const LinearFit& baseline,
    double T_start,
    double T_end
) {
    // 生成基线延长线数据点
    QVector<ThermalDataPoint> baselineData;
    int numPoints = 100;
    double step = (T_end - T_start) / (numPoints - 1);

    for (int i = 0; i < numPoints; ++i) {
        double T = T_start + i * step;
        double y = baseline.slope * T + baseline.intercept;

        ThermalDataPoint pt;
        pt.temperature = T;
        pt.time = 0;
        pt.value = y;
        baselineData.append(pt);
    }

    // 创建曲线
    auto* curve = new ThermalCurve();
    curve->setName(parent->name() + " - Baseline Ext");
    curve->setInstrumentType(parent->instrumentType());
    curve->setSignalType(SignalType::Baseline);
    curve->setRawData(baselineData);
    curve->setProcessedData(baselineData);

    // 设置辅助曲线属性
    curve->setIsAuxiliaryCurve(true);
    curve->setIsStronglyBound(true);
    curve->setParentId(parent->id());

    // 设置样式 (虚线，蓝色)
    curve->setPlotStyle(PlotStyle::Line);
    curve->setColor(QColor(0, 0, 255));  // 蓝色
    curve->setLineStyle(Qt::DashLine);   // 虚线

    return curve;
}
```

#### 任务 4.3: 添加外推点和拐点 Marker 到结果

已在 Phase 3 任务 3.3 中完成。

---

### Phase 5: 集成和测试 (预计 30 分钟)

#### 任务 5.1: 验证 handleCompositeResult 处理混合输出

**检查点**:
- [ ] Curves 正确添加到 CurveManager
- [ ] 父子关系正确设置
- [ ] Markers 正确渲染到图表
- [ ] 辅助曲线随父曲线显示/隐藏
- [ ] 级联删除正常工作

**测试代码位置**:
`algorithm_manager.cpp` - `handleCompositeResult()`

#### 任务 5.2: 提交代码并推送

**Git 操作**:
```bash
# 查看修改
git status
git diff

# 提交
git add -A
git commit -m "feat: 优化外推温度算法 - 自动拐点检测和混合基线策略

- 实现自动拐点检测 (最大斜率点)
- 实现混合基线策略 (优先现有/降级局部拟合)
- 重写 executeWithContext 整合算法流程
- 添加辅助曲线 (切线、基线延长线)
- 添加 Markers (外推点、拐点)

符合 ISO 11358-1 / ASTM E2550 标准"

# 推送
git push -u origin claude/switch-simple-code-01LGQUobtCjAiZqVoUcq1tQ5
```

---

## 4. 文件修改清单

| 文件 | 操作 | 说明 |
|------|------|------|
| `temperature_extrapolation_algorithm.h` | MODIFY | 添加辅助函数声明 |
| `temperature_extrapolation_algorithm.cpp` | MODIFY | 重写核心算法 |
| `algorithm_manager.cpp` | VERIFY | 验证 handleCompositeResult |
| `thermal_chart.h/cpp` | NO CHANGE | 现有机制已支持 |
| `chart_view.h/cpp` | NO CHANGE | 现有机制已支持 |

---

## 5. 测试计划

### 5.1 单元测试

| 测试项 | 输入 | 预期输出 |
|--------|------|----------|
| 基线拟合 | 线性数据 | 正确的斜率和截距 |
| 拐点检测 | S型曲线 | 中点位置 |
| 切线计算 | 拐点坐标 | 正确的切线方程 |
| 交点计算 | 两条直线 | 正确的交点坐标 |
| 平行线检测 | 平行直线 | 返回空点 |

### 5.2 集成测试

| 测试场景 | 操作 | 预期结果 |
|----------|------|----------|
| 正常流程 | 选择两点 → 执行 | 显示切线、基线、标记点 |
| 有现有基线 | 先做基线校正 → 外推 | 使用现有基线 |
| 无现有基线 | 直接外推 | 局部拟合基线 |
| 取消操作 | 选择一点后取消 | 恢复正常状态 |

### 5.3 边界测试

| 测试场景 | 预期行为 |
|----------|----------|
| 选择范围太小 | 错误提示 |
| 选择范围无拐点 | 错误提示 |
| 数据点太少 | 错误提示 |

---

## 6. 风险评估

| 风险 | 可能性 | 影响 | 缓解措施 |
|------|--------|------|----------|
| 微分噪声放大 | 中 | 拐点检测不准确 | 使用平滑微分或局部多项式拟合 |
| 基线搜索范围不匹配 | 低 | 找不到现有基线 | 降级策略已设计 |
| 辅助曲线显示混乱 | 低 | 图表难以阅读 | isStronglyBound 确保随父曲线隐藏 |
| 计算精度问题 | 低 | 交点计算错误 | 添加平行线检测 |

---

## 7. 预计工作量

| Phase | 任务数 | 预计时间 | 复杂度 |
|-------|--------|----------|--------|
| Phase 1 | 3 | 30 分钟 | 低 |
| Phase 2 | 5 | 2-3 小时 | 高 |
| Phase 3 | 3 | 1-2 小时 | 中 |
| Phase 4 | 3 | 1 小时 | 中 |
| Phase 5 | 2 | 30 分钟 | 低 |
| **总计** | **16** | **5-7 小时** | - |

---

## 8. 验收标准

### 8.1 功能验收

- [ ] 用户选择两点后自动计算外推温度
- [ ] 切线和基线延长线正确显示
- [ ] 外推点和拐点 Marker 正确标注
- [ ] 辅助曲线随父曲线显示/隐藏
- [ ] 级联删除正常工作
- [ ] 支持撤销/重做

### 8.2 性能验收

- [ ] 1000 点数据计算时间 < 100ms
- [ ] 无内存泄漏

### 8.3 兼容性验收

- [ ] TGA 数据正常工作
- [ ] DSC 数据正常工作
- [ ] 与现有基线校正功能兼容

---

## 9. 参考资料

- ISO 11358-1:2022 - Plastics -- Thermogravimetry (TG) of polymers
- ASTM E2550 - Standard Test Method for Thermal Stability by Thermogravimetry
- 项目文档: `CLAUDE.md` - 架构设计和编码约定
- 设计文档: `新设计文档/统一输出算法_AlgorithmResult设计.md`

---

## 10. 修订历史

| 版本 | 日期 | 作者 | 说明 |
|------|------|------|------|
| v1.0 | 2025-11-20 | Claude | 初始版本 |
