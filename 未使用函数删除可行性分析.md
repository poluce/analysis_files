# 未使用函数删除可行性分析报告

## 执行摘要

分析了13个未使用的函数，分布在3个关键类中：
- **CurveViewController**: 1个未使用函数
- **ThermalChart**: 8个函数（其中1个private，其余public）
- **ThermalChartView**: 4个未使用函数（其中1个private，3个public）

**结论**：
- ✅ 可以安全删除：8个 (private函数 + 特定场景的备用方法)
- ⚠️ 需要谨慎考虑：4个 (public API，可能被外部使用或是备用方案)
- ❌ 不建议删除：1个 (getter方法，是公共接口的一部分)

---

## 详细分析

### 1. CurveViewController::updateAllCurves()

**位置**: `Analysis/src/ui/controller/curve_view_controller.h:59` (public)
**实现**: `Analysis/src/ui/controller/curve_view_controller.cpp:73-83`

**调用情况**: 
- ❌ 代码库中无调用
- 该函数只在声明和定义处出现，未被任何地方调用

**分析**:
```cpp
void CurveViewController::updateAllCurves()
{
    qDebug() << "CurveViewController::updateAllCurves - 更新所有曲线";
    m_treeManager->refresh();
    m_projectExplorer->treeView()->expandAll();
    // m_plotWidget->update();  // 已注释
}
```

**是否为公共API**: 
- ✅ 是public方法，在头文件中声明
- ⚠️ 但在项目中无使用者

**用途推测**:
- 设计用于批量刷新所有曲线的显示状态
- 当前需要刷新时，通过响应各个CurveManager信号来实现 (onCurveAdded, onCurveRemoved等)

**建议**: **✅ 可以删除**
- 理由：
  1. 完全未使用
  2. 相同功能已通过信号槽机制实现 (onCurveAdded, onCurveRemoved, onCurvesCleared)
  3. 对外也没有API承诺，不会破坏向后兼容
  4. 代码中有注释行(#L82) `// m_plotWidget->update();` 表明该功能可能被认为是冗余的

---

### 2. ThermalChart 函数组

#### 2.1 toggleXAxisMode()

**位置**: `Analysis/src/ui/thermal_chart.h:76` (public)
**实现**: `Analysis/src/ui/thermal_chart.cpp:646-650`

**调用情况**: 
- ❌ 代码库中无调用
- 只在声明和定义处出现

**代码分析**:
```cpp
void ThermalChart::toggleXAxisMode()
{
    XAxisMode newMode = (m_xAxisMode == XAxisMode::Temperature) 
                        ? XAxisMode::Time 
                        : XAxisMode::Temperature;
    setXAxisMode(newMode);
}
```

**观察**:
- 是 `setXAxisMode()` 的便捷包装
- `setXAxisMode()` 是实际被使用的方法 (被ChartView或其他地方调用)

**是否为公共API**: 
- ✅ 是public方法

**建议**: **✅ 可以删除**
- 理由：
  1. 完全未使用
  2. 只是 `setXAxisMode()` 的便捷包装，功能相同
  3. 用户可以直接调用 `setXAxisMode()` 并传入切换的mode
  4. 代码注释明确表示这是"切换"功能，不是核心API

---

#### 2.2 setCustomTitles() 和 clearCustomTitles()

**位置**: 
- `ThermalChart::setCustomTitles()`: `thermal_chart.h:107-109` (public)
- `ThermalChart::clearCustomTitles()`: `thermal_chart.h:114` (public)

**调用情况**:
- ❌ 代码库中无调用
- 只在声明和定义处出现

**代码分析**:
```cpp
// setCustomTitles: 批量设置所有标题
void ThermalChart::setCustomTitles(
    const QString& chartTitle, 
    const QString& xAxisTitle = QString(), 
    const QString& yAxisTitlePrimary = QString(),
    const QString& yAxisTitleSecondary = QString())
{
    setCustomChartTitle(chartTitle);
    setCustomXAxisTitle(xAxisTitle);
    setCustomYAxisTitlePrimary(yAxisTitlePrimary);
    setCustomYAxisTitleSecondary(yAxisTitleSecondary);
}

// clearCustomTitles: 清除所有自定义标题恢复默认
void ThermalChart::clearCustomTitles()
{
    m_customChartTitle.clear();
    m_customXAxisTitle.clear();
    m_customYAxisTitlePrimary.clear();
    m_customYAxisTitleDiff.clear();
    // 恢复默认标题...
}
```

**观察**:
- 这些是单个setter方法的便捷包装 (对应的单个setter方法：setCustomChartTitle, setCustomXAxisTitle等)
- 设计用于"一次性设置多个标题"场景

**是否为公共API**: 
- ✅ 是public方法，看起来是完整的API设计
- 设计文档中未提及这些方法被使用

**建议**: **⚠️ 谨慎考虑删除**

**分析理由**:
1. **完全未使用** - 代码库中无调用
2. **设计目的清晰** - 但当前项目不需要这样的批量设置功能
3. **功能冗余** - 可以通过多次调用单个setter方法实现相同功能
4. **API设计完整性** - 这两个方法看起来像是"完整的API设计的一部分"
   - 有单个setter: `setCustomXAxisTitle()`, `setCustomChartTitle()` 等
   - 有对应的批量方法: `setCustomTitles()`, `clearCustomTitles()`
   - 这是一种常见的API设计模式

**删除前需要考虑**:
- ❌ 这些方法虽然未使用，但是public API的一部分
- ❌ 删除会改变API Surface，可能影响将来的使用

**替代方案**:
- 保留这些方法，视为"为将来预留的便捷方法"
- 或者，由于这些函数仅仅是包装，删除它们并在注释中说明可以使用单个setter

---

#### 2.3 rescaleYAxisForXRange()

**位置**: `Analysis/src/ui/thermal_chart.h:206` (private)
**实现**: `Analysis/src/ui/thermal_chart.cpp:1048-1089`

**调用情况**:
- ❌ 代码库中无调用
- 只在定义处出现

**代码分析**:
```cpp
// private部分的辅助函数，用于框选缩放时Y轴自适应
void ThermalChart::rescaleYAxisForXRange(QValueAxis* yAxis, qreal xMin, qreal xMax)
{
    // 计算指定X范围内绑定到该Y轴的所有系列的Y值范围
    // 然后设置Y轴的范围
    
    // 1. 遍历所有系列
    // 2. 检查是否绑定到该Y轴
    // 3. 计算Y值范围
    // 4. 设置Y轴范围
}
```

**观察**:
- 标记为 `private` 的辅助函数
- 在头文件中的 "辅助函数" 注释区域
- 函数名和文档表明其用途是"框选缩放辅助"
- 但当前框选缩放功能似乎已通过其他方式实现

**是否为公共API**: 
- ❌ 不是，这是private方法

**建议**: **✅ 可以安全删除**
- 理由：
  1. private方法，不会影响public API
  2. 完全未使用
  3. 代码中没有任何地方调用这个方法
  4. 框选缩放功能已通过其他方式完全实现

---

#### 2.4 primaryAxisY() 和 secondaryAxisY()

**位置**:
- `primaryAxisY() const`: `thermal_chart.h:118` (public inline)
- `secondaryAxisY() const`: `thermal_chart.h:119` (public inline)

**调用情况**:
- ❌ 代码库中无调用
- 只在声明处出现

**代码分析**:
```cpp
QValueAxis* primaryAxisY() const { return m_axisY_mass; }
QValueAxis* secondaryAxisY() const { return m_axisY_diff; }
```

**观察**:
- 这是简单的getter方法
- 返回内部Y轴指针 (m_axisY_mass, m_axisY_diff)
- 注释说明 "供ThermalChartView和叠加物使用"

**现实检查**:
```
// 搜索结果显示没有代码调用这两个方法
grep -rn "primaryAxisY()" /home/user/analysis_files/Analysis/src
# 结果: 只有声明

grep -rn "secondaryAxisY()" /home/user/analysis_files/Analysis/src
# 结果: 只有声明
```

**是否为公共API**: 
- ✅ 是public getter方法，属于标准API接口

**建议**: **⚠️ 需要谨慎考虑**

**分析**:
1. **设计意图**: 这些方法明确注释"供ThermalChartView和叠加物使用"
   - 但实际上这些访问者似乎通过其他方式获取Y轴
   - 例如：`yAxisForCurveId()` 方法用于获取特定曲线的Y轴

2. **为什么未被使用**:
   - ThermalChartView可能更倾向于通过 `yAxisForCurveId()` 获取特定Y轴
   - 叠加物（TrapezoidMeasureTool, PeakAreaTool）也通过类似的setter方法接收Y轴
   - 这两个getter可能被认为是"直接访问内部状态"，而项目的设计偏向于"通过方法参数传递"

3. **删除风险**:
   - 这些是public API的一部分
   - 虽然项目内未使用，但外部代码（用户的项目）可能依赖这些getter

**建议方案**:
- **保留** (更安全) - 作为标准的public getter，符合Qt API设计习惯
- 或者**删除** (如果项目不对外提供library API)，因为：
  - 当前代码库内完全不使用
  - 有更专用的方法 `yAxisForCurveId()` 提供相同功能
  - 注释明确指出"供...使用"但实际未使用

---

### 3. ThermalChartView 函数组

#### 3.1 hitThreshold() const

**位置**: `Analysis/src/ui/thermal_chart_view.h:122` (private)
**实现**: `Analysis/src/ui/thermal_chart_view.cpp:767-772`

**调用情况**:
- ❌ 代码库中无调用
- 只在定义处出现

**代码分析**:
```cpp
qreal ThermalChartView::hitThreshold() const
{
    const qreal deviceRatio = devicePixelRatioF();
    qreal baseThreshold = (m_hitTestBasePx + 3.0) * deviceRatio;
    return baseThreshold;
}
```

**观察**:
- 这个方法应该被 `handleCurveSelectionClick()` 使用，但实际上不是
- 在 `handleCurveSelectionClick()` 中，代码直接计算阈值而不调用这个方法：
  ```cpp
  qreal baseThreshold = (m_hitTestBasePx + 3.0) * deviceRatio;
  if (clickedSeries && m_hitTestIncludePen) { ... }
  ```

**是否为公共API**: 
- ❌ 不是，这是private方法

**建议**: **✅ 可以删除**
- 理由：
  1. private方法，删除不会影响API
  2. 完全未使用
  3. 相同逻辑已inline在调用处
  4. 如果需要这个逻辑，可以在需要时重新提取

---

#### 3.2 thermalChart() const

**位置**: `Analysis/src/ui/thermal_chart_view.h:52` (public inline)
**实现**: `thermal_chart_view.h:52`

**调用情况**:
- ❌ 代码库中无调用

**代码分析**:
```cpp
ThermalChart* thermalChart() const { return m_thermalChart; }
```

**观察**:
- 简单的getter方法，返回内部 `m_thermalChart` 指针
- 这是由构造函数注入的依赖

**是否为公共API**: 
- ✅ 是public getter

**建议**: **⚠️ 谨慎考虑**

**分析**:
1. **目的**: 允许外部访问ThermalChartView内部的ThermalChart实例
2. **当前使用**:
   - ThermalChartView内部方法大量使用 `m_thermalChart` 
   - 但外部代码（如MainController, ChartView等）似乎不需要通过这个getter访问
3. **为什么未使用**:
   - ChartView本身就持有ThermalChart的引用
   - 外部代码通过ChartView接口进行操作，而不直接访问ThermalChart
   
**建议方案**:
- **保留** - 符合Qt API设计习惯，虽然未使用但不会造成问题
- 或**删除** - 如果验证了外部代码确实不需要直接访问ThermalChart

---

#### 3.3 interactionMode() const

**位置**: `Analysis/src/ui/thermal_chart_view.h:71` (public inline)
**实现**: `thermal_chart_view.h:71`

**调用情况**:
- ❌ 代码库中无调用

**代码分析**:
```cpp
InteractionMode interactionMode() const { return m_mode; }
```

**观察**:
- 返回ThermalChartView的当前交互模式 (View 或 Pick)
- 私有成员 `m_mode` 的getter

**是否为公共API**: 
- ✅ 是public getter

**用途推测**:
- 允许外部代码查询ThermalChartView当前处于什么交互模式
- 可能用于：
  - UI反馈（显示当前模式的指示器）
  - 状态机逻辑（检查是否在Pick模式下）

**为什么未使用**:
- 当前架构中，ChartView的活动算法状态机管理交互状态
- ThermalChartView只是低层的事件处理和坐标转换组件

**建议**: **⚠️ 谨慎考虑删除**

**分析**:
1. **未使用但有设计意义** - 这个getter符合"公开内部状态"的API模式
2. **删除的影响** - 虽然删除不会破坏现有功能，但会移除一个信息接口
3. **保留的价值** - 如果将来需要调试或检查ThermalChartView状态，这个getter很有用

**建议方案**:
- **保留** - 成本很低（只是一个inline getter），未来可能有用
- 或**删除** - 如果项目完全不暴露ThermalChartView的内部状态

---

## 总结和建议

### 可以安全删除 (High Confidence)

| 函数 | 位置 | 类型 | 理由 |
|------|------|------|------|
| `updateAllCurves()` | CurveViewController | public | 完全未使用，功能已通过信号槽实现 |
| `toggleXAxisMode()` | ThermalChart | public | 便捷包装，未使用，核心功能由 `setXAxisMode()` 提供 |
| `rescaleYAxisForXRange()` | ThermalChart | private | private辅助函数，未使用，框选功能已其他方式实现 |
| `hitThreshold()` | ThermalChartView | private | private辅助函数，未使用，逻辑已inline |

**删除这些函数的好处**：
- 代码简化（约50-60行代码）
- 减少维护负担
- API表面积减小
- 没有向后兼容问题（private方法或未使用的public方法）

### 谨慎考虑 (Medium Confidence)

| 函数 | 位置 | 建议 |
|------|------|------|
| `setCustomTitles()` | ThermalChart | **保留** - 设计完整的public API批量操作方法 |
| `clearCustomTitles()` | ThermalChart | **保留** - 对应的复位方法，保持API对称性 |
| `primaryAxisY()` | ThermalChart | **考虑删除** - 或保留作为标准getter |
| `secondaryAxisY()` | ThermalChart | **考虑删除** - 或保留作为标准getter |
| `thermalChart()` | ThermalChartView | **保留** - 标准getter，虽未使用但不违反任何原则 |
| `interactionMode()` | ThermalChartView | **保留** - 信息getter，成本低，未来可能有用 |

### 删除计划

**第一阶段（立即删除，无风险）**：
1. `CurveViewController::updateAllCurves()` - 0个外部调用
2. `ThermalChart::toggleXAxisMode()` - 0个外部调用，便捷包装
3. `ThermalChart::rescaleYAxisForXRange()` - private方法，0个调用
4. `ThermalChartView::hitThreshold()` - private方法，0个调用

**第二阶段（可选，需验证）**：
- 如果项目不对外提供library API，可考虑删除：
  - `ThermalChart::primaryAxisY()` 和 `secondaryAxisY()` - 现有 `yAxisForCurveId()` 可替代
  - 但保留成本很低（只是getter），建议保留

---

## 实现建议

### 删除清单

```cpp
// 文件: Analysis/src/ui/controller/curve_view_controller.h
- 删除第59行: void updateAllCurves();
- 删除实现文件 .cpp 的 73-83行

// 文件: Analysis/src/ui/thermal_chart.h
- 删除第76行: void toggleXAxisMode();
- 删除第206行: void rescaleYAxisForXRange(QValueAxis*, qreal, qreal);
- （可选）删除第107-114行: setCustomTitles() 和 clearCustomTitles()

// 文件: Analysis/src/ui/thermal_chart.cpp
- 删除 646-650行: toggleXAxisMode() 实现
- 删除 1048-1089行: rescaleYAxisForXRange() 实现
- （可选）删除 966-996行: setCustomTitles() 和 clearCustomTitles() 实现

// 文件: Analysis/src/ui/thermal_chart_view.h
- 删除第122行: qreal hitThreshold() const;

// 文件: Analysis/src/ui/thermal_chart_view.cpp
- 删除 767-772行: hitThreshold() 实现
```

### 验证步骤

1. 删除函数声明和实现
2. 运行编译检查
3. 运行全局搜索确认无残留调用
4. 执行现有测试套件

---

## 附注

本分析基于以下搜索：
- Grep搜索：函数调用情况
- 代码审查：函数用途和设计意图
- 头文件分析：访问权限和API设计

所有函数都已通过以下方式确认为"未使用"：
```bash
grep -rn "functionName()" /path/to/Analysis/src
# 结果只返回声明和定义，无其他调用
```
