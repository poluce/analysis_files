# 信号流向架构设计说明

## 📋 目录
- [核心概念](#核心概念)
- [两种信号路径](#两种信号路径)
- [完整代码示例](#完整代码示例)
- [最佳实践](#最佳实践)
- [常见错误](#常见错误)

---

## 核心概念

### 🎯 设计原则

在 DSC/TGA 热分析软件的四层架构中，信号流向遵循以下核心原则：

1. **命令向下走 Controller**（写操作）
   - 用户操作 → UI 发信号 → Controller 协调 → Service 执行

2. **通知向上可直连**（读操作）
   - Service 发信号 → UI 监听 → 更新显示

---

## 两种信号路径

### 🔽 路径1: 命令路径（向下）

```
用户点击按钮
    ↓
ToolPanel::emit algorithmApplyRequested(name, params)
    ↓
MainController::handleAlgorithmApply(name, params)
    ├─ 业务规则检查（曲线是否存在？）
    ├─ 创建 Command 对象（支持撤销）
    ├─ 调用 HistoryManager::execute(cmd)
    └─ 记录日志、更新状态
        ↓
    AlgorithmCommand::execute()
        ├─ 调用 AlgorithmService::getAlgorithm()
        ├─ 执行 algorithm->process(data)
        └─ 更新 CurveManager 数据
```

**适用场景:**
- ✅ 所有修改数据的操作
- ✅ 需要撤销/重做的操作
- ✅ 需要协调多个 Service 的操作
- ✅ 需要权限检查、日志记录的操作

---

### 🔼 路径2: 通知路径（向上）

```
算法执行完成
    ↓
AlgorithmService::emit algorithmFinished(name, result)
    ↓
ToolPanel::onAlgorithmFinished(name, result)  ← 直接监听
    └─ 更新结果表格（纯 UI 更新）

CurveManager::emit curveDataChanged(curveId)
    ↓
ChartView::onCurveDataChanged(curveId)  ← 直接监听
    └─ 重绘图表
```

**适用场景:**
- ✅ 只读的 UI 更新（显示结果、进度条）
- ✅ 实时状态同步（曲线数据变化后刷新图表）
- ✅ 不涉及业务逻辑的通知

---

## 完整代码示例

### 1. ToolPanel 实现

```cpp
// ToolPanel.h
#ifndef TOOLPANEL_H
#define TOOLPANEL_H

#include <QDockWidget>
#include <QComboBox>
#include <QPushButton>
#include <QTableWidget>
#include <QFormLayout>
#include <QProgressBar>
#include <QVariantMap>

class ToolPanel : public QDockWidget {
    Q_OBJECT

public:
    explicit ToolPanel(QWidget* parent = nullptr);

    // UI 更新方法（被动接收）
    void showAlgorithmParams(const QString& algoName);
    void displayResults(const QVariantMap& result);

signals:
    // ===== 命令信号（发送给 Controller）=====
    void algorithmApplyRequested(QString name, QVariantMap params);
    void parameterChanged(QString name, QVariant value);

private slots:
    // ===== 通知槽函数（监听 Service）=====
    void onAlgorithmStarted(QString name);
    void onAlgorithmFinished(QString name, QVariantMap result);
    void onAlgorithmProgress(int percent);
    void onCurveDataChanged(QString curveId);

    // UI 控件槽函数
    void onApplyButtonClicked();

private:
    void setupUI();
    void setupConnections();
    QVariantMap collectParameters();

    // UI 成员
    QComboBox* m_algoComboBox;
    QPushButton* m_applyButton;
    QTableWidget* m_resultTable;
    QProgressBar* m_progressBar;
    QFormLayout* m_paramLayout;

    // 参数输入控件容器
    QMap<QString, QWidget*> m_paramWidgets;
};

#endif // TOOLPANEL_H
```

```cpp
// ToolPanel.cpp
#include "ToolPanel.h"
#include "AlgorithmService.h"
#include "CurveManager.h"
#include <QVBoxLayout>
#include <QLabel>
#include <QSpinBox>
#include <QDoubleSpinBox>

ToolPanel::ToolPanel(QWidget* parent)
    : QDockWidget("算法工具", parent)
{
    setupUI();
    setupConnections();
}

void ToolPanel::setupUI() {
    auto* widget = new QWidget(this);
    auto* layout = new QVBoxLayout(widget);

    // 算法选择
    layout->addWidget(new QLabel("选择算法:"));
    m_algoComboBox = new QComboBox();
    m_algoComboBox->addItems({"基线校正", "平滑处理", "峰检测", "动力学分析"});
    layout->addWidget(m_algoComboBox);

    // 参数区域
    m_paramLayout = new QFormLayout();
    layout->addLayout(m_paramLayout);

    // 应用按钮
    m_applyButton = new QPushButton("应用");
    layout->addWidget(m_applyButton);

    // 进度条
    m_progressBar = new QProgressBar();
    m_progressBar->setVisible(false);
    layout->addWidget(m_progressBar);

    // 结果表格
    layout->addWidget(new QLabel("结果:"));
    m_resultTable = new QTableWidget();
    m_resultTable->setColumnCount(2);
    m_resultTable->setHorizontalHeaderLabels({"参数", "值"});
    layout->addWidget(m_resultTable);

    layout->addStretch();
    setWidget(widget);
}

void ToolPanel::setupConnections() {
    // ========== 监听 Service 信号（通知路径）==========
    connect(AlgorithmService::instance(),
            &AlgorithmService::algorithmStarted,
            this, &ToolPanel::onAlgorithmStarted);

    connect(AlgorithmService::instance(),
            &AlgorithmService::algorithmFinished,
            this, &ToolPanel::onAlgorithmFinished);

    connect(AlgorithmService::instance(),
            &AlgorithmService::algorithmProgress,
            this, &ToolPanel::onAlgorithmProgress);

    // 监听 CurveManager
    connect(CurveManager::instance(),
            &CurveManager::curveDataChanged,
            this, &ToolPanel::onCurveDataChanged);

    // ========== UI 控件信号（发送命令）==========
    connect(m_applyButton, &QPushButton::clicked,
            this, &ToolPanel::onApplyButtonClicked);

    connect(m_algoComboBox, QOverload<int>::of(&QComboBox::currentIndexChanged),
            this, [this](int index) {
        QString algoName = m_algoComboBox->currentText();
        showAlgorithmParams(algoName);
    });
}

// ========== 命令发送方法 ==========
void ToolPanel::onApplyButtonClicked() {
    QString algoName = m_algoComboBox->currentText();
    QVariantMap params = collectParameters();

    // ✅ 正确：发送信号给 Controller，不直接调用 Service
    emit algorithmApplyRequested(algoName, params);

    // ❌ 错误：不要这样做
    // AlgorithmService::instance()->executeAsync(algoName, data, params);
}

QVariantMap ToolPanel::collectParameters() {
    QVariantMap params;
    for (auto it = m_paramWidgets.begin(); it != m_paramWidgets.end(); ++it) {
        QString paramName = it.key();
        QWidget* widget = it.value();

        if (auto* spinBox = qobject_cast<QSpinBox*>(widget)) {
            params[paramName] = spinBox->value();
        } else if (auto* doubleSpinBox = qobject_cast<QDoubleSpinBox*>(widget)) {
            params[paramName] = doubleSpinBox->value();
        }
        // ... 其他控件类型
    }
    return params;
}

// ========== 通知接收方法（只读更新）==========
void ToolPanel::onAlgorithmStarted(QString name) {
    m_applyButton->setEnabled(false);
    m_progressBar->setVisible(true);
    m_progressBar->setValue(0);
}

void ToolPanel::onAlgorithmFinished(QString name, QVariantMap result) {
    m_applyButton->setEnabled(true);
    m_progressBar->setVisible(false);

    // 纯 UI 更新，不涉及业务逻辑
    displayResults(result);
}

void ToolPanel::displayResults(const QVariantMap& result) {
    m_resultTable->setRowCount(0);

    for (auto it = result.begin(); it != result.end(); ++it) {
        int row = m_resultTable->rowCount();
        m_resultTable->insertRow(row);
        m_resultTable->setItem(row, 0, new QTableWidgetItem(it.key()));
        m_resultTable->setItem(row, 1,
            new QTableWidgetItem(it.value().toString()));
    }
}

void ToolPanel::onAlgorithmProgress(int percent) {
    m_progressBar->setValue(percent);
}

void ToolPanel::onCurveDataChanged(QString curveId) {
    // 如果结果表格显示的是当前曲线的数据，可能需要清空
    // 这是纯 UI 逻辑
}

void ToolPanel::showAlgorithmParams(const QString& algoName) {
    // 清空当前参数
    QLayoutItem* item;
    while ((item = m_paramLayout->takeAt(0)) != nullptr) {
        delete item->widget();
        delete item;
    }
    m_paramWidgets.clear();

    // 根据算法类型显示不同参数（示例）
    if (algoName == "基线校正") {
        auto* degreeSpinBox = new QSpinBox();
        degreeSpinBox->setRange(1, 10);
        degreeSpinBox->setValue(3);
        m_paramLayout->addRow("多项式阶数:", degreeSpinBox);
        m_paramWidgets["degree"] = degreeSpinBox;

    } else if (algoName == "平滑处理") {
        auto* windowSpinBox = new QSpinBox();
        windowSpinBox->setRange(3, 51);
        windowSpinBox->setValue(5);
        m_paramLayout->addRow("窗口大小:", windowSpinBox);
        m_paramWidgets["windowSize"] = windowSpinBox;
    }
    // ... 其他算法参数
}
```

---

### 2. MainController 实现

```cpp
// MainController.h
#ifndef MAINCONTROLLER_H
#define MAINCONTROLLER_H

#include <QObject>
#include <QString>
#include <QVariantMap>

// 前向声明
class ProjectManager;
class CurveManager;
class AlgorithmService;
class HistoryManager;

class MainController : public QObject {
    Q_OBJECT

public:
    explicit MainController(
        ProjectManager* projectManager,
        CurveManager* curveManager,
        AlgorithmService* algorithmService,
        HistoryManager* historyManager,
        QObject* parent = nullptr
    );

public slots:
    // ===== 处理 UI 命令的槽函数 =====
    void handleOpenFile();
    void handleSaveProject();
    void handleUndo();
    void handleRedo();
    void handleAlgorithmApply(QString name, QVariantMap params);

signals:
    // 状态通知（可选，用于状态栏消息等）
    void statusMessage(QString message);
    void errorOccurred(QString error);

private:
    // 依赖注入的 Service
    ProjectManager* m_projectManager;
    CurveManager* m_curveManager;
    AlgorithmService* m_algorithmService;
    HistoryManager* m_historyManager;

    // 辅助方法
    bool validateCurveData();
    void logOperation(const QString& operation, const QVariantMap& details);
};

#endif // MAINCONTROLLER_H
```

```cpp
// MainController.cpp
#include "MainController.h"
#include "ProjectManager.h"
#include "CurveManager.h"
#include "AlgorithmService.h"
#include "HistoryManager.h"
#include "AlgorithmCommand.h"
#include "ThermalCurve.h"
#include <QMessageBox>
#include <QDebug>

MainController::MainController(
    ProjectManager* projectManager,
    CurveManager* curveManager,
    AlgorithmService* algorithmService,
    HistoryManager* historyManager,
    QObject* parent
)
    : QObject(parent)
    , m_projectManager(projectManager)
    , m_curveManager(curveManager)
    , m_algorithmService(algorithmService)
    , m_historyManager(historyManager)
{
    Q_ASSERT(projectManager);
    Q_ASSERT(curveManager);
    Q_ASSERT(algorithmService);
    Q_ASSERT(historyManager);
}

// ========== 处理算法执行命令 ==========
void MainController::handleAlgorithmApply(QString name, QVariantMap params) {
    qInfo() << "MainController: 接收到算法执行请求" << name;

    // 1️⃣ 业务规则检查
    ThermalCurve* curve = m_curveManager->getActiveCurve();
    if (!curve) {
        QString error = tr("错误：请先选择一条曲线");
        emit errorOccurred(error);
        QMessageBox::warning(nullptr, tr("错误"), error);
        return;
    }

    if (curve->getRawData().isEmpty()) {
        QString error = tr("错误：曲线数据为空，无法执行算法");
        emit errorOccurred(error);
        QMessageBox::warning(nullptr, tr("错误"), error);
        return;
    }

    // 2️⃣ 获取算法实例
    IThermalAlgorithm* algorithm = m_algorithmService->getAlgorithm(name);
    if (!algorithm) {
        QString error = tr("错误：未找到算法 '%1'").arg(name);
        emit errorOccurred(error);
        QMessageBox::critical(nullptr, tr("错误"), error);
        return;
    }

    // 3️⃣ 设置算法参数
    algorithm->setParameters(params);

    // 4️⃣ 创建可撤销命令
    auto* cmd = new AlgorithmCommand(
        curve->getId(),
        algorithm,
        m_curveManager,
        m_algorithmService
    );

    // 5️⃣ 通过 HistoryManager 执行（支持撤销）
    if (!m_historyManager->execute(cmd)) {
        QString error = tr("错误：算法执行失败");
        emit errorOccurred(error);
        QMessageBox::critical(nullptr, tr("错误"), error);
        delete cmd;
        return;
    }

    // 6️⃣ 标记项目已修改
    m_projectManager->setModified(true);

    // 7️⃣ 记录操作日志
    logOperation("算法执行", {
        {"algorithm", name},
        {"curveId", curve->getId()},
        {"curveName", curve->getName()},
        {"parameters", params}
    });

    // 8️⃣ 发送状态消息
    emit statusMessage(tr("正在执行算法: %1").arg(name));

    // 注意：结果显示由 ToolPanel 监听 AlgorithmService::algorithmFinished 信号处理
    // Controller 不负责通知 UI 更新
}

void MainController::handleUndo() {
    if (!m_historyManager->canUndo()) {
        QMessageBox::information(nullptr, tr("提示"), tr("没有可撤销的操作"));
        return;
    }

    m_historyManager->undo();
    m_projectManager->setModified(true);

    emit statusMessage(tr("已撤销上一步操作"));
}

void MainController::handleRedo() {
    if (!m_historyManager->canRedo()) {
        QMessageBox::information(nullptr, tr("提示"), tr("没有可重做的操作"));
        return;
    }

    m_historyManager->redo();
    m_projectManager->setModified(true);

    emit statusMessage(tr("已重做操作"));
}

void MainController::logOperation(const QString& operation, const QVariantMap& details) {
    // 记录到日志系统
    QString logMsg = QString("操作: %1").arg(operation);
    for (auto it = details.begin(); it != details.end(); ++it) {
        logMsg += QString(", %1=%2").arg(it.key()).arg(it.value().toString());
    }
    qInfo() << logMsg;
}
```

---

### 3. 应用程序启动代码

```cpp
// Application.cpp
#include "Application.h"
#include "MainWindow.h"
#include "MainController.h"
#include "ChartController.h"
#include "ProjectManager.h"
#include "CurveManager.h"
#include "AlgorithmService.h"
#include "HistoryManager.h"
#include "SignalConnectionManager.h"

class Application {
public:
    void initialize() {
        // ========== 创建单例 Service（应用层）==========
        auto* projectManager = ProjectManager::instance();
        auto* curveManager = CurveManager::instance();
        auto* algorithmService = AlgorithmService::instance();
        auto* historyManager = HistoryManager::instance();

        // ========== 创建 Controller（应用层）==========
        m_mainController = new MainController(
            projectManager,
            curveManager,
            algorithmService,
            historyManager
        );

        m_chartController = new ChartController(
            curveManager,
            algorithmService
        );

        // ========== 创建 UI（表示层）==========
        m_mainWindow = new MainWindow();

        // ========== 建立信号连接 ==========
        setupSignalConnections();

        // ========== 显示窗口 ==========
        m_mainWindow->show();
    }

private:
    void setupSignalConnections() {
        // ===== 命令路径：UI → Controller =====

        // MainWindow → MainController
        connect(m_mainWindow, &MainWindow::openFileRequested,
                m_mainController, &MainController::handleOpenFile);
        connect(m_mainWindow, &MainWindow::saveProjectRequested,
                m_mainController, &MainController::handleSaveProject);
        connect(m_mainWindow, &MainWindow::undoRequested,
                m_mainController, &MainController::handleUndo);
        connect(m_mainWindow, &MainWindow::redoRequested,
                m_mainController, &MainController::handleRedo);

        // ToolPanel → MainController
        auto* toolPanel = m_mainWindow->getToolPanel();
        connect(toolPanel, &ToolPanel::algorithmApplyRequested,
                m_mainController, &MainController::handleAlgorithmApply);

        // ChartView → ChartController
        auto* chartView = m_mainWindow->getChartView();
        connect(chartView, &ChartView::regionSelected,
                m_chartController, &ChartController::handleRegionSelection);

        // ===== 通知路径：Service → UI =====
        // (已在各 UI 组件内部的 setupConnections() 中完成)
        // 例如：ToolPanel 监听 AlgorithmService::algorithmFinished

        // ===== Controller 状态消息 → MainWindow 状态栏 =====
        connect(m_mainController, &MainController::statusMessage,
                m_mainWindow, &MainWindow::showStatusMessage);
        connect(m_mainController, &MainController::errorOccurred,
                m_mainWindow, &MainWindow::showErrorMessage);
    }

    MainWindow* m_mainWindow;
    MainController* m_mainController;
    ChartController* m_chartController;
};

// main.cpp
int main(int argc, char *argv[]) {
    QApplication app(argc, argv);

    Application application;
    application.initialize();

    return app.exec();
}
```

---

## 最佳实践

### ✅ DO - 推荐做法

1. **所有写操作走 Controller**
```cpp
// ToolPanel.cpp
void ToolPanel::onApplyButtonClicked() {
    // ✅ 发射信号给 Controller
    emit algorithmApplyRequested(algoName, params);
}
```

2. **只读更新直接监听 Service**
```cpp
// ToolPanel.cpp 构造函数
connect(AlgorithmService::instance(), &AlgorithmService::algorithmFinished,
        this, &ToolPanel::displayResults);
```

3. **使用 Command 模式支持撤销**
```cpp
// MainController.cpp
auto* cmd = new AlgorithmCommand(...);
m_historyManager->execute(cmd);  // 自动记录历史
```

4. **在 Controller 中协调多个 Service**
```cpp
void MainController::handleAlgorithmApply(...) {
    // 检查 CurveManager
    // 调用 AlgorithmService
    // 记录到 HistoryManager
    // 通知 ProjectManager
}
```

---

### ❌ DON'T - 避免的做法

1. **❌ UI 直接调用 Service 执行写操作**
```cpp
// ToolPanel.cpp - 错误示例
void ToolPanel::onApplyButtonClicked() {
    // ❌ 跳过 Controller，无法撤销，无法记录日志
    AlgorithmService::instance()->executeAsync(...);
}
```

2. **❌ 通过 Controller 转发只读信号**
```cpp
// MainController.cpp - 不必要的转发
connect(AlgorithmService::instance(), &AlgorithmService::algorithmFinished,
        this, &MainController::onAlgorithmFinished);

void MainController::onAlgorithmFinished(Result result) {
    // ❌ 只是转发，没有添加任何业务逻辑
    emit algorithmResultReady(result);
}
```

3. **❌ UI 层包含业务逻辑**
```cpp
// ToolPanel.cpp - 错误示例
void ToolPanel::onApplyButtonClicked() {
    // ❌ UI 层不应该处理业务规则
    if (CurveManager::instance()->getActiveCurve() == nullptr) {
        QMessageBox::warning(...);
        return;
    }
    // ❌ UI 层不应该协调多个 Service
    AlgorithmService::instance()->executeAsync(...);
    ProjectManager::instance()->setModified(true);
}
```



---

## 常见错误

### 问题1: "为什么不能 ToolPanel 直接调用 AlgorithmService？"

**答案:**
- ❌ 无法实现撤销/重做功能
- ❌ 无法统一记录操作日志
- ❌ 无法协调多个 Service（如同时更新 ProjectManager）
- ❌ UI 层承担了业务协调职责，违反单一职责原则

### 问题2: "监听 Service 信号是否违反了分层原则？"

**答案:**
- ✅ **不违反**，这是合理的设计
- 表示层可以**只读访问**应用层的状态
- 这是**发布-订阅模式**，不是直接依赖
- 避免了不必要的信号转发（Service → Controller → UI）

### 问题3: "什么时候需要通过 Controller 转发信号？"

**答案:**
只在以下情况需要转发：
1. Controller 需要**添加业务逻辑**（如过滤、转换）
2. 需要**协调多个 Service 的响应**
3. 需要**权限检查**后再通知 UI

如果只是纯粹转发，应该让 UI 直接监听 Service。

---

## 总结

### 🎯 核心要点

| 操作类型 | 信号路径 | 原因 |
|---------|---------|------|
| **写操作** | UI → Controller → Service | 需要撤销、日志、协调 |
| **读操作** | Service → UI（直接监听） | 避免不必要转发 |

### 📊 判断标准

**问自己三个问题:**

1. **这个操作修改数据吗？**
   - 是 → 必须走 Controller
   - 否 → 可以直接监听

2. **需要撤销/重做吗？**
   - 是 → 必须走 Controller + Command 模式
   - 否 → 看情况

3. **需要协调多个 Service 吗？**
   - 是 → 必须走 Controller
   - 否 → 可以直接监听

---

**架构图参考:**
- [架构层级图.puml](架构层级图.puml) - 详细的四层架构图
- [架构图.puml](架构图.puml) - 简化的架构图

**相关文档:**
- Command 模式实现
- Service 层设计指南
- 单元测试最佳实践
