# 全新架构实施方案 - 无兼容层

> **核心原则**: 彻底重构，不做兼容，直接切到"纯上下文 + 自描述 + 统一结果"架构
> **目标**: 保持应用层简洁，避免辅助类累积

---

## 一、当前问题：兼容层堆积

### 1.1 重复的描述符定义

**领域层**（domain/algorithm/）:
- ✅ `AlgorithmDescriptor` - 算法自描述结构
- ✅ `AlgorithmParameterDefinition` - 参数定义

**应用层**（application/algorithm/）:
- ❌ `App::AlgorithmDescriptor` - **重复定义！**
- ❌ `App::ParameterDescriptor` - **重复定义！**
- ❌ `MetadataDescriptorRegistry` - **冗余注册表！**

**问题**: 两套描述符系统并存，导致代码冗余和维护成本增加。

---

## 二、彻底删除清单

### 2.1 完全删除的文件（7个）

| 文件 | 行数 | 删除原因 |
|------|------|---------|
| `metadata_descriptor.h` | ~150 | 与 domain 层 AlgorithmDescriptor 重复 |
| `metadata_descriptor_registry.h` | ~60 | 冗余注册表，算法自描述即可 |
| `metadata_descriptor_registry.cpp` | ~80 | 冗余注册表实现 |
| `register_metadata_descriptors.cpp` | ~120 | 冗余注册逻辑 |
| `algorithm_descriptor.h`（应用层） | ~50 | 如果存在，删除（保留领域层版本） |

**预计删除**: ~460 行代码

---

### 2.2 大幅简化的文件（2个）

| 文件 | 当前行数 | 重构后行数 | 减少 |
|------|---------|-----------|------|
| `algorithm_coordinator.h` | 278 | ~120 | 158 |
| `algorithm_coordinator.cpp` | 445 | ~180 | 265 |
| **总计** | **723** | **~300** | **423** |

---

### 2.3 保留的核心文件（8个）

| 文件 | 职责 | 备注 |
|------|------|------|
| `algorithm_context.h/cpp` | 上下文容器 | 保持不变 |
| `algorithm_manager.h/cpp` | 算法管理器 | 轻微简化 |
| `algorithm_coordinator.h/cpp` | 流程协调器 | **大幅简化** |
| `algorithm_thread_manager.h/cpp` | 线程管理 | 保持不变 |
| `algorithm_worker.h/cpp` | 工作线程 | 保持不变 |
| `algorithm_task.h/cpp` | 任务封装 | 保持不变 |

---

## 三、全新架构设计

### 3.1 核心理念

```
算法自描述（领域层）
         ↓
上下文驱动（应用层）
         ↓
统一结果输出（领域层）
```

**关键点**：
- ❌ **无应用层描述符** - 只使用领域层的 `AlgorithmDescriptor`
- ❌ **无元数据注册表** - 算法自己提供 `descriptor()`
- ❌ **无兼容适配类** - 直接使用新架构

---

### 3.2 应用层职责划分

| 组件 | 职责 | 行数 |
|------|------|------|
| **AlgorithmContext** | 存储运行时数据 | ~200 |
| **AlgorithmManager** | 注册/查找/执行算法 | ~300 |
| **AlgorithmCoordinator** | 协调交互流程 | ~300 |
| **AlgorithmThreadManager** | 管理线程池 | ~150 |
| **AlgorithmWorker** | 后台执行算法 | ~100 |
| **AlgorithmTask** | 任务封装 | ~50 |
| **总计** | | **~1100 行** |

**对比当前**：~1700 行 → ~1100 行（减少 35%）

---

## 四、删除步骤

### Step 1: 删除元数据相关文件

```bash
# 删除冗余的元数据描述符
rm Analysis/src/application/algorithm/metadata_descriptor.h
rm Analysis/src/application/algorithm/metadata_descriptor_registry.h
rm Analysis/src/application/algorithm/metadata_descriptor_registry.cpp
rm Analysis/src/application/algorithm/register_metadata_descriptors.cpp
```

### Step 2: 删除应用层的重复描述符（如果存在）

```bash
# 检查是否存在应用层的 algorithm_descriptor.h
# 如果存在，删除（保留领域层版本）
rm Analysis/src/application/algorithm/algorithm_descriptor.h
```

### Step 3: 更新所有引用

**替换规则**：
```cpp
// ❌ 旧方式（应用层描述符）
#include "application/algorithm/metadata_descriptor.h"
using App::AlgorithmDescriptor;
using App::ParameterDescriptor;

// ✅ 新方式（领域层描述符）
#include "domain/algorithm/algorithm_descriptor.h"
using AlgorithmDescriptor;
using AlgorithmParameterDefinition;
```

---

## 五、全新架构实施

### 5.1 Phase 1: 清理冗余类（1小时）

**任务**：
- [ ] 删除 `metadata_descriptor.h`
- [ ] 删除 `metadata_descriptor_registry.h/cpp`
- [ ] 删除 `register_metadata_descriptors.cpp`
- [ ] 删除应用层的 `algorithm_descriptor.h`（如果存在）
- [ ] 更新所有 `#include` 引用

**影响文件**：
- `algorithm_coordinator.h/cpp`
- `algorithm_manager.h/cpp`
- `main_controller.h/cpp`

---

### 5.2 Phase 2: 增强领域层 AlgorithmDescriptor（2小时）

**文件**: `domain/algorithm/algorithm_descriptor.h`

**添加字段**：
```cpp
struct AlgorithmDescriptor {
    // ==================== 基本信息 ====================
    QString name;
    QString displayName;
    QString category;

    // ==================== 交互需求（算法自描述）====================
    bool needsParameters = false;
    QVector<AlgorithmParameterDefinition> parameters;

    bool needsPointSelection = false;
    int requiredPointCount = 0;
    QString pointSelectionHint;

    bool needsCurveSelection = false;  // 未来扩展

    QStringList interactionOrder;  // 交互顺序
};
```

---

### 5.3 Phase 3: 重构 AlgorithmCoordinator（4小时）

**文件**: `application/algorithm/algorithm_coordinator.h/cpp`

**核心改动**：
```cpp
class AlgorithmCoordinator : public QObject {
    Q_OBJECT

public:
    // ✅ 唯一入口
    void run(const QString& algorithmName);

    // ✅ 简化的提交接口
    void submitParameters(const QVariantMap& parameters);
    void submitPoints(const QVector<ThermalDataPoint>& points);
    void cancel();

signals:
    // ✅ 直接使用领域层 AlgorithmDescriptor
    void requestParameterDialog(const QString& algorithmName,
                                const AlgorithmDescriptor& descriptor);
    void requestPointSelection(const QString& algorithmName,
                               int requiredCount, const QString& hint);

private:
    // ✅ 简化的状态结构
    struct PendingRequest {
        QString algorithmName;
        AlgorithmDescriptor descriptor;  // 直接使用领域层描述符
        QVariantMap parameters;
        QVector<ThermalDataPoint> points;
        int currentStepIndex = 0;
    };

    std::optional<PendingRequest> m_pending;

    // ✅ 核心方法
    void processNextStep();
    void execute();
};
```

**删除的代码**：
- ❌ `enum class PendingPhase`
- ❌ `MetadataPendingRequest` 结构
- ❌ `handleGenericParameterSubmission()`
- ❌ `runByName()` 的复杂判断逻辑
- ❌ 所有元数据注册表相关代码

---

### 5.4 Phase 4: 实现动态参数对话框（3小时）

**文件**: `ui/controller/main_controller.h/cpp`

```cpp
// main_controller.cpp
void MainController::onRequestParameterDialog(
    const QString& algorithmName,
    const AlgorithmDescriptor& descriptor)  // ✅ 直接使用领域层描述符
{
    QDialog* dlg = new QDialog(m_mainWindow);
    QFormLayout* form = new QFormLayout(dlg);

    QMap<QString, QWidget*> widgets;

    // ✅ 遍历领域层的 parameters
    for (const auto& param : descriptor.parameters) {
        QWidget* widget = createParameterWidget(param, dlg);
        form->addRow(param.displayName + ":", widget);
        widgets[param.name] = widget;
    }

    // ... 按钮和提交逻辑
}
```

---

### 5.5 Phase 5: 更新所有算法（2小时）

**每个算法实现 `descriptor()`**：

```cpp
class DifferentiationAlgorithm : public IThermalAlgorithm {
public:
    AlgorithmDescriptor descriptor() const override {
        AlgorithmDescriptor desc;
        desc.name = "differentiation";
        desc.displayName = "微分";
        desc.category = "Analysis";

        // ✅ 直接使用领域层描述符
        desc.needsParameters = false;
        desc.needsPointSelection = false;

        return desc;
    }
};
```

---

### 5.6 Phase 6: 测试验证（2小时）

**完整测试清单**：
- [ ] 微分算法（无交互）
- [ ] 积分算法（无交互）
- [ ] 移动平均（参数对话框）
- [ ] 基线校正（点选交互）
- [ ] 峰面积（参数 + 点选）
- [ ] 取消操作
- [ ] 错误处理

---

## 六、架构对比

### 6.1 应用层文件数量

| 文件类别 | 旧架构 | 新架构 | 变化 |
|---------|--------|--------|------|
| **核心文件** | 8 个 | 6 个 | -2 |
| **元数据相关** | 4 个 | 0 个 | **-4** ✅ |
| **兼容适配** | 3 个 | 0 个 | **-3** ✅ |
| **总计** | **15 个** | **6 个** | **-9 个** |

---

### 6.2 代码行数对比

| 组件 | 旧架构 | 新架构 | 减少 |
|------|--------|--------|------|
| AlgorithmCoordinator | 723 | 300 | 423 |
| 元数据相关 | 460 | 0 | 460 |
| 重复描述符 | 200 | 0 | 200 |
| **应用层总计** | **~1700** | **~1100** | **~600** |

**减少比例**: 35%

---

### 6.3 依赖关系

**旧架构（复杂）**：
```
应用层 ──┬─→ App::AlgorithmDescriptor
         ├─→ MetadataDescriptorRegistry
         ├─→ domain::AlgorithmDescriptor
         └─→ 多套系统并存
```

**新架构（简洁）**：
```
应用层 ──→ domain::AlgorithmDescriptor
         （唯一数据源）
```

---

## 七、迁移检查清单

### 7.1 删除文件检查

- [ ] 确认删除 `metadata_descriptor.h`
- [ ] 确认删除 `metadata_descriptor_registry.h/cpp`
- [ ] 确认删除 `register_metadata_descriptors.cpp`
- [ ] 确认删除应用层的重复描述符

### 7.2 引用更新检查

- [ ] AlgorithmCoordinator 引用更新
- [ ] AlgorithmManager 引用更新
- [ ] MainController 引用更新
- [ ] 所有算法实现引用更新

### 7.3 编译验证

- [ ] 清理编译产物：`clean.bat`
- [ ] 重新编译：`build.bat`
- [ ] 检查链接错误
- [ ] 检查运行时错误

---

## 八、实施时间表

| 阶段 | 任务 | 耗时 |
|------|------|------|
| Phase 1 | 清理冗余类 | 1h |
| Phase 2 | 增强领域层 AlgorithmDescriptor | 2h |
| Phase 3 | 重构 AlgorithmCoordinator | 4h |
| Phase 4 | 实现动态参数对话框 | 3h |
| Phase 5 | 更新所有算法 | 2h |
| Phase 6 | 测试验证 | 2h |
| **总计** | | **14h** |

---

## 九、关键原则

### ✅ 必须遵守

1. **单一数据源** - 只使用领域层的 `AlgorithmDescriptor`
2. **无兼容层** - 直接切换到新架构，不保留旧代码
3. **简洁应用层** - 避免辅助类累积
4. **算法自描述** - 算法自己提供 `descriptor()`

### ❌ 严格禁止

1. **禁止创建适配器** - 不要创建 `DescriptorAdapter` 之类的类
2. **禁止双重路径** - 不要保留旧的执行路径
3. **禁止重复定义** - 不要在应用层重复定义描述符
4. **禁止元数据注册表** - 算法自描述即可

---

## 十、预期成果

### 代码质量

- ✅ **应用层文件减少 60%**（15 个 → 6 个）
- ✅ **应用层代码减少 35%**（~1700 行 → ~1100 行）
- ✅ **单一数据源**（只用领域层描述符）
- ✅ **无技术债务**（无兼容层堆积）

### 架构清晰度

- ✅ **职责明确** - 领域层定义，应用层执行
- ✅ **依赖单向** - 应用层 → 领域层
- ✅ **易于理解** - 无重复概念
- ✅ **易于扩展** - 添加新算法无需修改框架

---

## 十一、开始实施

**准备工作**：
1. 备份当前代码（已在 Git 中）
2. 确认当前分支：`claude/switch-simple-code-branch-0115yMamo9jdvpYQLPrx8ogs`
3. 清空工作区：确保无未提交的修改

**立即开始**：
- Phase 1: 删除冗余类（1小时）
- 逐步推进到 Phase 6

---

**文档版本**: v3.0（全新架构，无兼容层）
**创建日期**: 2025-11-18
**状态**: 待执行
**核心原则**: 彻底重构，不做兼容，保持简洁
