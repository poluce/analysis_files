# 算法自描述重构方案 v2.0

## 核心理念

**算法应该完全自描述：是否需要交互、怎么交互、交互顺序，都由算法自己定义。**

AlgorithmCoordinator 只是一个"执行器"，按照算法的自描述信息来驱动流程。

---

## 一、当前问题分析

### 1.1 Coordinator 做了太多判断

```cpp
// 当前 AlgorithmCoordinator 需要判断：
void AlgorithmCoordinator::runByName(const QString& algorithmName) {
    auto descriptor = descriptorFor(algorithmName);

    // ❌ Coordinator 在判断是否需要参数
    if (!descriptor.parameters.isEmpty()) {
        // 请求参数对话框
    }

    // ❌ Coordinator 在判断是否需要点选
    if (descriptor.interaction == AlgorithmInteraction::PointSelection) {
        // 请求点选
    }

    // ❌ Coordinator 在判断交互顺序
    if (needsParameters && needsPoints) {
        // 先参数后点选？还是反过来？
    }
}
```

**问题**：
- Coordinator 需要理解算法的交互逻辑
- 添加新交互类型需要修改 Coordinator
- 违反开闭原则

---

### 1.2 算法的自描述能力被低估

当前 `IThermalAlgorithm` 已经有 `descriptor()` 方法：

```cpp
virtual AlgorithmDescriptor descriptor() const {
    AlgorithmDescriptor desc;
    desc.name = name();
    desc.interaction = AlgorithmInteraction::None;
    desc.parameters = {...};
    desc.requiredPointCount = 2;
    desc.pointSelectionHint = "请选择起点和终点";
    return desc;
}
```

但这些信息**没有被充分利用**，Coordinator 还在做重复的判断。

---

## 二、新设计方案：算法完全自描述

### 2.1 核心思想

**算法应该告诉 Coordinator："我需要什么，按什么顺序给我"**

```cpp
// 算法自己定义交互流程
class BaselineCorrectionAlgorithm : public IThermalAlgorithm {
public:
    AlgorithmDescriptor descriptor() const override {
        AlgorithmDescriptor desc;
        desc.name = "baseline_correction";
        desc.displayName = "基线校正";

        // ✅ 算法自己描述需要什么
        desc.needsParameters = false;      // 不需要参数对话框
        desc.needsPointSelection = true;   // 需要点选
        desc.requiredPointCount = 2;       // 需要2个点
        desc.pointSelectionHint = "请选择基线起点和终点";

        return desc;
    }
};
```

---

### 2.2 增强的 AlgorithmDescriptor

```cpp
struct AlgorithmDescriptor {
    // ==================== 基本信息 ====================
    QString name;          // 算法名称（如 "differentiation"）
    QString displayName;   // 显示名称（如 "微分"）
    QString category;      // 分类（如 "Analysis"）

    // ==================== 交互需求（算法自描述）====================

    /**
     * @brief 是否需要参数对话框
     *
     * true  - 执行前弹出参数对话框
     * false - 无需参数输入，直接执行
     */
    bool needsParameters = false;

    /**
     * @brief 参数定义列表（如果 needsParameters = true）
     */
    QVector<AlgorithmParameterDefinition> parameters;

    /**
     * @brief 是否需要点选交互
     *
     * true  - 执行前需要用户在图表上选点
     * false - 无需点选，直接执行
     */
    bool needsPointSelection = false;

    /**
     * @brief 所需点数（如果 needsPointSelection = true）
     */
    int requiredPointCount = 0;

    /**
     * @brief 点选提示信息（如果 needsPointSelection = true）
     */
    QString pointSelectionHint;

    /**
     * @brief 是否需要选择第二条曲线（未来扩展）
     *
     * true  - 执行前需要用户选择另一条曲线
     * false - 无需选择曲线
     */
    bool needsCurveSelection = false;

    /**
     * @brief 交互顺序（如果同时需要多种交互）
     *
     * 定义交互的执行顺序，例如：
     * - ["parameters", "points"] - 先参数对话框，再点选
     * - ["points", "parameters"] - 先点选，再参数对话框
     * - ["points"] - 只需要点选
     *
     * 如果为空，则按默认顺序：parameters → points → curve
     */
    QStringList interactionOrder;
};
```

---

### 2.3 简化后的 AlgorithmCoordinator

```cpp
class AlgorithmCoordinator : public QObject {
    Q_OBJECT

public:
    /**
     * @brief 唯一的执行入口
     *
     * 读取算法的自描述信息，按顺序执行交互流程。
     */
    void run(const QString& algorithmName);

    /**
     * @brief 用户提交参数后调用
     */
    void submitParameters(const QVariantMap& parameters);

    /**
     * @brief 用户完成点选后调用
     */
    void submitPoints(const QVector<ThermalDataPoint>& points);

    /**
     * @brief 取消当前操作
     */
    void cancel();

signals:
    void requestParameterDialog(const QString& algorithmName, const AlgorithmDescriptor& descriptor);
    void requestPointSelection(const QString& algorithmName, int requiredCount, const QString& hint);
    void algorithmFinished(const QString& algorithmName, const AlgorithmResult& result);
    void algorithmFailed(const QString& algorithmName, const QString& reason);

private:
    /**
     * @brief 处理下一个交互步骤
     *
     * 根据算法的自描述信息（interactionOrder）执行下一步。
     * 如果所有交互完成，则执行算法。
     */
    void processNextStep();

    /**
     * @brief 执行算法（所有交互完成后调用）
     */
    void execute();

    // ==================== 简化的状态 ====================

    struct PendingRequest {
        QString algorithmName;
        AlgorithmDescriptor descriptor;  // 算法的完整自描述信息
        QVariantMap parameters;          // 已收集的参数
        QVector<ThermalDataPoint> points; // 已收集的点
        int currentStepIndex = 0;        // 当前交互步骤索引
    };

    std::optional<PendingRequest> m_pending;
    QString m_currentTaskId;
};
```

---

### 2.4 核心执行逻辑

```cpp
void AlgorithmCoordinator::run(const QString& algorithmName) {
    // 1. 获取算法的自描述信息
    auto descriptor = getDescriptor(algorithmName);
    if (!descriptor.has_value()) {
        emit algorithmFailed(algorithmName, "找不到算法");
        return;
    }

    // 2. 创建待处理请求
    PendingRequest pending;
    pending.algorithmName = algorithmName;
    pending.descriptor = descriptor.value();
    pending.currentStepIndex = 0;
    m_pending = pending;

    // 3. 开始处理交互流程
    processNextStep();
}

void AlgorithmCoordinator::processNextStep() {
    if (!m_pending.has_value()) {
        return;
    }

    auto& pending = m_pending.value();
    auto& descriptor = pending.descriptor;

    // 获取交互顺序（如果未定义，使用默认顺序）
    QStringList order = descriptor.interactionOrder;
    if (order.isEmpty()) {
        // 默认顺序：参数 → 点选 → 曲线
        if (descriptor.needsParameters) order << "parameters";
        if (descriptor.needsPointSelection) order << "points";
        if (descriptor.needsCurveSelection) order << "curve";
    }

    // 检查是否所有交互都完成
    if (pending.currentStepIndex >= order.size()) {
        // 所有交互完成，执行算法
        execute();
        return;
    }

    // 处理当前步骤
    QString currentStep = order[pending.currentStepIndex];

    if (currentStep == "parameters") {
        // 请求参数对话框
        emit requestParameterDialog(pending.algorithmName, descriptor);

    } else if (currentStep == "points") {
        // 请求点选
        emit requestPointSelection(
            pending.algorithmName,
            descriptor.requiredPointCount,
            descriptor.pointSelectionHint);

    } else if (currentStep == "curve") {
        // 请求曲线选择（未来扩展）
        // emit requestCurveSelection(pending.algorithmName);
    }
}

void AlgorithmCoordinator::submitParameters(const QVariantMap& parameters) {
    if (!m_pending.has_value()) {
        return;
    }

    // 保存参数
    m_pending->parameters = parameters;

    // 移动到下一步
    m_pending->currentStepIndex++;
    processNextStep();
}

void AlgorithmCoordinator::submitPoints(const QVector<ThermalDataPoint>& points) {
    if (!m_pending.has_value()) {
        return;
    }

    // 验证点数
    if (points.size() < m_pending->descriptor.requiredPointCount) {
        emit algorithmFailed(m_pending->algorithmName,
            QString("需要至少 %1 个点").arg(m_pending->descriptor.requiredPointCount));
        return;
    }

    // 保存点选结果
    m_pending->points = points;

    // 移动到下一步
    m_pending->currentStepIndex++;
    processNextStep();
}

void AlgorithmCoordinator::execute() {
    if (!m_pending.has_value()) {
        return;
    }

    auto& pending = m_pending.value();

    // 获取活动曲线
    ThermalCurve* curve = m_curveManager->getActiveCurve();
    if (!curve) {
        emit algorithmFailed(pending.algorithmName, "没有活动曲线");
        return;
    }

    // 注入数据到上下文
    m_context->setValue("activeCurve", QVariant::fromValue(curve));
    m_context->setValue("parameters", pending.parameters);
    m_context->setValue("selectedPoints", QVariant::fromValue(pending.points));

    // 提交到线程池执行
    QString taskId = m_algorithmManager->executeAsync(
        pending.algorithmName, m_context);

    m_currentTaskId = taskId;
}
```

---

## 三、算法自描述示例

### 3.1 无需交互的算法（微分）

```cpp
class DifferentiationAlgorithm : public IThermalAlgorithm {
public:
    AlgorithmDescriptor descriptor() const override {
        AlgorithmDescriptor desc;
        desc.name = "differentiation";
        desc.displayName = "微分";
        desc.category = "Analysis";

        // ✅ 无需任何交互
        desc.needsParameters = false;
        desc.needsPointSelection = false;

        return desc;
    }
};

// 执行流程：
// run("differentiation") → execute() → 完成
```

---

### 3.2 需要参数的算法（移动平均）

```cpp
class MovingAverageFilterAlgorithm : public IThermalAlgorithm {
public:
    AlgorithmDescriptor descriptor() const override {
        AlgorithmDescriptor desc;
        desc.name = "moving_average";
        desc.displayName = "移动平均";
        desc.category = "Preprocessing";

        // ✅ 需要参数对话框
        desc.needsParameters = true;
        desc.parameters = {
            {"windowSize", "窗口大小", ParameterType::Integer, 5, 1, 100}
        };

        // 不需要点选
        desc.needsPointSelection = false;

        return desc;
    }
};

// 执行流程：
// run("moving_average")
//   → requestParameterDialog()
//   → submitParameters()
//   → execute()
//   → 完成
```

---

### 3.3 需要点选的算法（基线校正）

```cpp
class BaselineCorrectionAlgorithm : public IThermalAlgorithm {
public:
    AlgorithmDescriptor descriptor() const override {
        AlgorithmDescriptor desc;
        desc.name = "baseline_correction";
        desc.displayName = "基线校正";
        desc.category = "Preprocessing";

        // 不需要参数对话框
        desc.needsParameters = false;

        // ✅ 需要点选
        desc.needsPointSelection = true;
        desc.requiredPointCount = 2;
        desc.pointSelectionHint = "请选择基线起点和终点";

        return desc;
    }
};

// 执行流程：
// run("baseline_correction")
//   → requestPointSelection()
//   → submitPoints()
//   → execute()
//   → 完成
```

---

### 3.4 需要参数 + 点选的算法（峰面积）

```cpp
class PeakAreaAlgorithm : public IThermalAlgorithm {
public:
    AlgorithmDescriptor descriptor() const override {
        AlgorithmDescriptor desc;
        desc.name = "peak_area";
        desc.displayName = "峰面积";
        desc.category = "Analysis";

        // ✅ 需要参数对话框
        desc.needsParameters = true;
        desc.parameters = {
            {"baselineType", "基线类型", ParameterType::Enum,
             0, {"线性", "多项式"}}
        };

        // ✅ 需要点选
        desc.needsPointSelection = true;
        desc.requiredPointCount = 2;
        desc.pointSelectionHint = "请选择峰的起点和终点";

        // ✅ 交互顺序：先参数，再点选
        desc.interactionOrder = {"parameters", "points"};

        return desc;
    }
};

// 执行流程：
// run("peak_area")
//   → requestParameterDialog()
//   → submitParameters()
//   → requestPointSelection()
//   → submitPoints()
//   → execute()
//   → 完成
```

---

## 四、关键优势

### 4.1 代码量大幅减少

| 组件 | 当前行数 | 新设计行数 | 减少比例 |
|------|---------|-----------|---------|
| AlgorithmCoordinator.h | 278 | ~120 | 57% |
| AlgorithmCoordinator.cpp | 445 | ~180 | 60% |
| **总计** | **723** | **~300** | **58%** |

**预计减少 420 行代码！**

---

### 4.2 架构更清晰

```
旧架构：
- Coordinator 需要理解算法的交互逻辑
- Coordinator 包含大量判断分支
- 添加新算法需要修改 Coordinator

新架构：
- 算法完全自描述
- Coordinator 只是执行器，无判断逻辑
- 添加新算法无需修改 Coordinator
```

---

### 4.3 完全符合 SOLID 原则

**单一职责**：
- 算法：定义交互需求
- Coordinator：执行交互流程

**开闭原则**：
- 添加新算法：只需实现 `descriptor()`
- 无需修改 Coordinator

**依赖倒置**：
- Coordinator 依赖算法的自描述接口
- 不依赖具体算法实现

---

### 4.4 易于扩展

**添加新交互类型**（如曲线选择）：

```cpp
// 1. 在 AlgorithmDescriptor 中添加字段
struct AlgorithmDescriptor {
    bool needsCurveSelection = false;  // ✅ 新增
};

// 2. 在 processNextStep() 中添加处理
if (currentStep == "curve") {
    emit requestCurveSelection(pending.algorithmName);
}

// 3. 算法自己声明需要曲线选择
AlgorithmDescriptor descriptor() const override {
    desc.needsCurveSelection = true;  // ✅ 算法自描述
    desc.interactionOrder = {"curve", "parameters", "points"};
    return desc;
}
```

**完全不需要修改 Coordinator 的核心逻辑！**

---

## 五、实施计划

### Phase 1: 增强 AlgorithmDescriptor（2小时）

**任务**：
- [ ] 添加 `needsParameters` 字段
- [ ] 添加 `needsPointSelection` 字段
- [ ] 添加 `needsCurveSelection` 字段（未来扩展）
- [ ] 添加 `interactionOrder` 字段

**影响范围**：
- `domain/algorithm/algorithm_descriptor.h`（修改约 30 行）

---

### Phase 2: 简化 AlgorithmCoordinator（4小时）

**任务**：
- [ ] 删除 `PendingPhase` 枚举
- [ ] 简化 `PendingRequest` 结构
- [ ] 实现 `processNextStep()` 方法
- [ ] 删除所有判断逻辑
- [ ] 统一 `submitParameters()` 和 `submitPoints()` 方法

**影响范围**：
- `application/algorithm/algorithm_coordinator.h`（减少约 150 行）
- `application/algorithm/algorithm_coordinator.cpp`（减少约 270 行）

---

### Phase 3: 更新所有算法的自描述（2小时）

**任务**：
- [ ] DifferentiationAlgorithm: 设置 `needsParameters = false`
- [ ] IntegrationAlgorithm: 设置 `needsParameters = false`
- [ ] MovingAverageFilterAlgorithm: 设置 `needsParameters = true`
- [ ] BaselineCorrectionAlgorithm: 设置 `needsPointSelection = true`
- [ ] PeakAreaAlgorithm: 设置 `needsParameters = true, needsPointSelection = true`

**影响范围**：
- `infrastructure/algorithm/*.cpp`（每个算法修改约 10 行）

---

### Phase 4: 更新 UI 层连接（1小时）

**任务**：
- [ ] 更新 MainController 中的信号连接
- [ ] 移除旧的信号处理槽函数
- [ ] 测试所有算法的执行流程

**影响范围**：
- `ui/controller/main_controller.cpp`（修改约 30 行）

---

### Phase 5: 测试验证（2小时）

**测试清单**：
- [ ] 无交互算法（微分、积分）
- [ ] 参数对话框算法（移动平均）
- [ ] 点选交互算法（基线校正）
- [ ] 复合交互算法（峰面积：参数 + 点选）
- [ ] 取消操作测试
- [ ] 错误处理测试

---

## 六、对比总结

### 旧方案 vs 新方案

| 特性 | 旧方案（v1.0） | 新方案（v2.0 自描述） |
|------|---------------|---------------------|
| **代码行数** | 723 行 | ~300 行（减少 58%） |
| **执行入口** | 3 个 | 1 个 |
| **状态管理** | 复杂状态机 | 简单索引 |
| **判断逻辑** | Coordinator 判断 | 算法自描述 |
| **扩展性** | 需要修改 Coordinator | 只需修改算法 |
| **符合 SOLID** | 部分符合 | 完全符合 |

---

## 七、结论

**算法自描述方案（v2.0）是更优的设计**：

✅ **代码量减少 58%**（723 行 → 300 行）
✅ **完全符合 SOLID 原则**
✅ **添加新算法无需修改 Coordinator**
✅ **更清晰的职责划分**
✅ **更易于维护和扩展**

**核心理念**：
> **算法知道自己需要什么，Coordinator 只是按照算法的要求来执行。**

---

**文档版本**: v2.0（算法自描述）
**创建日期**: 2025-11-18
**作者**: Claude Code
**状态**: 待审批
**优先级**: 高（推荐采用此方案）
