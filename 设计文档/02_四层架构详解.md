# 四层架构详细解析

DSC/TGA热分析软件的四层架构设计。这个架构是基于经典的分层架构模式，结合了领域驱动设计(DDD)的思想，专门针对复杂数据分析软件的特点进行了优化。

## 一、整体架构理念

四层架构的核心思想是**关注点分离**和**依赖方向控制**。每一层都有明确的职责边界，上层可以依赖下层，但下层绝不能依赖上层。这种设计确保了系统的可维护性和可测试性。

架构从下往上的依赖流向体现了软件工程中的一个重要原则：稳定的、不易变化的部分应该处于底层，而易变的、面向用户的部分应该处于上层。在热分析软件中，数据模型和算法接口是相对稳定的核心，而用户界面是最容易根据需求变化的部分。

```
┌─────────────────────────────────────────┐
│         表示层 (Presentation)           │  ← 用户交互
│  MainWindow, ChartView, Controllers    │
├─────────────────────────────────────────┤
│          应用层 (Application)           │  ← 业务流程协调
│  Managers, Services, Coordinators      │
├─────────────────────────────────────────┤
│           领域层 (Domain)               │  ← 业务规则与模型
│  ThermalCurve, Algorithms Interface    │
├─────────────────────────────────────────┤
│        基础设施层 (Infrastructure)       │  ← 技术实现
│  FileIO, Algorithm Implementations     │
└─────────────────────────────────────────┘
```

## 二、基础设施层 (Infrastructure Layer)

基础设施层是整个系统的地基，它提供技术能力支持，但不包含任何业务逻辑。这一层的特点是高度可复用和技术导向。

### FileIO模块的设计哲学

文件输入输出模块负责与外部世界交互。在热分析领域，不同的仪器厂商会产生不同格式的数据文件。

#### Reader子模块 - 可扩展的文件读取框架

**当前实现**：
- `IFileReader` 接口：定义统一的文件读取契约
- `TextFileReader`：支持文本格式文件（.txt, .csv）的读取

```cpp
class IFileReader {
public:
    virtual bool canRead(const QString& filePath) const = 0;
    virtual ThermalCurve read(const QString& filePath) const = 0;
    virtual QStringList supportedExtensions() const = 0;
};
```

`TextFileReader` 实现了智能列识别和数据解析：
- 自动检测分隔符（逗号、制表符、空格）
- 灵活的列映射（温度、时间、测量值）
- 错误处理和数据验证

**扩展点**：
- 未来可添加 `ExcelFileReader`（支持 .xlsx 格式）
- 未来可添加 `BinaryFileReader`（支持厂商专有格式）
- 通过 `FileReaderFactory` 注册新的 Reader 类型

#### Writer子模块（待实现）

Writer子模块将采用工厂模式来处理数据导出的多样性。系统需要支持将分析结果导出为多种格式，如通用的CSV、JSON，或特定的二进制格式。每种格式由一个实现了`IFileWriter`接口的具体Writer类负责。

### Algorithm模块的技术实现

Algorithm模块存放的是算法的具体实现代码。这些实现都遵循领域层定义的IThermalAlgorithm接口。

**当前已实现的算法**：

#### 1. DifferentiationAlgorithm（微分算法）
采用**大窗口平滑中心差分法**，在计算导数的同时进行平滑处理：

```cpp
class DifferentiationAlgorithm : public IThermalAlgorithm {
    QString name() const override { return "differentiation"; }
    QString displayName() const override { return "微分"; }
    QString category() const override { return "数据处理"; }

    // 核心特性
    bool isAuxiliaryCurve() const override { return false; }  // 独立曲线
    bool isStronglyBound() const override { return false; }
    SignalType getOutputSignalType(SignalType input) const override {
        return (input == SignalType::Raw) ? SignalType::Derivative : input;
    }
};
```

算法特点：
- 使用大窗口（默认 halfWin=50）进行双向平滑
- 中心差分法保证精度：`dy/dt = (y[i+halfWin] - y[i-halfWin]) / (2*halfWin*dt)`
- 支持调试输出，便于参数调优
- 生成独立的微分曲线，创建新的右侧Y轴

#### 2. IntegrationAlgorithm（积分算法）
采用**梯形法则**进行数值积分：

```cpp
class IntegrationAlgorithm : public IThermalAlgorithm {
    QString name() const override { return "integration"; }
    QString displayName() const override { return "积分"; }

    bool isAuxiliaryCurve() const override { return false; }  // 独立曲线
    SignalType getOutputSignalType(SignalType input) const override {
        return SignalType::Raw;  // 积分后恢复为原始信号类型
    }
};
```

算法特点：
- 梯形法则：`integral += (y[i] + y[i+1]) * dt / 2`
- 处理DTG→TG的逆向计算
- 累积积分值，生成新曲线

#### 3. MovingAverageFilterAlgorithm（移动平均滤波）
简单但有效的平滑算法：

```cpp
class MovingAverageFilterAlgorithm : public IThermalAlgorithm {
    QString name() const override { return "moving_average"; }
    QString displayName() const override { return "移动平均"; }

    bool isAuxiliaryCurve() const override { return true; }   // 辅助曲线
    bool isStronglyBound() const override { return false; }
};
```

算法特点：
- 使用滑动窗口计算局部平均值
- 简单高效，适合噪声较大的数据
- 生成辅助曲线，继承父曲线Y轴

#### 4. BaselineCorrectionAlgorithm（基线校正）
**交互式算法**，需要用户在图表上选择基线点：

```cpp
class BaselineCorrectionAlgorithm : public IThermalAlgorithm {
    QString name() const override { return "baseline_correction"; }
    QString displayName() const override { return "基线校正"; }

    bool isAuxiliaryCurve() const override { return true; }   // 辅助曲线
    bool isStronglyBound() const override { return true; }    // 强绑定

    // 需要用户选择2个基线点
    AlgorithmDescriptor descriptor() const override {
        AlgorithmDescriptor desc;
        desc.requiresPointSelection = true;
        desc.requiredPointCount = 2;
        desc.selectionHint = "请选择两个基线点";
        return desc;
    }
};
```

算法特点：
- 用户交互式选点（通过 ChartView 的活动算法状态机）
- 线性基线拟合：`baseline(x) = k*x + b`
- 生成强绑定的基线曲线（不出现在项目树中）
- 基线曲线随父曲线显隐而显隐

**未来计划实现的算法**：
- `PeakDetector`：峰值检测算法
- `PeakAreaCalculator`：峰面积计算（交互式）
- `KineticsCalculator`：动力学分析（Kissinger、Ozawa等）
- `SmoothingAlgorithm`：Savitzky-Golay滤波

### Utility模块的工具支持（待实现）

Utility模块提供了各种数据处理和优化工具，这些工具是技术性的，与具体业务无关。

DataDecimator数据抽稀工具解决了大数据量可视化的性能问题。当一条DSC曲线包含三十万个数据点时，DataDecimator使用Douglas-Peucker算法或LTTB算法，智能地保留曲线的关键特征点。

DataInterpolator插值工具用于数据的重采样。有时候需要将不同采样率的曲线对齐进行比较，线性插值适合简单场景，样条插值能提供更平滑的结果。

StatisticsCalculator统计计算工具提供了基本的统计函数：均值、标准差、极值查找等。

## 三、领域层 (Domain Layer)

领域层是整个系统的核心，它定义了热分析领域的概念模型和业务规则。这一层反映了热分析专业人员的思维方式和工作流程。

### 数据模型的业务语义

数据模型模块定义了核心实体：ThermalDataPoint 和 ThermalCurve。

#### ThermalDataPoint - 测量点

代表热分析中的一个测量点，包含三个核心属性：

```cpp
struct ThermalDataPoint {
    qreal temperature;   // 温度 (°C)
    qreal time;          // 时间 (s)
    qreal value;         // 测量值（热流或质量）
    QVariantMap metadata; // 元数据（实验条件、标记等）
};
```

这个简单的结构反映了热分析实验的本质：在不同温度下测量物理量随时间的变化。

#### ThermalCurve - 核心业务对象

ThermalCurve是最核心的业务对象，代表一次热分析实验的完整数据。

**双枚举分离设计** - 项目的核心设计理念：

传统热分析软件常用单一枚举（TGA/DSC/DTG），导致语义混乱。本项目采用**双枚举分离**：

```cpp
class ThermalCurve {
public:
    // 枚举1: 仪器类型（描述数据来源）
    enum class InstrumentType {
        TGA,    // 热重分析仪
        DSC,    // 差示扫描量热仪
        ARC     // 加速量热仪
    };

    // 枚举2: 信号类型（描述数据处理状态）
    enum class SignalType {
        Raw,        // 原始信号
        Derivative, // 微分信号（如DTG）
        Baseline,   // 基线信号
        PeakArea    // 峰面积信号
    };

    // 枚举3: 显示样式
    enum class PlotStyle {
        Line,    // 线图
        Scatter, // 散点图
        Both     // 线+点
    };
};
```

**优势**：
- 语义清晰，概念不混淆
- 易于扩展新仪器类型或处理方法
- 算法通用化，无需针对特定仪器编写特殊逻辑
- `DTG = TGA + Derivative`，清晰表达数据状态

**数据不可变性原则**：

ThermalCurve内部维护两份数据，体现了科研数据处理的基本原则：

```cpp
class ThermalCurve {
private:
    QVector<ThermalDataPoint> m_rawData;        // 原始数据（只读）
    QVector<ThermalDataPoint> m_processedData;  // 处理数据（可修改）

public:
    // 原始数据只提供 const 引用，无修改接口
    const QVector<ThermalDataPoint>& getRawData() const;

    // 处理数据可读写
    const QVector<ThermalDataPoint>& getProcessedData() const;
    void setProcessedData(const QVector<ThermalDataPoint>& data);
};
```

原始数据在加载后不再改变，所有算法处理的都是 `processedData`。这种设计：
- 支持数据回溯和重新处理
- 自然支持撤销功能
- 符合科研规范（原始数据不可篡改）

**父子关系追踪**：

算法生成的曲线自动关联到父曲线：

```cpp
class ThermalCurve {
private:
    QString m_id;          // 唯一标识
    QString m_parentId;    // 父曲线ID
    QString m_projectName; // 所属项目

    InstrumentType m_instrumentType;
    SignalType m_signalType;
    PlotStyle m_plotStyle;

    // 曲线特性标记
    bool m_isAuxiliaryCurve;  // 是否为辅助曲线（继承父曲线Y轴）
    bool m_isStronglyBound;   // 是否强绑定（不在树中显示）
};
```

在 ProjectExplorerView 中以树形结构展示数据血缘关系。

**动态单位推断**：

```cpp
QString ThermalCurve::getYAxisLabel() const {
    if (m_signalType == SignalType::Derivative) {
        return "dValue/dt";
    }

    switch (m_instrumentType) {
        case InstrumentType::TGA:
            return "质量 (mg)";
        case InstrumentType::DSC:
            return "热流 (mW)";
        case InstrumentType::ARC:
            return "温升速率 (°C/min)";
    }
}
```

根据仪器类型和信号类型自动生成Y轴标签，无需手动配置。

#### ThermalProject（待完善）

ThermalProject代表一个研究项目，可以包含多条曲线。在实际研究中，科研人员经常需要对比不同条件下的实验结果。Project提供了组织和管理这些曲线的能力。

### 算法接口的抽象设计

算法接口模块定义了系统中算法的契约规范。

#### IThermalAlgorithm - 核心算法接口

**纯上下文驱动执行模式** - 项目的核心算法架构：

```cpp
class IThermalAlgorithm {
public:
    virtual ~IThermalAlgorithm() = default;

    // ========== 基础信息 ==========
    virtual QString name() const = 0;           // 算法名称（用于注册）
    virtual QString displayName() const = 0;    // 显示名称（用于UI）
    virtual QString category() const = 0;       // 算法分类

    // ========== 上下文驱动执行（唯一接口）==========
    virtual bool prepareContext(AlgorithmContext* context) = 0;
    virtual QVariant executeWithContext(AlgorithmContext* context) = 0;

    // ========== 算法元数据 ==========
    virtual AlgorithmDescriptor descriptor() const = 0;

    // ========== 曲线特性声明 ==========
    virtual bool isAuxiliaryCurve() const = 0;     // 是否为辅助曲线
    virtual bool isStronglyBound() const = 0;      // 是否强绑定
    virtual SignalType getOutputSignalType(SignalType input) const = 0;
};
```

**关键设计特性**：

1. **拉取模式（Pull）**：算法从 `AlgorithmContext` 拉取数据，而非通过参数推送
2. **零参数传递**：`executeWithContext(context)` 无其他参数
3. **单一数据源**：所有运行时数据（曲线、参数、选点）都在 context 中
4. **两阶段执行**：
   - `prepareContext()`：验证数据完整性，注入默认参数，返回就绪状态
   - `executeWithContext()`：只在数据完整时执行计算

**算法实现模板**：

```cpp
class XXXAlgorithm : public IThermalAlgorithm {
public:
    bool prepareContext(AlgorithmContext* context) override {
        if (!context) return false;

        // 验证必需数据
        auto curve = context->get<ThermalCurve*>("activeCurve");
        if (!curve.has_value()) return false;

        // [交互算法] 验证用户交互数据
        auto points = context->get<QVector<QPointF>>("selectedPoints");
        if (points.value().size() < 2) return false;  // 数据不完整

        // 注入默认参数
        if (!context->contains("param.windowSize")) {
            context->setValue("param.windowSize", 50);
        }

        return true;  // 数据完整，可执行
    }

    QVariant executeWithContext(AlgorithmContext* context) override {
        // 拉取曲线
        auto curve = context->get<ThermalCurve*>("activeCurve").value();

        // 拉取参数
        int windowSize = context->get<int>("param.windowSize").value_or(50);

        // 执行算法逻辑
        QVector<ThermalDataPoint> result = processData(curve, windowSize);

        return QVariant::fromValue(result);
    }
};
```

#### AlgorithmContext - 运行时上下文容器

统一的算法运行时数据容器，解决算法执行时的数据传递和追踪问题：

```cpp
struct ContextValue {
    QVariant value;       // 实际值
    QDateTime timestamp;  // 更新时间戳
    QString source;       // 数据来源（UI/Algorithm/File）
};

class AlgorithmContext : public QObject {
    Q_OBJECT

    QMap<QString, ContextValue> m_data;  // 键值对存储

public:
    // 类型安全的访问
    template<typename T>
    std::optional<T> get(const QString& key, const T& defaultValue = T());

    // 设置值并记录来源
    void setValue(const QString& key, const QVariant& value,
                  const QString& source = "Unknown");

    bool contains(const QString& key) const;
    void merge(const AlgorithmContext& other);

signals:
    void valueChanged(const QString& key);  // 值变化信号
};
```

**数据分类**（详见 `新设计文档/AlgorithmContext_数据清单.md`）：
- 基础曲线数据：activeCurve, inputCurve, outputCurve 等
- 通用算法参数：windowSize, threshold, stepSize 等
- 峰面积参数：integralRange, baselineType, startPoint 等
- 基线校正参数：correctionType, polynomialOrder, anchorPoints 等

**优势**：
- 统一数据管理，所有参数/选点/曲线都在上下文中
- 时间戳追踪，便于调试和审计
- 来源追踪，记录数据来自UI输入/算法计算/文件加载
- 信号通知，值变化时自动发出信号
- 类型安全，模板方法提供编译时类型检查

#### AlgorithmDescriptor - 算法元数据

描述算法的参数需求和交互需求：

```cpp
struct AlgorithmDescriptor {
    QString name;
    QString displayName;
    QString category;
    QString description;

    // 参数定义
    QList<ParameterDefinition> parameters;

    // 交互需求
    bool requiresPointSelection = false;
    int requiredPointCount = 0;
    QString selectionHint;

    bool requiresParameterDialog = false;

    // 输出类型
    enum class OutputType {
        Curve,      // 生成新曲线
        Value,      // 返回数值
        Report      // 生成报告
    };
    OutputType outputType = OutputType::Curve;
};
```

用于：
- UI自动生成参数对话框
- 算法交互流程编排
- 结果处理逻辑选择

#### ICommand - 命令模式接口（待完善）

ICommand接口实现了命令模式，这是支持撤销重做功能的关键：

```cpp
class ICommand {
public:
    virtual ~ICommand() = default;
    virtual void execute() = 0;
    virtual void undo() = 0;
    virtual QString description() const = 0;
};
```

每个修改数据的操作都被封装为一个Command对象。Command模式将操作本身对象化，使得操作历史可以被存储、遍历和反向执行。

## 四、应用层 (Application Layer)

应用层是业务逻辑的协调中心，它不定义业务规则（那是领域层的事），而是负责协调领域对象和基础设施服务来完成用户任务。

### 统一初始化 - ApplicationContext

**ApplicationContext** 是应用上下文，负责统一初始化和管理所有 MVC 实例的构造顺序：

```cpp
class ApplicationContext {
public:
    void initialize() {
        // 1. 核心数据管理
        m_curveManager = new CurveManager();

        // 2. 算法服务
        m_algorithmManager = new AlgorithmManager(m_curveManager);
        m_algorithmContext = new AlgorithmContext();
        m_algorithmCoordinator = new AlgorithmCoordinator(
            m_algorithmManager, m_algorithmContext, m_curveManager);

        // 3. 项目管理
        m_projectTreeManager = new ProjectTreeManager(m_curveManager);

        // 4. UI 组件
        m_mainWindow = new MainWindow();
        m_chartView = new ChartView();
        m_projectExplorerView = new ProjectExplorerView();

        // 5. 控制器
        m_mainController = new MainController(
            m_curveManager, m_algorithmCoordinator, m_mainWindow);
        m_curveViewController = new CurveViewController(
            m_curveManager, m_chartView,
            m_projectTreeManager, m_projectExplorerView);
    }
};
```

**优势**：
- 依赖注入，清晰的依赖关系，避免循环依赖
- 可测试性，易于替换为 Mock 对象
- 生命周期管理，统一管理对象的创建和销毁
- 配置集中，所有初始化逻辑集中在一处

### CurveManager - 曲线数据管理

CurveManager是曲线数据的中央仓库，维护当前打开的所有曲线：

```cpp
class CurveManager : public QObject {
    Q_OBJECT

public:
    // 曲线生命周期管理
    void addCurve(const ThermalCurve& curve);
    void removeCurve(const QString& curveId);
    void clearCurves();

    // 曲线访问
    ThermalCurve* getCurve(const QString& curveId);
    const QMap<QString, ThermalCurve>& getAllCurves() const;

    // 活动曲线管理
    ThermalCurve* getActiveCurve();
    void setActiveCurve(const QString& curveId);

    // 文件读取器注册
    void registerFileReader(IFileReader* reader);

signals:
    void curveAdded(const QString& curveId);
    void curveRemoved(const QString& curveId);
    void curveDataChanged(const QString& curveId);
    void activeCurveChanged(const QString& curveId);
    void curvesCleared();

private:
    QMap<QString, ThermalCurve> m_curves;
    QString m_activeCurveId;
    QList<IFileReader*> m_fileReaders;
};
```

**关键特性**：
- activeCurve 概念表示当前工作的曲线
- 所有算法操作默认应用于激活曲线
- 发送数据变化通知（观察者模式）
- 管理文件读取器的注册

### AlgorithmManager - 算法管理器

AlgorithmManager 管理算法注册表，执行算法并创建新曲线：

```cpp
class AlgorithmManager : public QObject {
    Q_OBJECT

public:
    explicit AlgorithmManager(CurveManager* curveManager);

    // 算法注册
    void registerAlgorithm(IThermalAlgorithm* algorithm);
    IThermalAlgorithm* getAlgorithm(const QString& name);

    // 算法执行（唯一接口）
    void executeWithContext(const QString& algorithmName,
                           AlgorithmContext* context);

signals:
    void algorithmResultReady(const QString& algorithmName,
                             const QString& outputCurveId);

private:
    void handleAlgorithmResult(IThermalAlgorithm* algorithm,
                              ThermalCurve* inputCurve,
                              const QVariant& result);

    QMap<QString, IThermalAlgorithm*> m_algorithms;
    CurveManager* m_curveManager;
};
```

**执行流程**：
1. 验证上下文中的 activeCurve
2. 调用 `algorithm->prepareContext(context)` 验证数据完整性
3. 如果就绪，调用 `algorithm->executeWithContext(context)` 执行计算
4. 根据结果类型处理输出（创建新曲线、显示数值等）
5. 设置父子关系、信号类型、辅助标记等
6. 发射 algorithmResultReady 信号

### AlgorithmCoordinator - 算法执行流程协调器

**AlgorithmCoordinator** 负责调度算法执行流程，包括参数收集、点选请求、算法执行、结果通知：

```cpp
class AlgorithmCoordinator : public QObject {
    Q_OBJECT

public:
    void handleAlgorithmTriggered(const QString& algorithmName);
    void handlePointSelectionResult(const QVector<QPointF>& points);
    void handleParameterDialogResult(const QVariantMap& parameters);

signals:
    // 请求信号
    void requestPointSelection(const QString& algorithmName,
                              const QString& curveId,
                              int requiredPoints,
                              const QString& hint);
    void requestParameterDialog(const QString& algorithmName,
                               const AlgorithmDescriptor& descriptor);

private:
    void executeAlgorithm(const QString& algorithmName);

    struct PendingRequest {
        QString algorithmName;
        QVariantMap parameters;
        QVector<QPointF> selectedPoints;
        QString curveId;
    };
    PendingRequest m_pending;

    AlgorithmManager* m_algorithmManager;
    AlgorithmContext* m_algorithmContext;
    CurveManager* m_curveManager;
};
```

**流程编排**：
```
handleAlgorithmTriggered()
  ↓
检查算法描述符
  ↓
需要参数？ → requestParameterDialog
  ↓
需要选点？ → requestPointSelection
  ↓
executeAlgorithm()
  ↓
清空上下文旧数据
  ↓
设置 activeCurve/参数/选点到上下文
  ↓
AlgorithmManager::executeWithContext()
```

**特点**：
- ⚠️ **实验性组件**：主要用于未来的交互式算法（基线、峰面积等）
- 当前简单算法（微分、积分、移动平均）通过此组件统一调度
- 提供扩展性：支持参数对话框、点选交互、多步骤流程

### ProjectTreeManager - 项目树管理器

ProjectTreeManager 管理树形视图结构，维护曲线的父子关系层级：

```cpp
class ProjectTreeManager : public QObject {
    Q_OBJECT

public:
    explicit ProjectTreeManager(CurveManager* curveManager);

    QStandardItemModel* model() { return m_model; }

    // 状态管理
    void setCurveChecked(const QString& curveId, bool checked);
    void setActiveCurve(const QString& curveId);
    QString getCurveId(const QModelIndex& index) const;

    void refresh();  // 完全重建树形结构

signals:
    void curveCheckStateChanged(const QString& curveId, bool checked);
    void curveItemClicked(const QString& curveId);
    void activeCurveIndexChanged(const QModelIndex& index);

private slots:
    void onCurveAdded(const QString& curveId);
    void onCurveRemoved(const QString& curveId);
    void onCurvesCleared();
    void onCurveItemClicked(const QModelIndex& index);
    void onItemChanged(QStandardItem* item);

private:
    void buildTree();

    // buildTree 辅助函数（函数拆分优化）
    void collectProjectNames(const QMap<QString, ThermalCurve>&, QSet<QString>&);
    void createProjectNodes(const QSet<QString>&, QMap<QString, QStandardItem*>&);
    void addTopLevelCurves(const QMap<QString, ThermalCurve>&,
                           const QMap<QString, QStandardItem*>&,
                           QMap<QString, QStandardItem*>&);
    void addChildCurves(const QMap<QString, ThermalCurve>&,
                        QMap<QString, QStandardItem*>&,
                        QSet<QString>&);
    void handleOrphanCurves(const QMap<QString, ThermalCurve>&,
                           const QMap<QString, QStandardItem*>&,
                           const QSet<QString>&,
                           QMap<QString, QStandardItem*>&);

    CurveManager* m_curveManager;
    QStandardItemModel* m_model;
};
```

**树构建流程**（已拆分为5个小函数）：
1. `collectProjectNames()` - 收集项目名称
2. `createProjectNodes()` - 创建项目节点
3. `addTopLevelCurves()` - 添加顶层曲线（无父曲线）
4. `addChildCurves()` - 添加子曲线（支持多层嵌套）
5. `handleOrphanCurves()` - 处理孤儿曲线（父曲线不存在）

**特殊处理**：
- 强绑定曲线（如基线）不在树中显示
- 父子关系自动维护，支持多层嵌套
- Checkbox 状态管理，控制曲线可见性

### HistoryManager - 历史管理器（待完善）

HistoryManager实现了操作历史管理和撤销重做功能：

```cpp
class HistoryManager : public QObject {
    Q_OBJECT

public:
    void execute(ICommand* command);
    void undo();
    void redo();
    bool canUndo() const;
    bool canRedo() const;

signals:
    void historyChanged();

private:
    QStack<ICommand*> m_undoStack;
    QStack<ICommand*> m_redoStack;
    int m_maxHistorySize = 100;
};
```

**命令封装**：
- `AddCurveCommand`：添加曲线命令
- `AlgorithmCommand`：算法执行命令
- `BaselineCommand`：基线校正命令

## 五、表示层 (Presentation Layer)

表示层是用户直接接触的部分，它负责信息的展示和用户交互的响应，但不包含业务逻辑。

### MainWindow - 主窗口

MainWindow 是应用程序的主窗口，负责整体布局和菜单管理：

```cpp
class MainWindow : public QMainWindow {
    Q_OBJECT

public:
    // 接收预构造的组件，只负责布局
    void setPlotWidget(ChartView* plotWidget);
    void setProjectExplorer(ProjectExplorerView* explorerView);

    // 菜单和工具栏创建
    void createMenus();
    void createToolBars();

signals:
    // 用户操作信号（不包含业务逻辑）
    void openFileRequested();
    void saveProjectRequested();
    void algorithmRequested(const QString& algorithmName);
    void undoRequested();
    void redoRequested();

private:
    ChartView* m_plotWidget;
    ProjectExplorerView* m_projectExplorer;

    QMenuBar* m_menuBar;
    QToolBar* m_toolBar;
    QStatusBar* m_statusBar;
};
```

**职责**：
- 管理整体布局（菜单、工具栏、停靠面板）
- 接收预构造的 ChartView 与 ProjectExplorerView
- **仅负责布局与信号转发**，不包含业务逻辑
- 所有用户操作发射信号，由 Controller 处理

### ChartView - 图表视图

ChartView 是专门用于显示热分析曲线的图表组件，基于 Qt Charts 实现：

```cpp
class ChartView : public QWidget {
    Q_OBJECT

public:
    // 曲线管理
    void addCurve(const ThermalCurve& curve);
    void updateCurve(const ThermalCurve& curve);
    void removeCurve(const QString& curveId);
    void clearCurves();

    // 曲线状态
    void setCurveVisible(const QString& curveId, bool visible);
    void highlightCurve(const QString& curveId);  // 加粗显示

    // 坐标轴管理
    void rescaleAxes();

    // 交互模式
    void setInteractionMode(InteractionMode mode);

    // ========== 活动算法状态机 ==========
    void startAlgorithmInteraction(const QString& algorithmName,
                                   const QString& displayName,
                                   int requiredPoints,
                                   const QString& hint,
                                   const QString& curveId);
    void cancelAlgorithmInteraction();

    InteractionState interactionState() const;
    const ActiveAlgorithmInfo& activeAlgorithm() const;

signals:
    void curveSelected(const QString& curveId);
    void algorithmInteractionCompleted(const QString& algorithmName,
                                      const QVector<QPointF>& points);
    void interactionStateChanged(int newState);

private:
    // 算法交互辅助函数（函数拆分优化）
    void clearInteractionState();
    QValueAxis* findYAxisForCurve(const QString& curveId);
    void setupSelectedPointsSeries(QValueAxis* targetYAxis);
    void transitionToState(InteractionState newState);
    QPointF convertToValueCoordinates(const QPointF& chartViewPos);
    void completePointSelection();

    // 曲线系列管理
    QLineSeries* seriesForCurve(const QString& curveId) const;
    QLineSeries* createSeriesForCurve(const ThermalCurve& curve) const;
    void populateSeriesWithCurveData(QLineSeries*, const ThermalCurve&) const;

    // Y轴智能分配
    QValueAxis* ensureYAxisForCurve(const ThermalCurve& curve);

    QChartView* m_chartView;
    QLineSeries* m_selectedSeries;  // 当前选中的曲线
    QScatterSeries* m_selectedPointsSeries;  // 选点高亮系列

    QHash<QString, QLineSeries*> m_idToSeries;
    QHash<QLineSeries*, QString> m_seriesToId;

    QValueAxis* m_axisX;
    QValueAxis* m_axisY_primary;    // 主Y轴（左）
    QValueAxis* m_axisY_secondary;  // 次Y轴（右）

    // 交互模式
    InteractionMode m_mode = InteractionMode::View;

    // 活动算法状态机
    InteractionState m_interactionState = InteractionState::Idle;
    ActiveAlgorithmInfo m_activeAlgorithm;
    QVector<QPointF> m_selectedPoints;
};
```

**核心功能**：

1. **多曲线显示**：
   - 每条曲线对应一个 QLineSeries
   - 通过 curveId 进行管理
   - 支持不同颜色和样式

2. **Y轴智能分配**（3级优先级）：
   ```cpp
   QValueAxis* ChartView::ensureYAxisForCurve(const ThermalCurve& curve) {
       // Priority 1: Derivative MUST use secondary Y-axis
       if (curve.signalType() == SignalType::Derivative) {
           return m_axisY_secondary;
       }

       // Priority 2: Auxiliary curves inherit parent's Y-axis
       if (curve.isAuxiliaryCurve() && !curve.parentId().isEmpty()) {
           QLineSeries* parentSeries = seriesForCurve(curve.parentId());
           // 找到父曲线的Y轴并继承
       }

       // Priority 3: Default to primary Y-axis
       return m_axisY_primary;
   }
   ```

3. **活动算法状态机**（核心交互管理）：

   **状态定义**：
   ```cpp
   enum class InteractionState {
       Idle,              // 空闲：无活动算法
       WaitingForPoints,  // 等待用户选点
       PointsCompleted,   // 选点完成，准备执行
       Executing          // 算法执行中
   };

   struct ActiveAlgorithmInfo {
       QString name;                // 算法名称
       QString displayName;         // 显示名称
       int requiredPointCount = 0;  // 需要的点数
       QString hint;                // 交互提示

       bool isValid() const { return !name.isEmpty(); }
       void clear();
   };
   ```

   **状态机流程**：
   ```
   用户选择算法（如"基线校正"）
     ↓
   startAlgorithmInteraction()
     - 清空交互状态
     - 查找目标曲线Y轴
     - 配置选点高亮系列
     - 设置活动算法信息
     - 状态转换: Idle → WaitingForPoints
     - 切换到 Pick 模式（十字光标）
     ↓
   用户在图表上点击选点
     ↓
   handlePointSelectionClick()
     - 转换坐标
     - 添加点到 m_selectedPoints
     - 在图表上显示红色高亮点
     - 检查是否收集够所需点数
     ↓
   收集够点数 → completePointSelection()
     - 状态转换: WaitingForPoints → PointsCompleted
     - 发射 algorithmInteractionCompleted() 信号
     - 清空活动算法信息
     - 状态转换: PointsCompleted → Idle
     - 切换回 View 模式
   ```

   **自动执行特性**：
   - 用户完成选点后**无需手动点击"执行"按钮**
   - 状态机自动检测完成并触发算法执行
   - 提供清晰的进度反馈

4. **曲线选中高亮**：
   - 点击曲线后线宽变为3（加粗）
   - 未选中曲线线宽为1
   - 通过 `highlightCurve()` 方法控制

5. **交互模式**：
   ```cpp
   enum class InteractionMode {
       View,  // 视图模式：查看、缩放、平移
       Pick   // 拾取模式：选择数据点、测量
   };
   ```
   - View 模式：禁用 RubberBand，避免意外缩放
   - Pick 模式：十字光标，用于选点

**函数拆分优化**（单一职责）：
- `startAlgorithmInteraction`: 80行 → 25行（减少68%）
- `handlePointSelectionClick`: 68行 → 35行（减少48%）
- 新增6个辅助函数，每个函数只做一件事

### ProjectExplorerView - 项目浏览器

ProjectExplorerView 是项目浏览器视图，树形结构展示曲线及其衍生关系：

```cpp
class ProjectExplorerView : public QWidget {
    Q_OBJECT

public:
    void setModel(QAbstractItemModel* model);
    QTreeView* treeView() const;

signals:
    void curveItemClicked(const QModelIndex& index);
    void deleteActionClicked();

private:
    QTreeView* m_treeView;
};
```

**特点**：
- 使用 QTreeView + QStandardItemModel
- 模型由 ProjectTreeManager 提供
- 支持 Checkbox 控制曲线可见性
- 单击选中曲线，触发图表加粗和浏览器高亮
- 强绑定曲线（如基线）不显示在树中

### CurveViewController - 视图控制器

CurveViewController 负责协调 ChartView、ProjectExplorerView、ProjectTreeManager 的状态同步：

```cpp
class CurveViewController : public QObject {
    Q_OBJECT

public:
    explicit CurveViewController(CurveManager* curveManager,
                                ChartView* plotWidget,
                                ProjectTreeManager* treeManager,
                                ProjectExplorerView* projectExplorer);

    // 视图管理接口
    void setCurveVisible(const QString& curveId, bool visible);
    void highlightCurve(const QString& curveId);
    void updateAllCurves();

private slots:
    // 响应 CurveManager 信号
    void onCurveAdded(const QString& curveId);
    void onCurveRemoved(const QString& curveId);
    void onCurveDataChanged(const QString& curveId);
    void onActiveCurveChanged(const QString& curveId);
    void onCurvesCleared();

    // 响应 ChartView 信号
    void onCurveSelected(const QString& curveId);

    // 响应 ProjectTreeManager 信号
    void onCurveCheckStateChanged(const QString& curveId, bool checked);
    void onCurveItemClicked(const QString& curveId);
    void onActiveCurveIndexChanged(const QModelIndex& index);

private:
    // 验证辅助函数（函数拆分优化）
    bool validateComponents() const;
    bool validatePlotWidget() const;
    bool validateCurveId(const QString& curveId) const;

    CurveManager* m_curveManager;
    ChartView* m_plotWidget;
    ProjectTreeManager* m_treeManager;
    ProjectExplorerView* m_projectExplorer;
};
```

**职责**：
- 协调多个视图的状态同步
- 管理曲线可见性、选择、高亮状态
- 响应 CurveManager 的数据变化信号
- **不包含业务逻辑**，只负责视图协调

**关键协调逻辑**：

1. **曲线选中的双重视觉反馈**：
   ```cpp
   void onActiveCurveChanged(const QString& curveId) {
       // 1. 图表中加粗显示
       highlightCurve(curveId);

       // 2. 项目浏览器中高亮选中项
       m_treeManager->setActiveCurve(curveId);
   }
   ```

2. **强绑定曲线联动**：
   ```cpp
   void onCurveCheckStateChanged(const QString& curveId, bool checked) {
       setCurveVisible(curveId, checked);

       // 强绑定子曲线联动逻辑
       for (const ThermalCurve& childCurve : allCurves) {
           if (childCurve.isStronglyBound() &&
               childCurve.parentId() == curveId) {
               setCurveVisible(childCurve.id(), checked);
           }
       }
   }
   ```

**函数拆分优化**：
- 新增3个验证函数，消除重复验证代码
- 重构6个事件处理函数，使用统一验证

### MainController - 主控制器（待完善）

MainController 作为主控制器，协调整个应用的业务流程：

```cpp
class MainController : public QObject {
    Q_OBJECT

public:
    explicit MainController(CurveManager* curveManager,
                           AlgorithmCoordinator* algorithmCoordinator,
                           MainWindow* mainWindow);

private slots:
    void onOpenFileRequested();
    void onSaveProjectRequested();
    void onAlgorithmRequested(const QString& algorithmName);
    void onUndoRequested();
    void onRedoRequested();

    void onCoordinatorRequestPointSelection(const QString& algorithmName,
                                           const QString& curveId,
                                           int requiredPoints,
                                           const QString& hint);

private:
    CurveManager* m_curveManager;
    AlgorithmCoordinator* m_algorithmCoordinator;
    MainWindow* m_mainWindow;
    ChartView* m_plotWidget;
};
```

**职责**：
- 连接 MainWindow 的信号到业务逻辑
- 协调文件打开、项目保存等流程
- 转发算法请求到 AlgorithmCoordinator
- 连接 Coordinator 的点选请求到 ChartView

## 六、层间通信机制

四层架构的有效运作依赖于明确的通信机制。

### 信号槽的异步通信

Qt的信号槽机制是层间通信的主要方式，特别是在表示层和应用层之间。

**典型信号流**：

1. **导入数据流**：
   ```
   用户选择文件
     → MainWindow::openFileRequested
     → MainController::onOpenFileRequested
     → FileReaderFactory::createReader
     → TextFileReader::read
     → ThermalCurve（创建）
     → CurveManager::addCurve
     → curveAdded 信号
     → ├─ ProjectTreeManager::onCurveAdded（更新树）
       └─ CurveViewController::onCurveAdded（显示图表）
   ```

2. **算法执行流（上下文驱动）**：
   ```
   用户选择算法
     → MainWindow::algorithmRequested
     → MainController::onAlgorithmRequested
     → AlgorithmCoordinator::handleAlgorithmTriggered
     → ├─ 需要参数？→ requestParameterDialog
       ├─ 需要选点？→ requestPointSelection
       │   → MainController::onCoordinatorRequestPointSelection
       │   → ChartView::startAlgorithmInteraction
       │   → 用户在图表上点选
       │   → ChartView::algorithmInteractionCompleted
       │   → AlgorithmCoordinator::handlePointSelectionResult
       └─ executeAlgorithm
           → 清空上下文
           → 设置 activeCurve/参数/选点到上下文
           → AlgorithmManager::executeWithContext
             → algorithm->prepareContext（验证）
             → algorithm->executeWithContext（执行）
             → 创建新曲线
             → 设置 parentId/signalType/辅助标记
           → CurveManager::addCurve
           → curveAdded 信号
           → ├─ ProjectTreeManager（添加为子节点）
             ├─ ChartView（显示新曲线）
             └─ CurveViewController（同步状态）
   ```

3. **活动算法状态机流程**：
   ```
   用户选择算法
     → AlgorithmCoordinator::requestPointSelection
     → MainController::onCoordinatorRequestPointSelection
     → ChartView::startAlgorithmInteraction
       ├─ 状态转换: Idle → WaitingForPoints
       ├─ interactionStateChanged 信号
       └─ 切换到 Pick 模式（十字光标）
     ↓
   用户点击选点
     → ChartView::handlePointSelectionClick
       ├─ 添加点到 m_selectedPoints
       ├─ 检查是否收集够所需点数
       └─ completePointSelection
           ├─ 状态转换: PointsCompleted → Idle
           ├─ algorithmInteractionCompleted 信号
           └─ 切换回 View 模式
     ↓
   MainController 接收信号
     → AlgorithmCoordinator::handlePointSelectionResult
     → 算法执行流程继续
   ```

### 直接调用的同步操作

对于简单的数据访问和业务调用，使用直接的方法调用：

- Controller 调用 Manager 的方法获取数据
- Manager 调用 Domain 对象的方法读写数据
- 用于不耗时的操作（获取曲线、设置数据等）

### 依赖注入的解耦策略

系统采用依赖注入思想，通过 **ApplicationContext** 统一管理：

```cpp
// ApplicationContext 在 initialize() 中按正确顺序创建实例
// 然后通过构造函数注入依赖

CurveViewController controller(
    curveManager,           // 注入
    chartView,             // 注入
    projectTreeManager,    // 注入
    projectExplorerView    // 注入
);
```

**优势**：
- 降低耦合，组件间通过接口通信
- 易于测试，可注入 Mock 对象
- 清晰的依赖关系，避免循环依赖

## 七、架构的价值体现

这个四层架构设计为热分析软件带来了多方面的价值。

### 开发效率

清晰的模块划分使得团队可以并行开发不同的层次。UI设计师可以专注于表示层的界面设计，算法工程师可以专注于基础设施层的算法实现，而不必相互等待。每个模块有明确的接口契约，只要接口稳定，内部实现可以独立演进。

### 代码质量

分层架构强制实施了关注点分离：
- UI 代码中不会出现复杂的算法逻辑
- 算法代码中不会涉及界面元素
- 业务逻辑集中在应用层便于审查和测试

**实际成果**：
- 通过函数拆分，代码行数减少约150行
- 函数复杂度显著降低（平均减少50%）
- 新增14个辅助函数，每个函数只做一件事
- 代码可读性和可维护性大幅提升

### 可扩展性

架构的开放封闭原则体现在多个地方：

1. **新增文件格式**：
   - 实现 IFileReader 接口
   - 注册到 CurveManager
   - 无需修改现有代码

2. **新增算法**：
   - 实现 IThermalAlgorithm 接口
   - 实现 prepareContext 和 executeWithContext
   - 注册到 AlgorithmManager
   - 自动支持上下文驱动执行

3. **新增UI功能**：
   - 在表示层添加组件
   - 连接到 Controller
   - 利用现有信号槽机制

### 可测试性

每一层都可以独立测试：

- **领域层**：单元测试验证业务规则（数据模型、枚举逻辑）
- **基础设施层**：数学测试用例验证算法正确性
- **应用层**：Mock 依赖进行业务逻辑测试
- **表示层**：集成测试验证交互流程

### 维护性

架构的分层清晰地指明了修改点：

- 算法性能问题 → 定位到基础设施层
- 业务流程问题 → 定位到应用层
- 界面体验问题 → 定位到表示层

**实际维护改进**：
- 修复算法交互后状态未清理问题（清晰定位到 ChartView）
- 修复点击缩放问题（RubberBand 配置在 ChartView）
- 函数拆分使得问题定位更加精确

## 八、架构演进与优化

### 已完成的优化

1. **统一初始化机制**（ApplicationContext）
   - 解决依赖关系混乱问题
   - 集中管理对象生命周期

2. **上下文驱动算法执行**（AlgorithmContext）
   - 消除参数传递的复杂性
   - 统一数据源，提供追踪能力
   - 两阶段执行（prepareContext + executeWithContext）

3. **活动算法状态机**（ChartView）
   - 管理用户交互流程
   - 自动触发算法执行
   - 清晰的状态转换

4. **函数拆分优化**
   - ChartView：新增6个辅助函数
   - ProjectTreeManager：新增5个阶段函数
   - CurveViewController：新增3个验证函数
   - 代码复杂度大幅降低

5. **双枚举分离设计**
   - InstrumentType + SignalType + PlotStyle
   - 语义清晰，易于扩展
   - 算法通用化

### 待实现的功能

1. **命令模式和历史管理**（Phase 1）
   - 完善 HistoryManager 和命令模式集成
   - 实现所有修改操作的 Command 封装

2. **项目管理**（Phase 2）
   - ProjectManager 多项目支持
   - 项目保存/加载功能
   - 曲线导出和图表导出

3. **算法交互**（Phase 3）
   - 算法参数对话框（基于 AlgorithmDescriptor）
   - 峰值检测、面积计算、归一化

4. **高级功能**（Phase 4）
   - 动力学分析
   - 批处理和脚本系统
   - 插件系统

## 总结

这个四层架构设计为热分析软件提供了坚实的基础：

✅ **清晰的层次划分**：每一层职责明确，边界清晰
✅ **单一职责原则**：通过函数拆分，每个函数专注一个小功能
✅ **上下文驱动**：统一的算法执行模式，零参数传递
✅ **状态机管理**：清晰的交互流程，自动化执行
✅ **可扩展性**：通过接口抽象，轻松添加新功能
✅ **可维护性**：代码优化减少150行，复杂度降低50%

这不是为了架构而架构，而是基于热分析领域的实际需求和软件工程的最佳实践形成的。它为构建一个专业、稳定、可扩展的热分析软件提供了坚实的基础。
