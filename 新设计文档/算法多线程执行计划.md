# ç®—æ³•å¤šçº¿ç¨‹æ‰§è¡Œè®¡åˆ’

## 1. é¡¹ç›®æ¦‚è¿°

### 1.0 è®¾è®¡å®¡æŸ¥å’Œé—®é¢˜ä¿®å¤ ğŸ”§

**v1.1 ä¿®å¤çš„é—®é¢˜** (ç¬¬ä¸€è½®å®¡æŸ¥):

| é—®é¢˜ | ä¼˜å…ˆçº§ | å½±å“ | ä¿®å¤æ–¹æ¡ˆ |
|------|--------|------|----------|
| AlgorithmTask åŒé‡é‡Šæ”¾ | ğŸ”´ é«˜ | å´©æºƒã€åŒé‡åˆ é™¤ | ä½¿ç”¨ QSharedPointerï¼Œæ˜ç¡®æ‰€æœ‰æƒ |
| prepareContext() é‡å¤æ‰§è¡Œ | ğŸ”´ é«˜ | éçº¿ç¨‹å®‰å…¨çš„æ•°æ®ä¿®æ”¹ | åªåœ¨ä¸»çº¿ç¨‹è°ƒç”¨ï¼ŒWorker è·³è¿‡ |
| çº¿ç¨‹æ± æ»¡æ—¶ä»»åŠ¡ä¸¢å¤± | ğŸŸ¡ ä¸­ | ç”¨æˆ·è¯·æ±‚é™é»˜å¤±è´¥ | æ·»åŠ ä»»åŠ¡é˜Ÿåˆ—æœºåˆ¶ |
| ProgressReporter æœªè®¾ç½® | ğŸŸ¡ ä¸­ | è¿›åº¦æŠ¥å‘Šæ— æ³•å·¥ä½œ | Worker è°ƒç”¨ setProgressReporter |
| AlgorithmContext å¹¶å‘è®¿é—® | ğŸŸ¡ ä¸­ | ç«æ€æ¡ä»¶ | ä¸ºæ¯ä¸ªä»»åŠ¡åˆ›å»ºä¸Šä¸‹æ–‡å¿«ç…§ |

**v1.2 ä¿®å¤çš„é—®é¢˜** (ç¬¬äºŒè½®å®¡æŸ¥):

| é—®é¢˜ | ä¼˜å…ˆçº§ | å½±å“ | ä¿®å¤æ–¹æ¡ˆ |
|------|--------|------|----------|
| é˜Ÿåˆ—åˆ†é…çš„ä¿¡å·è¿æ¥ç¼ºå£ | ğŸ”´ é«˜ | Workeræœªè¿æ¥ä¿¡å·ã€æ˜ å°„ä¸¢å¤± | é˜Ÿåˆ—ä¸Šç§»åˆ° AlgorithmManager |
| å–æ¶ˆé€»è¾‘æœªè½åœ° | ğŸŸ¡ ä¸­ | ç”¨æˆ·æ— æ³•å–æ¶ˆä»»åŠ¡ | å®ç° cancelTask() å’Œé˜Ÿåˆ—ç§»é™¤ |
| ä¸Šä¸‹æ–‡å¿«ç…§è¯­ä¹‰æ¨¡ç³Š | ğŸŸ¡ ä¸­ | å¯èƒ½å…±äº«å¯å˜æ•°æ® | æ˜ç¡®æ·±æ‹·è´è¯­ä¹‰å’Œçº¦æŸ |
| çº¿ç¨‹æ•°ç¡¬ç¼–ç  | ğŸŸ¢ ä½ | æ— æ³•é€‚é…ä¸åŒç¡¬ä»¶ | é…ç½®åŒ– MAX_THREADS |

**æ„Ÿè°¢**: æ„Ÿè°¢ä»£ç å®¡æŸ¥å‘ç°è¿™äº›å…³é”®é—®é¢˜ï¼

---

### 1.1 ç›®æ ‡
å°†æ‰€æœ‰ç®—æ³•è®¡ç®—ä»UIçº¿ç¨‹ç§»åˆ°å·¥ä½œçº¿ç¨‹ï¼Œé˜²æ­¢é•¿æ—¶é—´è®¡ç®—é˜»å¡ç•Œé¢ã€‚

### 1.2 è®¾è®¡åŸåˆ™
- âœ… **éé˜»å¡æ‰§è¡Œ**: ç®—æ³•åœ¨åå°çº¿ç¨‹æ‰§è¡Œï¼ŒUIä¿æŒå“åº”
- âœ… **è¿›åº¦åé¦ˆ**: æ”¯æŒæ˜¾ç¤ºè®¡ç®—è¿›åº¦ï¼ˆç‰¹åˆ«æ˜¯é•¿æ—¶é—´ç®—æ³•ï¼‰
- âœ… **å¯å–æ¶ˆæ€§**: ç”¨æˆ·å¯ä»¥ä¸­é€”å–æ¶ˆè®¡ç®—
- âœ… **é”™è¯¯éš”ç¦»**: çº¿ç¨‹å¼‚å¸¸ä¸å½±å“ä¸»çº¿ç¨‹
- âœ… **ä¿æŒæ¶æ„ä¸€è‡´æ€§**: ä¸ç ´åç°æœ‰çš„ä¸Šä¸‹æ–‡é©±åŠ¨æ¨¡å¼
- âœ… **å‘åå…¼å®¹**: ä¿ç•™åŒæ­¥æ‰§è¡Œæ¥å£ï¼ˆç”¨äºæµ‹è¯•ï¼‰

### 1.3 æŠ€æœ¯é€‰å‹

**é‡‡ç”¨æ–¹æ¡ˆ**: Qt Worker Object Pattern (æ¨è)

```
UIçº¿ç¨‹ (ä¸»çº¿ç¨‹)
  â†“
AlgorithmManager::executeAsync()
  â†“ å‘é€ä¿¡å·
AlgorithmWorker (åœ¨å·¥ä½œçº¿ç¨‹ä¸­)
  â†“ æ‰§è¡Œç®—æ³•
algorithm->executeWithContext(context)
  â†“ å‘é€ç»“æœä¿¡å·
AlgorithmManager::onWorkerFinished()
  â†“ å¤„ç†ç»“æœ
emit algorithmResultReady(...)
```

**ä¸ºä»€ä¹ˆä¸ç»§æ‰¿QThread**:
- Qtå®˜æ–¹æ¨èä½¿ç”¨Worker Objectæ¨¡å¼
- æ›´çµæ´»çš„çº¿ç¨‹å¤ç”¨ï¼ˆçº¿ç¨‹æ± ï¼‰
- æ›´å¥½çš„ä¿¡å·æ§½é›†æˆ
- é¿å…QThreadçš„ç”Ÿå‘½å‘¨æœŸç®¡ç†é—®é¢˜

---

## 2. æ¶æ„è®¾è®¡

### 2.1 æ ¸å¿ƒç±»è®¾è®¡

#### 2.1.1 AlgorithmTask (ä»»åŠ¡å°è£…)

```cpp
// src/domain/algorithm/algorithm_task.h
#ifndef ALGORITHM_TASK_H
#define ALGORITHM_TASK_H

#include <QString>
#include <QUuid>
#include <QDateTime>
#include <QSharedPointer>
#include "algorithm_context.h"

/**
 * @brief ç®—æ³•ä»»åŠ¡å°è£…
 *
 * å°è£…å•æ¬¡ç®—æ³•æ‰§è¡Œçš„æ‰€æœ‰ä¿¡æ¯ï¼ˆç®—æ³•åã€ä¸Šä¸‹æ–‡ã€ä»»åŠ¡IDï¼‰
 *
 * ã€æ‰€æœ‰æƒç®¡ç†ã€‘ï¼š
 * - ä½¿ç”¨ QSharedPointer ç®¡ç†ä»»åŠ¡ç”Ÿå‘½å‘¨æœŸï¼Œé¿å…åŒé‡é‡Šæ”¾
 * - AlgorithmManager å’Œ AlgorithmWorker å…±äº«æ‰€æœ‰æƒ
 * - ä¸Šä¸‹æ–‡ä¸ºä»»åŠ¡ä¸“å±å¿«ç…§ï¼ˆæ·±æ‹·è´ï¼‰ï¼Œä¸ä¸å…¶ä»–ä»»åŠ¡å…±äº«
 */
class AlgorithmTask {
public:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param algorithmName ç®—æ³•åç§°
     * @param contextSnapshot ä¸Šä¸‹æ–‡å¿«ç…§ï¼ˆå¿…é¡»æ˜¯ç‹¬ç«‹æ‹·è´ï¼‰
     */
    AlgorithmTask(const QString& algorithmName, AlgorithmContext* contextSnapshot)
        : m_taskId(QUuid::createUuid().toString())
        , m_algorithmName(algorithmName)
        , m_contextSnapshot(contextSnapshot)
        , m_createdAt(QDateTime::currentDateTime())
        , m_isCancelled(false)
    {}

    ~AlgorithmTask() {
        // æ¸…ç†ä¸Šä¸‹æ–‡å¿«ç…§ï¼ˆå¦‚æœæœªè¢«å¤–éƒ¨ç®¡ç†ï¼‰
        delete m_contextSnapshot;
    }

    QString taskId() const { return m_taskId; }
    QString algorithmName() const { return m_algorithmName; }
    AlgorithmContext* context() const { return m_contextSnapshot; }
    QDateTime createdAt() const { return m_createdAt; }

    bool isCancelled() const { return m_isCancelled; }
    void cancel() { m_isCancelled = true; }

private:
    QString m_taskId;                      // ä»»åŠ¡å”¯ä¸€ID
    QString m_algorithmName;               // ç®—æ³•åç§°
    AlgorithmContext* m_contextSnapshot;   // ä¸Šä¸‹æ–‡å¿«ç…§ï¼ˆä»»åŠ¡ç‹¬å ï¼‰
    QDateTime m_createdAt;                 // åˆ›å»ºæ—¶é—´
    bool m_isCancelled;                    // æ˜¯å¦è¢«å–æ¶ˆ
};

// æ™ºèƒ½æŒ‡é’ˆç±»å‹å®šä¹‰
using AlgorithmTaskPtr = QSharedPointer<AlgorithmTask>;

#endif // ALGORITHM_TASK_H
```

#### 2.1.2 IProgressReporter (è¿›åº¦æŠ¥å‘Šæ¥å£)

```cpp
// src/domain/algorithm/i_progress_reporter.h
#ifndef I_PROGRESS_REPORTER_H
#define I_PROGRESS_REPORTER_H

#include <QString>

/**
 * @brief è¿›åº¦æŠ¥å‘Šæ¥å£
 *
 * ç®—æ³•å¯ä»¥é€‰æ‹©å®ç°æ­¤æ¥å£æ¥æŠ¥å‘Šæ‰§è¡Œè¿›åº¦
 */
class IProgressReporter {
public:
    virtual ~IProgressReporter() = default;

    /**
     * @brief æŠ¥å‘Šè¿›åº¦
     * @param percentage è¿›åº¦ç™¾åˆ†æ¯” (0-100)
     * @param message è¿›åº¦æè¿°
     */
    virtual void reportProgress(int percentage, const QString& message = "") = 0;

    /**
     * @brief æ£€æŸ¥æ˜¯å¦è¢«è¯·æ±‚å–æ¶ˆ
     * @return true å¦‚æœåº”è¯¥å–æ¶ˆæ‰§è¡Œ
     */
    virtual bool isCancellationRequested() const = 0;
};

#endif // I_PROGRESS_REPORTER_H
```

#### 2.1.3 AlgorithmWorker (å·¥ä½œçº¿ç¨‹å¯¹è±¡)

```cpp
// src/application/algorithm/algorithm_worker.h
#ifndef ALGORITHM_WORKER_H
#define ALGORITHM_WORKER_H

#include <QObject>
#include <QVariant>
#include "algorithm_task.h"
#include "i_thermal_algorithm.h"
#include "i_progress_reporter.h"

/**
 * @brief ç®—æ³•å·¥ä½œçº¿ç¨‹å¯¹è±¡
 *
 * åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­æ‰§è¡Œç®—æ³•è®¡ç®—ï¼Œé€šè¿‡ä¿¡å·æ§½è¿”å›ç»“æœ
 */
class AlgorithmWorker : public QObject, public IProgressReporter {
    Q_OBJECT

public:
    explicit AlgorithmWorker(QObject* parent = nullptr);
    ~AlgorithmWorker() override;

    // IProgressReporter æ¥å£å®ç°
    void reportProgress(int percentage, const QString& message = "") override;
    bool isCancellationRequested() const override;

public slots:
    /**
     * @brief æ‰§è¡Œç®—æ³•ä»»åŠ¡
     * @param task ä»»åŠ¡å°è£…ï¼ˆæ™ºèƒ½æŒ‡é’ˆï¼Œå…±äº«æ‰€æœ‰æƒï¼‰
     * @param algorithm ç®—æ³•å®ä¾‹ï¼ˆå¿…é¡»æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼‰
     *
     * ã€å…³é”®ä¿®å¤ã€‘ï¼š
     * 1. ä½¿ç”¨ AlgorithmTaskPtr é¿å…åŒé‡é‡Šæ”¾
     * 2. è°ƒç”¨ algorithm->setProgressReporter(this) å¯ç”¨è¿›åº¦æŠ¥å‘Š
     * 3. è·³è¿‡ prepareContextï¼ˆå·²åœ¨ä¸»çº¿ç¨‹æ‰§è¡Œï¼‰
     */
    void executeTask(AlgorithmTaskPtr task, IThermalAlgorithm* algorithm);

    /**
     * @brief è¯·æ±‚å–æ¶ˆå½“å‰ä»»åŠ¡
     */
    void requestCancellation();

signals:
    /**
     * @brief ä»»åŠ¡å¼€å§‹æ‰§è¡Œ
     * @param taskId ä»»åŠ¡ID
     * @param algorithmName ç®—æ³•åç§°
     */
    void taskStarted(QString taskId, QString algorithmName);

    /**
     * @brief ä»»åŠ¡æ‰§è¡Œè¿›åº¦
     * @param taskId ä»»åŠ¡ID
     * @param percentage è¿›åº¦ç™¾åˆ†æ¯” (0-100)
     * @param message è¿›åº¦æè¿°
     */
    void taskProgress(QString taskId, int percentage, QString message);

    /**
     * @brief ä»»åŠ¡æ‰§è¡Œå®Œæˆ
     * @param taskId ä»»åŠ¡ID
     * @param result æ‰§è¡Œç»“æœ
     * @param elapsedMs æ‰§è¡Œæ—¶é•¿ï¼ˆæ¯«ç§’ï¼‰
     */
    void taskFinished(QString taskId, QVariant result, qint64 elapsedMs);

    /**
     * @brief ä»»åŠ¡æ‰§è¡Œå¤±è´¥
     * @param taskId ä»»åŠ¡ID
     * @param errorMessage é”™è¯¯ä¿¡æ¯
     */
    void taskFailed(QString taskId, QString errorMessage);

private:
    AlgorithmTaskPtr m_currentTask;  // å½“å‰æ‰§è¡Œçš„ä»»åŠ¡ï¼ˆæ™ºèƒ½æŒ‡é’ˆï¼‰
    bool m_cancellationRequested;    // æ˜¯å¦è¯·æ±‚å–æ¶ˆ
};

#endif // ALGORITHM_WORKER_H
```

```cpp
// src/application/algorithm/algorithm_worker.cpp
#include "algorithm_worker.h"
#include <QElapsedTimer>
#include <QDebug>

AlgorithmWorker::AlgorithmWorker(QObject* parent)
    : QObject(parent)
    , m_currentTask(nullptr)
    , m_cancellationRequested(false)
{}

AlgorithmWorker::~AlgorithmWorker() {
    // ä¸éœ€è¦ delete m_currentTaskï¼Œç”± QSharedPointer è‡ªåŠ¨ç®¡ç†
}

void AlgorithmWorker::executeTask(AlgorithmTaskPtr task, IThermalAlgorithm* algorithm) {
    if (!task || !algorithm) {
        emit taskFailed(task ? task->taskId() : "", "Invalid task or algorithm");
        return;
    }

    m_currentTask = task;
    m_cancellationRequested = false;

    QString taskId = task->taskId();
    QString algorithmName = task->algorithmName();

    qDebug() << "[Worker] Starting task" << taskId << "algorithm:" << algorithmName;
    emit taskStarted(taskId, algorithmName);

    QElapsedTimer timer;
    timer.start();

    try {
        // ğŸ”§ ä¿®å¤ï¼šè®¾ç½®è¿›åº¦æŠ¥å‘Šå™¨ï¼ˆä¹‹å‰é—æ¼ï¼‰
        algorithm->setProgressReporter(this);

        // ğŸ”§ ä¿®å¤ï¼šè·³è¿‡ prepareContextï¼ˆå·²åœ¨ä¸»çº¿ç¨‹æ‰§è¡Œï¼‰
        // prepareContext åªåœ¨ä¸»çº¿ç¨‹è°ƒç”¨ä¸€æ¬¡ï¼Œé¿å…é‡å¤æ‰§è¡Œå’Œçº¿ç¨‹å®‰å…¨é—®é¢˜
        // ä¸Šä¸‹æ–‡å·²ç»è¿‡éªŒè¯ä¸”ä¸ºä»»åŠ¡ä¸“å±å¿«ç…§ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨

        // æ£€æŸ¥å–æ¶ˆè¯·æ±‚
        if (isCancellationRequested()) {
            algorithm->setProgressReporter(nullptr); // æ¸…ç†
            emit taskFailed(taskId, "Task cancelled before execution");
            m_currentTask.clear(); // é‡Šæ”¾å…±äº«æŒ‡é’ˆ
            return;
        }

        // æ‰§è¡Œç®—æ³•
        QVariant result = algorithm->executeWithContext(task->context());

        // æ¸…ç†è¿›åº¦æŠ¥å‘Šå™¨
        algorithm->setProgressReporter(nullptr);

        // å†æ¬¡æ£€æŸ¥å–æ¶ˆè¯·æ±‚
        if (isCancellationRequested()) {
            emit taskFailed(taskId, "Task cancelled during execution");
            m_currentTask.clear();
            return;
        }

        qint64 elapsed = timer.elapsed();
        qDebug() << "[Worker] Task" << taskId << "completed in" << elapsed << "ms";
        emit taskFinished(taskId, result, elapsed);

    } catch (const std::exception& e) {
        algorithm->setProgressReporter(nullptr); // æ¸…ç†
        qWarning() << "[Worker] Task" << taskId << "failed with exception:" << e.what();
        emit taskFailed(taskId, QString("Exception: %1").arg(e.what()));
    } catch (...) {
        algorithm->setProgressReporter(nullptr); // æ¸…ç†
        qWarning() << "[Worker] Task" << taskId << "failed with unknown exception";
        emit taskFailed(taskId, "Unknown exception");
    }

    m_currentTask.clear(); // é‡Šæ”¾å…±äº«æŒ‡é’ˆï¼ˆä¸æ˜¯ deleteï¼‰
}

void AlgorithmWorker::requestCancellation() {
    qDebug() << "[Worker] Cancellation requested";
    m_cancellationRequested = true;
    if (m_currentTask) {
        m_currentTask->cancel();
    }
}

void AlgorithmWorker::reportProgress(int percentage, const QString& message) {
    if (m_currentTask) {
        emit taskProgress(m_currentTask->taskId(), percentage, message);
    }
}

bool AlgorithmWorker::isCancellationRequested() const {
    return m_cancellationRequested || (m_currentTask && m_currentTask->isCancelled());
}
```

#### 2.1.4 AlgorithmThreadManager (çº¿ç¨‹æ± ç®¡ç†å™¨)

```cpp
// src/application/algorithm/algorithm_thread_manager.h
#ifndef ALGORITHM_THREAD_MANAGER_H
#define ALGORITHM_THREAD_MANAGER_H

#include <QObject>
#include <QThread>
#include <QMap>
#include "algorithm_worker.h"

/**
 * @brief ç®—æ³•çº¿ç¨‹æ± ç®¡ç†å™¨
 *
 * å•ä¾‹æ¨¡å¼ï¼Œç®¡ç†å·¥ä½œçº¿ç¨‹çš„åˆ›å»ºã€å¤ç”¨å’Œé”€æ¯
 *
 * ã€èŒè´£ã€‘ï¼š
 * - âœ… åˆ›å»ºå’Œç®¡ç† Worker åŠå…¶æ‰€åœ¨çº¿ç¨‹
 * - âœ… è·Ÿè¸ª Worker çš„å¿™/é—²çŠ¶æ€
 * - âœ… çº¿ç¨‹å¤ç”¨å’Œç”Ÿå‘½å‘¨æœŸç®¡ç†
 * - âŒ ä¸è´Ÿè´£ä»»åŠ¡é˜Ÿåˆ—ï¼ˆç”± AlgorithmManager ç®¡ç†ï¼‰
 * - âŒ ä¸è´Ÿè´£ä¿¡å·è¿æ¥ï¼ˆç”± AlgorithmManager ç®¡ç†ï¼‰
 *
 * ã€v1.2 ä¿®å¤ã€‘ï¼š
 * - ç§»é™¤ä»»åŠ¡é˜Ÿåˆ—ï¼ˆä¸Šç§»åˆ° AlgorithmManagerï¼‰
 * - ç®€åŒ–èŒè´£ï¼šåªç®¡ç† Worker ç”Ÿå‘½å‘¨æœŸ
 * - é‡Šæ”¾æ—¶å‘å‡ºä¿¡å·ï¼Œé€šçŸ¥ Manager å¯å¤„ç†é˜Ÿåˆ—
 */
class AlgorithmThreadManager : public QObject {
    Q_OBJECT

public:
    static AlgorithmThreadManager* instance();

    /**
     * @brief è·å–ç©ºé—²çš„Workerï¼ˆå¯èƒ½è¿”å› nullptrï¼‰
     * @return Workerå¯¹è±¡å’Œå…¶æ‰€åœ¨çš„çº¿ç¨‹ï¼Œå¦‚æœæ‰€æœ‰Workerå¿™åˆ™è¿”å› {nullptr, nullptr}
     *
     * ã€è¿”å›å€¼ã€‘ï¼š
     * - {worker, thread}: æˆåŠŸè·å–ç©ºé—²Worker
     * - {nullptr, nullptr}: æ‰€æœ‰Workerå¿™ä¸”å·²è¾¾åˆ°æœ€å¤§çº¿ç¨‹æ•°
     *
     * ã€è°ƒç”¨è€…èŒè´£ã€‘ï¼š
     * - æ£€æŸ¥è¿”å›å€¼æ˜¯å¦ä¸º nullptr
     * - å¦‚æœä¸º nullptrï¼Œåº”å°†ä»»åŠ¡åŠ å…¥é˜Ÿåˆ—
     */
    QPair<AlgorithmWorker*, QThread*> acquireWorker();

    /**
     * @brief é‡Šæ”¾Workerï¼ˆæ ‡è®°ä¸ºç©ºé—²ï¼‰
     * @param worker è¦é‡Šæ”¾çš„Worker
     *
     * ã€ä¿¡å·ã€‘ï¼š
     * - å‘å‡º workerReleased() ä¿¡å·ï¼Œé€šçŸ¥ AlgorithmManager å¯å¤„ç†é˜Ÿåˆ—
     */
    void releaseWorker(AlgorithmWorker* worker);

    /**
     * @brief è·å–çº¿ç¨‹æ± çŠ¶æ€
     */
    int activeWorkerCount() const;
    int totalWorkerCount() const { return m_workers.size(); }
    int maxThreads() const { return m_maxThreads; }

    /**
     * @brief è®¾ç½®æœ€å¤§çº¿ç¨‹æ•°ï¼ˆè¿è¡Œæ—¶é…ç½®ï¼‰
     * @param maxThreads æœ€å¤§çº¿ç¨‹æ•°ï¼ˆ1-16ï¼‰
     *
     * ã€æ³¨æ„ã€‘ï¼šä¸ä¼šé”€æ¯å·²æœ‰çº¿ç¨‹ï¼Œåªå½±å“æ–°çº¿ç¨‹åˆ›å»º
     */
    void setMaxThreads(int maxThreads);

    /**
     * @brief å…³é—­æ‰€æœ‰çº¿ç¨‹ï¼ˆåº”ç”¨é€€å‡ºæ—¶è°ƒç”¨ï¼‰
     */
    void shutdown();

signals:
    void workerCountChanged(int activeCount, int totalCount);
    void workerReleased(); // ğŸ†• Worker é‡Šæ”¾ä¿¡å·ï¼Œé€šçŸ¥ Manager å¯å¤„ç†é˜Ÿåˆ—

private:
    explicit AlgorithmThreadManager(QObject* parent = nullptr);
    ~AlgorithmThreadManager() override;

    struct WorkerInfo {
        QThread* thread;
        AlgorithmWorker* worker;
        bool isBusy;
    };

    QList<WorkerInfo> m_workers;
    static AlgorithmThreadManager* s_instance;
    int m_maxThreads; // å¯é…ç½®çš„æœ€å¤§çº¿ç¨‹æ•°
};

#endif // ALGORITHM_THREAD_MANAGER_H
```

```cpp
// src/application/algorithm/algorithm_thread_manager.cpp
#include "algorithm_thread_manager.h"
#include <QThread>
#include <QDebug>

AlgorithmThreadManager* AlgorithmThreadManager::s_instance = nullptr;

AlgorithmThreadManager* AlgorithmThreadManager::instance() {
    if (!s_instance) {
        s_instance = new AlgorithmThreadManager();
    }
    return s_instance;
}

AlgorithmThreadManager::AlgorithmThreadManager(QObject* parent)
    : QObject(parent)
    , m_maxThreads(qMin(QThread::idealThreadCount(), 8)) // é»˜è®¤ï¼šCPUæ ¸å¿ƒæ•°ï¼Œæœ€å¤š8ä¸ª
{
    qDebug() << "[ThreadManager] Initialized with maxThreads:" << m_maxThreads
             << "(idealThreadCount:" << QThread::idealThreadCount() << ")";
}

AlgorithmThreadManager::~AlgorithmThreadManager() {
    shutdown();
}

QPair<AlgorithmWorker*, QThread*> AlgorithmThreadManager::acquireWorker() {
    // 1. æŸ¥æ‰¾ç©ºé—²Worker
    for (WorkerInfo& info : m_workers) {
        if (!info.isBusy) {
            info.isBusy = true;
            qDebug() << "[ThreadManager] Reusing worker" << info.worker;
            emit workerCountChanged(activeWorkerCount(), m_workers.size());
            return {info.worker, info.thread};
        }
    }

    // 2. å¦‚æœæ²¡æœ‰ç©ºé—²Workerä¸”æœªè¾¾åˆ°æœ€å¤§çº¿ç¨‹æ•°ï¼Œåˆ›å»ºæ–°Worker
    if (m_workers.size() < m_maxThreads) {
        QThread* thread = new QThread(this);
        AlgorithmWorker* worker = new AlgorithmWorker();
        worker->moveToThread(thread);

        // çº¿ç¨‹ç»“æŸæ—¶æ¸…ç†
        connect(thread, &QThread::finished, worker, &QObject::deleteLater);

        thread->start();

        WorkerInfo info{thread, worker, true};
        m_workers.append(info);

        qDebug() << "[ThreadManager] Created new worker" << worker
                 << "total:" << m_workers.size() << "/" << m_maxThreads;
        emit workerCountChanged(activeWorkerCount(), m_workers.size());

        return {worker, thread};
    }

    // 3. æ‰€æœ‰Workeréƒ½å¿™ä¸”è¾¾åˆ°æœ€å¤§çº¿ç¨‹æ•°ï¼Œè¿”å› nullptr
    qDebug() << "[ThreadManager] All workers busy (max threads reached)";
    return {nullptr, nullptr};
}

void AlgorithmThreadManager::releaseWorker(AlgorithmWorker* worker) {
    for (WorkerInfo& info : m_workers) {
        if (info.worker == worker) {
            info.isBusy = false;
            qDebug() << "[ThreadManager] Released worker" << worker;
            emit workerCountChanged(activeWorkerCount(), m_workers.size());

            // ğŸ†• å‘å‡ºä¿¡å·ï¼Œé€šçŸ¥ AlgorithmManager å¯å¤„ç†é˜Ÿåˆ—
            emit workerReleased();
            return;
        }
    }
    qWarning() << "[ThreadManager] Attempted to release unknown worker" << worker;
}

void AlgorithmThreadManager::setMaxThreads(int maxThreads) {
    if (maxThreads < 1 || maxThreads > 16) {
        qWarning() << "[ThreadManager] Invalid maxThreads:" << maxThreads << ", must be 1-16";
        return;
    }

    m_maxThreads = maxThreads;
    qDebug() << "[ThreadManager] Max threads updated to:" << m_maxThreads;
}

void AlgorithmThreadManager::shutdown() {
    qDebug() << "[ThreadManager] Shutting down all threads";

    for (const WorkerInfo& info : m_workers) {
        info.thread->quit();
        info.thread->wait(3000); // ç­‰å¾…æœ€å¤š3ç§’
        if (info.thread->isRunning()) {
            qWarning() << "[ThreadManager] Thread did not quit gracefully, terminating";
            info.thread->terminate();
        }
        delete info.thread;
    }
    m_workers.clear();
}

int AlgorithmThreadManager::activeWorkerCount() const {
    int count = 0;
    for (const WorkerInfo& info : m_workers) {
        if (info.isBusy) ++count;
    }
    return count;
}
```

---

### 2.2 ä¿®æ”¹ç°æœ‰ç±»

#### 2.2.1 AlgorithmManager (æ·»åŠ å¼‚æ­¥æ¥å£)

```cpp
// algorithm_manager.h (æ–°å¢æ–¹æ³•)
public:
    /**
     * @brief å¼‚æ­¥æ‰§è¡Œç®—æ³•ï¼ˆæ¨èä½¿ç”¨ï¼‰
     * @param algorithmName ç®—æ³•åç§°
     * @param context ä¸Šä¸‹æ–‡
     * @return ä»»åŠ¡IDï¼ˆç©ºå­—ç¬¦ä¸²è¡¨ç¤ºå¤±è´¥ï¼‰
     */
    QString executeAsync(const QString& algorithmName, AlgorithmContext* context);

    /**
     * @brief å–æ¶ˆæ­£åœ¨æ‰§è¡Œæˆ–æ’é˜Ÿçš„ä»»åŠ¡
     * @param taskId ä»»åŠ¡ID
     * @return true å¦‚æœä»»åŠ¡è¢«å–æ¶ˆï¼Œfalse å¦‚æœä»»åŠ¡ä¸å­˜åœ¨æˆ–å·²å®Œæˆ
     *
     * ã€å®ç°ã€‘ï¼š
     * - è¿è¡Œä¸­ä»»åŠ¡ï¼šè°ƒç”¨ Worker::requestCancellation()
     * - æ’é˜Ÿä»»åŠ¡ï¼šä»é˜Ÿåˆ—ç§»é™¤
     */
    bool cancelTask(const QString& taskId);

    /**
     * @brief è·å–é˜Ÿåˆ—çŠ¶æ€
     */
    int queuedTaskCount() const { return m_taskQueue.size(); }
    int runningTaskCount() const { return m_taskWorkers.size(); }

signals:
    void algorithmStarted(QString taskId, QString algorithmName);
    void algorithmProgress(QString taskId, int percentage, QString message);
    void algorithmFinished(QString taskId, qint64 elapsedMs);
    void algorithmFailed(QString taskId, QString errorMessage);
    void algorithmQueued(QString taskId, QString algorithmName); // ä»»åŠ¡æ’é˜Ÿ
    void algorithmCancelled(QString taskId, QString algorithmName); // ğŸ†• ä»»åŠ¡å–æ¶ˆ
    void queuedTaskCountChanged(int count); // ğŸ†• é˜Ÿåˆ—ä»»åŠ¡æ•°å˜åŒ–

private slots:
    void onWorkerStarted(QString taskId, QString algorithmName);
    void onWorkerProgress(QString taskId, int percentage, QString message);
    void onWorkerFinished(QString taskId, QVariant result, qint64 elapsedMs);
    void onWorkerFailed(QString taskId, QString errorMessage);
    void onWorkerReleased(); // ğŸ†• Worker é‡Šæ”¾æ—¶å¤„ç†é˜Ÿåˆ—

private:
    /**
     * @brief ä»é˜Ÿåˆ—ä¸­å–å‡ºä»»åŠ¡å¹¶åˆ†é…ç»™ç©ºé—²Worker
     *
     * ã€v1.2 ä¿®å¤ã€‘ï¼šé˜Ÿåˆ—ç®¡ç†ä¸Šç§»åˆ° AlgorithmManager
     */
    void processQueue();

    /**
     * @brief æäº¤ä»»åŠ¡åˆ°Workeræ‰§è¡Œ
     * @param task ä»»åŠ¡
     * @param algorithm ç®—æ³•
     * @param worker ç©ºé—²Worker
     *
     * ã€èŒè´£ã€‘ï¼š
     * - è¿æ¥ Worker ä¿¡å·ï¼ˆä¸€æ¬¡æ€§ï¼‰
     * - è®¾ç½® m_taskWorkers[taskId] æ˜ å°„
     * - è°ƒç”¨ Worker::executeTask()
     */
    void submitTaskToWorker(AlgorithmTaskPtr task, IThermalAlgorithm* algorithm,
                            AlgorithmWorker* worker);

    // ä»»åŠ¡é˜Ÿåˆ—ç»“æ„
    struct QueuedTask {
        AlgorithmTaskPtr task;
        IThermalAlgorithm* algorithm;
        QString algorithmName;
    };

    QMap<QString, AlgorithmTaskPtr> m_activeTasks;  // æ‰€æœ‰ä»»åŠ¡ï¼ˆè¿è¡Œä¸­+æ’é˜Ÿï¼‰
    QMap<QString, AlgorithmWorker*> m_taskWorkers;  // è¿è¡Œä¸­ä»»åŠ¡çš„ Worker æ˜ å°„
    QSet<AlgorithmWorker*> m_connectedWorkers;      // å·²è¿æ¥ä¿¡å·çš„Workeré›†åˆ
    QQueue<QueuedTask> m_taskQueue;                 // ğŸ†• ä»»åŠ¡é˜Ÿåˆ—ï¼ˆä¸Šç§»è‡ª ThreadManagerï¼‰
```

```cpp
// algorithm_manager.cpp (å®ç°å¼‚æ­¥æ‰§è¡Œ)

// åˆå§‹åŒ–æ—¶è¿æ¥ ThreadManager ä¿¡å·
AlgorithmManager::AlgorithmManager(CurveManager* curveManager, QObject* parent)
    : QObject(parent)
    , m_curveManager(curveManager)
{
    // ... å…¶ä»–åˆå§‹åŒ– ...

    // ğŸ†• è¿æ¥ ThreadManager çš„ workerReleased ä¿¡å·
    connect(AlgorithmThreadManager::instance(), &AlgorithmThreadManager::workerReleased,
            this, &AlgorithmManager::onWorkerReleased);
}

QString AlgorithmManager::executeAsync(const QString& algorithmName, AlgorithmContext* context) {
    // 1. è·å–ç®—æ³•å®ä¾‹
    IThermalAlgorithm* algorithm = getAlgorithm(algorithmName);
    if (!algorithm) {
        qWarning() << "[AlgorithmManager] Algorithm not found:" << algorithmName;
        return QString();
    }

    // 2. ğŸ”§ åªåœ¨ä¸»çº¿ç¨‹è°ƒç”¨ä¸€æ¬¡ prepareContextï¼ŒéªŒè¯æ•°æ®å®Œæ•´æ€§
    if (!algorithm->prepareContext(context)) {
        qWarning() << "[AlgorithmManager] Context preparation failed for" << algorithmName;
        return QString();
    }

    // 3. ğŸ”§ åˆ›å»ºä¸Šä¸‹æ–‡å¿«ç…§ï¼ˆæ·±æ‹·è´ï¼‰ï¼Œé¿å…å¹¶å‘è®¿é—®
    AlgorithmContext* contextSnapshot = context->clone();
    if (!contextSnapshot) {
        qWarning() << "[AlgorithmManager] Failed to create context snapshot";
        return QString();
    }

    // 4. åˆ›å»ºä»»åŠ¡ï¼ˆä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆï¼‰
    AlgorithmTaskPtr task = AlgorithmTaskPtr::create(algorithmName, contextSnapshot);
    QString taskId = task->taskId();

    // 5. è®°å½•ä»»åŠ¡ï¼ˆæ‰€æœ‰ä»»åŠ¡éƒ½è®°å½•ï¼Œæ— è®ºæ˜¯å¦æ’é˜Ÿï¼‰
    m_activeTasks[taskId] = task;

    // 6. å°è¯•è·å– Worker
    auto [worker, thread] = AlgorithmThreadManager::instance()->acquireWorker();
    if (!worker) {
        // ğŸ”§ v1.2 ä¿®å¤ï¼šæ‰€æœ‰Workerå¿™ï¼Œå°†ä»»åŠ¡åŠ å…¥é˜Ÿåˆ—
        qDebug() << "[AlgorithmManager] All workers busy, enqueueing task" << taskId;

        QueuedTask queuedTask{task, algorithm, algorithmName};
        m_taskQueue.enqueue(queuedTask);

        emit algorithmQueued(taskId, algorithmName);
        emit queuedTaskCountChanged(m_taskQueue.size());
        return taskId;
    }

    // 7. æœ‰ç©ºé—²Workerï¼Œç«‹å³æäº¤ä»»åŠ¡
    submitTaskToWorker(task, algorithm, worker);

    qDebug() << "[AlgorithmManager] Submitted task" << taskId << "algorithm:" << algorithmName
             << "to worker" << worker;
    return taskId;
}

void AlgorithmManager::submitTaskToWorker(AlgorithmTaskPtr task, IThermalAlgorithm* algorithm,
                                           AlgorithmWorker* worker) {
    QString taskId = task->taskId();

    // 1. è¿æ¥ Worker ä¿¡å·ï¼ˆä»…é¦–æ¬¡è¿æ¥ï¼‰
    if (!m_connectedWorkers.contains(worker)) {
        connect(worker, &AlgorithmWorker::taskStarted, this, &AlgorithmManager::onWorkerStarted);
        connect(worker, &AlgorithmWorker::taskProgress, this, &AlgorithmManager::onWorkerProgress);
        connect(worker, &AlgorithmWorker::taskFinished, this, &AlgorithmManager::onWorkerFinished);
        connect(worker, &AlgorithmWorker::taskFailed, this, &AlgorithmManager::onWorkerFailed);
        m_connectedWorkers.insert(worker);
        qDebug() << "[AlgorithmManager] Connected signals for worker" << worker;
    }

    // 2. è®¾ç½® Worker æ˜ å°„
    m_taskWorkers[taskId] = worker;

    // 3. è§¦å‘æ‰§è¡Œï¼ˆè·¨çº¿ç¨‹è°ƒç”¨ï¼‰
    QMetaObject::invokeMethod(worker, "executeTask", Qt::QueuedConnection,
                              Q_ARG(AlgorithmTaskPtr, task),
                              Q_ARG(IThermalAlgorithm*, algorithm));
}

void AlgorithmManager::processQueue() {
    if (m_taskQueue.isEmpty()) {
        return; // é˜Ÿåˆ—ä¸ºç©º
    }

    // å°è¯•è·å–ç©ºé—²Worker
    auto [worker, thread] = AlgorithmThreadManager::instance()->acquireWorker();
    if (!worker) {
        qDebug() << "[AlgorithmManager] No idle worker for queued task, waiting...";
        return;
    }

    // å–å‡ºé˜Ÿåˆ—å¤´éƒ¨ä»»åŠ¡
    QueuedTask queuedTask = m_taskQueue.dequeue();
    qDebug() << "[AlgorithmManager] Processing queued task" << queuedTask.task->taskId()
             << "remaining:" << m_taskQueue.size();

    emit queuedTaskCountChanged(m_taskQueue.size());

    // æäº¤ä»»åŠ¡åˆ°Worker
    submitTaskToWorker(queuedTask.task, queuedTask.algorithm, worker);
}

void AlgorithmManager::onWorkerReleased() {
    // Worker é‡Šæ”¾æ—¶ï¼Œå°è¯•å¤„ç†é˜Ÿåˆ—
    processQueue();
}

bool AlgorithmManager::cancelTask(const QString& taskId) {
    // 1. æ£€æŸ¥ä»»åŠ¡æ˜¯å¦å­˜åœ¨
    if (!m_activeTasks.contains(taskId)) {
        qWarning() << "[AlgorithmManager] Task not found:" << taskId;
        return false;
    }

    AlgorithmTaskPtr task = m_activeTasks[taskId];
    QString algorithmName = task->algorithmName();

    // 2. æ£€æŸ¥ä»»åŠ¡æ˜¯å¦åœ¨è¿è¡Œä¸­
    if (m_taskWorkers.contains(taskId)) {
        // è¿è¡Œä¸­ä»»åŠ¡ï¼šè¯·æ±‚ Worker å–æ¶ˆ
        AlgorithmWorker* worker = m_taskWorkers[taskId];
        qDebug() << "[AlgorithmManager] Cancelling running task" << taskId;

        QMetaObject::invokeMethod(worker, "requestCancellation", Qt::QueuedConnection);

        emit algorithmCancelled(taskId, algorithmName);
        return true;
    }

    // 3. ä»»åŠ¡åœ¨é˜Ÿåˆ—ä¸­ï¼šä»é˜Ÿåˆ—ç§»é™¤
    for (int i = 0; i < m_taskQueue.size(); ++i) {
        if (m_taskQueue[i].task->taskId() == taskId) {
            m_taskQueue.removeAt(i);
            m_activeTasks.remove(taskId);

            qDebug() << "[AlgorithmManager] Cancelled queued task" << taskId
                     << "remaining:" << m_taskQueue.size();

            emit queuedTaskCountChanged(m_taskQueue.size());
            emit algorithmCancelled(taskId, algorithmName);
            return true;
        }
    }

    qWarning() << "[AlgorithmManager] Task" << taskId << "found but not running or queued";
    return false;
}

void AlgorithmManager::onWorkerFinished(QString taskId, QVariant result, qint64 elapsedMs) {
    qDebug() << "[AlgorithmManager] Task" << taskId << "finished in" << elapsedMs << "ms";

    // 1. è·å–ä»»åŠ¡ä¿¡æ¯
    if (!m_activeTasks.contains(taskId)) {
        qWarning() << "[AlgorithmManager] Unknown task finished:" << taskId;
        return;
    }

    AlgorithmTaskPtr task = m_activeTasks[taskId];
    IThermalAlgorithm* algorithm = getAlgorithm(task->algorithmName());
    ThermalCurve* curve = task->context()->get<ThermalCurve*>("activeCurve").value();

    // 2. å¤„ç†ç»“æœï¼ˆå¿…é¡»é€šè¿‡å‘½ä»¤æ¨¡å¼ï¼‰
    // ğŸ”§ v1.2ï¼šç¡®ä¿æ‰€æœ‰æ•°æ®å†™å…¥éƒ½é€šè¿‡ HistoryManager
    handleAlgorithmResult(algorithm, curve, result); // å†…éƒ¨ä½¿ç”¨ AddCurveCommand

    // 3. å‘å‡ºå®Œæˆä¿¡å·
    emit algorithmFinished(taskId, elapsedMs);
    emit algorithmResultReady(task->algorithmName(), curve, result);

    // 4. æ¸…ç†ï¼ˆæ™ºèƒ½æŒ‡é’ˆè‡ªåŠ¨é‡Šæ”¾ï¼Œä¸éœ€è¦ deleteï¼‰
    AlgorithmWorker* worker = m_taskWorkers.take(taskId);
    if (worker) {
        AlgorithmThreadManager::instance()->releaseWorker(worker);
        // releaseWorker() ä¼šå‘å‡º workerReleased() ä¿¡å·ï¼Œè§¦å‘ processQueue()
    }

    m_activeTasks.remove(taskId); // ç§»é™¤æ™ºèƒ½æŒ‡é’ˆå¼•ç”¨
}

// handleAlgorithmResult() çš„æ­£ç¡®å®ç°ï¼ˆç¡®ä¿ä½¿ç”¨å‘½ä»¤æ¨¡å¼ï¼‰
void AlgorithmManager::handleAlgorithmResult(IThermalAlgorithm* algorithm,
                                              ThermalCurve* parentCurve,
                                              const QVariant& result) {
    // ... è§£æ result åˆ›å»º outputCurve ...

    // ğŸ”§ å…³é”®ï¼šå¿…é¡»é€šè¿‡ HistoryManager æ·»åŠ æ›²çº¿
    auto command = new AddCurveCommand(m_curveManager, outputCurve);
    HistoryManager::instance()->executeCommand(command);

    // ä¸è¦ç›´æ¥è°ƒç”¨ï¼šm_curveManager->addCurve(outputCurve); // âŒ ç»•è¿‡å†å²
}
```

#### 2.2.2 IThermalAlgorithm (æ·»åŠ å¯é€‰çš„è¿›åº¦æ”¯æŒ)

```cpp
// i_thermal_algorithm.h (æ·»åŠ æ–¹æ³•)
public:
    /**
     * @brief è®¾ç½®è¿›åº¦æŠ¥å‘Šå™¨ï¼ˆå¯é€‰ï¼‰
     * @param reporter è¿›åº¦æŠ¥å‘Šå™¨
     *
     * ç®—æ³•å¯ä»¥é€‰æ‹©æ€§åœ°ä½¿ç”¨æ­¤æ¥å£æŠ¥å‘Šæ‰§è¡Œè¿›åº¦
     */
    virtual void setProgressReporter(IProgressReporter* reporter) {
        Q_UNUSED(reporter);
        // é»˜è®¤å®ç°ï¼šä¸åšä»»ä½•äº‹ï¼ˆç®—æ³•ä¸æ”¯æŒè¿›åº¦æŠ¥å‘Šï¼‰
    }

protected:
    /**
     * @brief æŠ¥å‘Šè¿›åº¦çš„ä¾¿æ·æ–¹æ³•
     * @param percentage è¿›åº¦ç™¾åˆ†æ¯” (0-100)
     * @param message è¿›åº¦æè¿°
     */
    void reportProgress(int percentage, const QString& message = "") {
        if (m_progressReporter) {
            m_progressReporter->reportProgress(percentage, message);
        }
    }

    /**
     * @brief æ£€æŸ¥æ˜¯å¦åº”è¯¥å–æ¶ˆæ‰§è¡Œ
     * @return true å¦‚æœåº”è¯¥å–æ¶ˆ
     */
    bool shouldCancel() const {
        return m_progressReporter && m_progressReporter->isCancellationRequested();
    }

private:
    IProgressReporter* m_progressReporter = nullptr;
```

---

## 3. å®æ–½è®¡åˆ’

### Phase 1: åˆ†æå½“å‰æ¶æ„å¹¶è®¾è®¡çº¿ç¨‹æ–¹æ¡ˆ âœ…

**ä»»åŠ¡**:
- âœ… åˆ†æç°æœ‰ç®—æ³•æ‰§è¡Œæµç¨‹
- âœ… ç¡®å®šæŠ€æœ¯æ–¹æ¡ˆï¼ˆWorker Object Patternï¼‰
- âœ… è®¾è®¡æ ¸å¿ƒç±»ï¼ˆAlgorithmTaskã€IProgressReporterã€AlgorithmWorkerã€AlgorithmThreadManagerï¼‰
- âœ… ç¼–å†™è®¾è®¡æ–‡æ¡£

**éªŒæ”¶æ ‡å‡†**:
- è®¾è®¡æ–‡æ¡£å®Œæˆ
- ç±»èŒè´£æ¸…æ™°
- ä¿¡å·æ§½æµç¨‹æ˜ç¡®

---

### Phase 2: å®ç°æ ¸å¿ƒçº¿ç¨‹åŸºç¡€è®¾æ–½

**ä»»åŠ¡**:
1. å®ç° `AlgorithmTask` ç±»ï¼ˆä»»åŠ¡å°è£…ï¼‰
2. å®ç° `IProgressReporter` æ¥å£
3. å®ç° `AlgorithmWorker` ç±»ï¼ˆå·¥ä½œçº¿ç¨‹å¯¹è±¡ï¼‰
4. å®ç° `AlgorithmThreadManager` ç±»ï¼ˆçº¿ç¨‹æ± ç®¡ç†å™¨ï¼‰

**æ–‡ä»¶æ¸…å•**:
- `src/domain/algorithm/algorithm_task.h`
- `src/domain/algorithm/i_progress_reporter.h`
- `src/application/algorithm/algorithm_worker.h`
- `src/application/algorithm/algorithm_worker.cpp`
- `src/application/algorithm/algorithm_thread_manager.h`
- `src/application/algorithm/algorithm_thread_manager.cpp`

**éªŒæ”¶æ ‡å‡†**:
- æ‰€æœ‰ç±»ç¼–è¯‘é€šè¿‡
- çº¿ç¨‹æ± èƒ½å¤Ÿåˆ›å»ºå’Œå¤ç”¨Worker
- Workerèƒ½å¤Ÿåœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­è¿è¡Œ

---

### Phase 3: ä¿®æ”¹ AlgorithmManager æ”¯æŒå¼‚æ­¥æ‰§è¡Œ

**ä»»åŠ¡**:
1. æ·»åŠ  `executeAsync()` æ–¹æ³•
2. æ·»åŠ  `cancelTask()` æ–¹æ³•
3. æ·»åŠ ä¿¡å·ï¼š`algorithmStarted`, `algorithmProgress`, `algorithmFinished`, `algorithmFailed`
4. å®ç°æ§½å‡½æ•°ï¼š`onWorkerStarted`, `onWorkerProgress`, `onWorkerFinished`, `onWorkerFailed`
5. ç®¡ç†æ´»åŠ¨ä»»åŠ¡æ˜ å°„ (`m_activeTasks`, `m_taskWorkers`)

**ä¿®æ”¹æ–‡ä»¶**:
- `src/application/algorithm/algorithm_manager.h`
- `src/application/algorithm/algorithm_manager.cpp`

**éªŒæ”¶æ ‡å‡†**:
- å¼‚æ­¥æ‰§è¡Œæ¥å£å¯ç”¨
- ç»“æœå›è°ƒæ­£ç¡®å¤„ç†
- ä»»åŠ¡ç”Ÿå‘½å‘¨æœŸç®¡ç†æ­£ç¡®

---

### Phase 4: é€‚é…ç®—æ³•æ¥å£æ”¯æŒè¿›åº¦æŠ¥å‘Š

**ä»»åŠ¡**:
1. ä¿®æ”¹ `IThermalAlgorithm` æ·»åŠ  `setProgressReporter()` æ–¹æ³•
2. æ·»åŠ  `reportProgress()` å’Œ `shouldCancel()` ä¾¿æ·æ–¹æ³•
3. åœ¨é•¿æ—¶é—´ç®—æ³•ä¸­æ·»åŠ è¿›åº¦æŠ¥å‘Šï¼ˆå¦‚å¾®åˆ†ã€ç§¯åˆ†ï¼‰

**ç¤ºä¾‹**:
```cpp
// DifferentiationAlgorithm::executeWithContext() ä¸­æ·»åŠ 
QVariant DifferentiationAlgorithm::executeWithContext(AlgorithmContext* context) {
    // ... å‰ç½®ä»£ç  ...

    for (int i = 0; i < data.size(); ++i) {
        // æ¯å¤„ç†10%æŠ¥å‘Šä¸€æ¬¡è¿›åº¦
        if (i % (data.size() / 10) == 0) {
            reportProgress(i * 100 / data.size(), QString("å·²å¤„ç† %1/%2 ç‚¹").arg(i).arg(data.size()));
        }

        // æ£€æŸ¥å–æ¶ˆè¯·æ±‚
        if (shouldCancel()) {
            qDebug() << "[Differentiation] Execution cancelled by user";
            return QVariant();
        }

        // ... ç®—æ³•é€»è¾‘ ...
    }

    reportProgress(100, "å¾®åˆ†è®¡ç®—å®Œæˆ");
    return QVariant::fromValue(result);
}
```

**ä¿®æ”¹æ–‡ä»¶**:
- `src/domain/algorithm/i_thermal_algorithm.h`
- `src/infrastructure/algorithm/differentiation_algorithm.cpp`
- `src/infrastructure/algorithm/integration_algorithm.cpp`
- `src/infrastructure/algorithm/moving_average_filter_algorithm.cpp`

**éªŒæ”¶æ ‡å‡†**:
- ç®—æ³•èƒ½å¤ŸæŠ¥å‘Šè¿›åº¦
- ç®—æ³•èƒ½å¤Ÿå“åº”å–æ¶ˆè¯·æ±‚
- ä¸æ”¯æŒè¿›åº¦çš„ç®—æ³•ä¸å—å½±å“

---

### Phase 5: é›†æˆåˆ° AlgorithmCoordinator

**ä»»åŠ¡**:
1. ä¿®æ”¹ `AlgorithmCoordinator::executeAlgorithm()` è°ƒç”¨å¼‚æ­¥æ¥å£
2. ä¿å­˜ taskId åˆ° PendingRequest
3. å¤„ç†å¼‚æ­¥å›è°ƒä¿¡å·

**ä¿®æ”¹æ–‡ä»¶**:
- `src/application/algorithm/algorithm_coordinator.h`
- `src/application/algorithm/algorithm_coordinator.cpp`

**ä»£ç ç¤ºä¾‹**:
```cpp
void AlgorithmCoordinator::executeAlgorithm(const QString& algorithmName) {
    // ... å‰ç½®ä»£ç  ...

    // è°ƒç”¨å¼‚æ­¥æ‰§è¡Œ
    QString taskId = m_algorithmManager->executeAsync(algorithmName, m_context);
    if (taskId.isEmpty()) {
        qWarning() << "[AlgorithmCoordinator] Failed to submit task";
        return;
    }

    // ä¿å­˜taskIdåˆ°å¾…å¤„ç†è¯·æ±‚
    if (m_pendingRequests.contains(algorithmName)) {
        m_pendingRequests[algorithmName].taskId = taskId;
    }

    qDebug() << "[AlgorithmCoordinator] Submitted algorithm" << algorithmName << "taskId:" << taskId;
}
```

**éªŒæ”¶æ ‡å‡†**:
- AlgorithmCoordinator èƒ½å¤Ÿè§¦å‘å¼‚æ­¥æ‰§è¡Œ
- ç»“æœå›è°ƒèƒ½å¤Ÿæ­£ç¡®å¤„ç†

---

### Phase 6: UI å±‚æ·»åŠ è¿›åº¦åé¦ˆ

**ä»»åŠ¡**:
1. MainWindow æ·»åŠ è¿›åº¦å¯¹è¯æ¡† (`QProgressDialog`)
2. MainController è¿æ¥è¿›åº¦ä¿¡å·
3. æ˜¾ç¤ºè¿›åº¦ç™¾åˆ†æ¯”å’Œæ¶ˆæ¯
4. æ”¯æŒå–æ¶ˆæŒ‰é’®

**ä¿®æ”¹æ–‡ä»¶**:
- `src/ui/main_window.h`
- `src/ui/main_window.cpp`
- `src/ui/controller/main_controller.h`
- `src/ui/controller/main_controller.cpp`

**ä»£ç ç¤ºä¾‹**:
```cpp
// main_controller.cpp
void MainController::onAlgorithmStarted(QString taskId, QString algorithmName) {
    qDebug() << "[MainController] Algorithm started:" << algorithmName << "taskId:" << taskId;

    // æ˜¾ç¤ºè¿›åº¦å¯¹è¯æ¡†
    m_progressDialog = new QProgressDialog(
        QString("æ­£åœ¨æ‰§è¡Œ: %1").arg(algorithmName),
        "å–æ¶ˆ",
        0, 100,
        m_mainWindow
    );
    m_progressDialog->setWindowModality(Qt::WindowModal);
    m_progressDialog->setMinimumDuration(500); // 500msåæ‰æ˜¾ç¤º
    m_progressDialog->setValue(0);

    // è¿æ¥å–æ¶ˆä¿¡å·
    connect(m_progressDialog, &QProgressDialog::canceled, this, [this, taskId]() {
        qDebug() << "[MainController] User requested cancellation for task" << taskId;
        m_algorithmManager->cancelTask(taskId);
    });

    m_currentTaskId = taskId;
}

void MainController::onAlgorithmProgress(QString taskId, int percentage, QString message) {
    if (taskId != m_currentTaskId || !m_progressDialog) return;

    m_progressDialog->setValue(percentage);
    if (!message.isEmpty()) {
        m_progressDialog->setLabelText(message);
    }
}

void MainController::onAlgorithmFinished(QString taskId, qint64 elapsedMs) {
    if (taskId != m_currentTaskId) return;

    qDebug() << "[MainController] Algorithm finished in" << elapsedMs << "ms";

    if (m_progressDialog) {
        m_progressDialog->close();
        delete m_progressDialog;
        m_progressDialog = nullptr;
    }

    m_currentTaskId.clear();
}
```

**éªŒæ”¶æ ‡å‡†**:
- è¿›åº¦å¯¹è¯æ¡†èƒ½å¤Ÿæ˜¾ç¤º
- è¿›åº¦ç™¾åˆ†æ¯”å®æ—¶æ›´æ–°
- å–æ¶ˆæŒ‰é’®èƒ½å¤Ÿä¸­æ­¢è®¡ç®—
- è®¡ç®—å®Œæˆåå¯¹è¯æ¡†è‡ªåŠ¨å…³é—­

---

### Phase 7: æµ‹è¯•å’Œä¼˜åŒ–

**ä»»åŠ¡**:
1. å•å…ƒæµ‹è¯•ï¼ˆAlgorithmWorkerã€AlgorithmThreadManagerï¼‰
2. é›†æˆæµ‹è¯•ï¼ˆå®Œæ•´ç®—æ³•æ‰§è¡Œæµç¨‹ï¼‰
3. å‹åŠ›æµ‹è¯•ï¼ˆå¤šä»»åŠ¡å¹¶å‘ï¼‰
4. æ€§èƒ½æµ‹è¯•ï¼ˆå¯¹æ¯”åŒæ­¥æ‰§è¡Œï¼‰
5. å†…å­˜æ³„æ¼æ£€æŸ¥
6. ä¼˜åŒ–çº¿ç¨‹æ± ç­–ç•¥

**æµ‹è¯•åœºæ™¯**:
- âœ… ç®€å•ç®—æ³•ï¼ˆå¾®åˆ†ã€ç§¯åˆ†ï¼‰å¼‚æ­¥æ‰§è¡Œ
- âœ… é•¿æ—¶é—´ç®—æ³•ï¼ˆå¤§æ•°æ®é›†ï¼‰è¿›åº¦æŠ¥å‘Š
- âœ… ç”¨æˆ·å–æ¶ˆæ‰§è¡Œ
- âœ… å¤šä¸ªç®—æ³•å¹¶å‘æ‰§è¡Œ
- âœ… çº¿ç¨‹æ± å¤ç”¨éªŒè¯
- âœ… å¼‚å¸¸æƒ…å†µï¼ˆç®—æ³•æŠ›å‡ºå¼‚å¸¸ã€ä¸Šä¸‹æ–‡æ— æ•ˆç­‰ï¼‰

**æ€§èƒ½æŒ‡æ ‡**:
- UIå“åº”æ—¶é—´ < 100msï¼ˆå³ä½¿ç®—æ³•æ‰§è¡Œä¸­ï¼‰
- çº¿ç¨‹å¼€é”€ < 10% CPUï¼ˆç©ºé—²æ—¶ï¼‰
- å†…å­˜å ç”¨ < 50MBï¼ˆ4ä¸ªçº¿ç¨‹ï¼‰

**éªŒæ”¶æ ‡å‡†**:
- æ‰€æœ‰æµ‹è¯•é€šè¿‡
- æ— å†…å­˜æ³„æ¼
- UIå§‹ç»ˆä¿æŒå“åº”

---

## 4. æŠ€æœ¯ç»†èŠ‚

### 4.1 çº¿ç¨‹å®‰å…¨è€ƒè™‘

**âœ… å®‰å…¨çš„è®¾è®¡ï¼ˆv1.1 ä¿®å¤åï¼‰**:
- âœ… `AlgorithmContext`: æ¯ä¸ªä»»åŠ¡ä½¿ç”¨ç‹¬ç«‹å¿«ç…§ï¼ˆæ·±æ‹·è´ï¼‰ï¼Œæ— å…±äº«è®¿é—®
- âœ… `AlgorithmTask`: ä½¿ç”¨ QSharedPointer ç®¡ç†ï¼Œé¿å…åŒé‡é‡Šæ”¾
- âœ… `ThermalCurve`: åªè¯»è®¿é—®ï¼ˆ`getProcessedData()`ï¼‰
- âœ… `QVariant`: å€¼ç±»å‹ï¼Œè‡ªåŠ¨æ‹·è´

**âš ï¸ éœ€è¦æ³¨æ„çš„**:
- âš ï¸ `CurveManager`: æ·»åŠ æ›²çº¿æ—¶éœ€è¦å›åˆ°ä¸»çº¿ç¨‹ï¼ˆé€šè¿‡ä¿¡å·æ§½ï¼‰
- âš ï¸ `AlgorithmDescriptor`: åªè¯»è®¿é—®ï¼Œæ— éœ€æ‹…å¿ƒ
- âš ï¸ `IThermalAlgorithm`: ç®—æ³•å®ä¾‹åº”è¯¥æ˜¯æ— çŠ¶æ€çš„ï¼ˆæˆå‘˜å˜é‡ä»…ç”¨äºé»˜è®¤å‚æ•°ï¼‰

**ğŸ”§ ä¿®å¤æ–¹æ¡ˆ**:
1. **ä¸Šä¸‹æ–‡éš”ç¦»**: ä¸ºæ¯ä¸ªä»»åŠ¡åˆ›å»ºä¸Šä¸‹æ–‡å¿«ç…§
   ```cpp
   AlgorithmContext* contextSnapshot = context->clone();
   AlgorithmTaskPtr task = AlgorithmTaskPtr::create(algorithmName, contextSnapshot);
   ```

2. **æ™ºèƒ½æŒ‡é’ˆç®¡ç†**: ä½¿ç”¨ QSharedPointer é¿å…æ‰€æœ‰æƒé—®é¢˜
   ```cpp
   using AlgorithmTaskPtr = QSharedPointer<AlgorithmTask>;
   QMap<QString, AlgorithmTaskPtr> m_activeTasks;
   ```

3. **å•æ¬¡éªŒè¯**: prepareContext åªåœ¨ä¸»çº¿ç¨‹è°ƒç”¨ä¸€æ¬¡
   ```cpp
   // ä¸»çº¿ç¨‹ï¼ˆAlgorithmManager::executeAsyncï¼‰
   algorithm->prepareContext(context); // âœ… åªè°ƒç”¨ä¸€æ¬¡

   // å·¥ä½œçº¿ç¨‹ï¼ˆAlgorithmWorker::executeTaskï¼‰
   // è·³è¿‡ prepareContextï¼Œç›´æ¥æ‰§è¡Œ âœ…
   algorithm->executeWithContext(task->context());
   ```

4. **ä¿¡å·æ§½å›åˆ°ä¸»çº¿ç¨‹**: æ‰€æœ‰UIæ›´æ–°å’Œæ•°æ®ä¿®æ”¹é€šè¿‡ä¿¡å·æ§½
   ```cpp
   // å·¥ä½œçº¿ç¨‹å‘å‡ºä¿¡å·
   emit taskFinished(taskId, result, elapsed);

   // ä¸»çº¿ç¨‹å¤„ç†
   void AlgorithmManager::onWorkerFinished(...) {
       handleAlgorithmResult(...); // åœ¨ä¸»çº¿ç¨‹æ‰§è¡Œ
   }
   ```

**AlgorithmContext::clone() å®ç°è¦æ±‚** (v1.2 æ˜ç¡®è¯­ä¹‰):

```cpp
// src/application/algorithm/algorithm_context.h
class AlgorithmContext : public QObject {
public:
    /**
     * @brief åˆ›å»ºä¸Šä¸‹æ–‡æ·±æ‹·è´
     * @return æ–°çš„ä¸Šä¸‹æ–‡å¯¹è±¡ï¼ˆè°ƒç”¨è€…è´Ÿè´£é‡Šæ”¾ï¼‰
     *
     * ã€è¯­ä¹‰çº¦æŸã€‘ï¼š
     * 1. æ·±æ‹·è´ç»“æ„ï¼šæ‰€æœ‰ QMap å’Œ QVariant éƒ½å¤åˆ¶ä¸€ä»½
     * 2. æŒ‡é’ˆå€¼è¯­ä¹‰ï¼šæŒ‡é’ˆç±»å‹ï¼ˆå¦‚ ThermalCurve*ï¼‰æ‹·è´æŒ‡é’ˆå€¼ï¼Œä¸æ‹·è´å¯¹è±¡
     * 3. åªè¯»è®¿é—®ï¼šWorker ç»ä¸ä¿®æ”¹ä¸»çº¿ç¨‹å¯¹è±¡ï¼ˆconst å¼•ç”¨è®¿é—®ï¼‰
     * 4. æ•°æ®ä¸å˜ï¼šæ›²çº¿æ•°æ®ä½¿ç”¨ QSharedPointer<const QVector<...>> å…±äº«åªè¯»æ•°æ®
     *
     * ã€ç¤ºä¾‹ã€‘ï¼š
     * - activeCurve (ThermalCurve*): æ‹·è´æŒ‡é’ˆï¼ŒWorker åªè¯»è®¿é—®
     * - param.windowSize (int): æ‹·è´å€¼
     * - selectedPoints (QVector<QPointF>): QVariant æ·±æ‹·è´
     */
    AlgorithmContext* clone() const {
        AlgorithmContext* copy = new AlgorithmContext();

        // æ·±æ‹·è´æ‰€æœ‰é”®å€¼å¯¹ï¼ˆQMap å’Œ ContextValueï¼‰
        for (auto it = m_data.constBegin(); it != m_data.constEnd(); ++it) {
            const QString& key = it.key();
            const ContextValue& value = it.value();

            // ContextValue åŒ…å« QVariantï¼Œä¼šè‡ªåŠ¨æ·±æ‹·è´å€¼ç±»å‹
            // æŒ‡é’ˆç±»å‹ï¼ˆå¦‚ ThermalCurve*ï¼‰åªæ‹·è´æŒ‡é’ˆå€¼ï¼ˆåˆæ³•ï¼Œå› ä¸ºåªè¯»ï¼‰
            copy->m_data[key] = value;
        }

        return copy;
    }

    /**
     * @brief è·å–æ›²çº¿æ•°æ®ï¼ˆåªè¯»è®¿é—®ï¼‰
     *
     * ã€çº¦æŸã€‘ï¼š
     * - è¿”å› const å¼•ç”¨ï¼Œç¦æ­¢ä¿®æ”¹
     * - ç®—æ³•åº”è¯¥è¯»å– getProcessedData()ï¼Œä¸ä¿®æ”¹æ›²çº¿
     */
    const QVector<ThermalDataPoint>& getCurveData(ThermalCurve* curve) const {
        return curve->getProcessedData(); // const æ–¹æ³•
    }
};
```

**ThermalCurve çš„çº¿ç¨‹å®‰å…¨è¦æ±‚**:

```cpp
// src/domain/model/thermal_curve.h
class ThermalCurve {
public:
    /**
     * @brief è·å–å¤„ç†æ•°æ®ï¼ˆåªè¯»è®¿é—®ï¼‰
     *
     * ã€çº¿ç¨‹å®‰å…¨ã€‘ï¼š
     * - const æ–¹æ³•ï¼Œä¸ä¿®æ”¹çŠ¶æ€
     * - è¿”å› const å¼•ç”¨ï¼ŒWorker å¯å®‰å…¨è¯»å–
     * - æ•°æ®ä¸åœ¨ç®—æ³•æ‰§è¡ŒæœŸé—´ä¿®æ”¹ï¼ˆä¸»çº¿ç¨‹ä¿è¯ï¼‰
     */
    const QVector<ThermalDataPoint>& getProcessedData() const {
        return m_processedData;
    }

    /**
     * @brief è·å–å…ƒæ•°æ®ï¼ˆåªè¯»è®¿é—®ï¼‰
     */
    QString sampleName() const { return m_sampleName; }
    InstrumentType instrumentType() const { return m_instrumentType; }
    SignalType signalType() const { return m_signalType; }

    // ã€ç¦æ­¢ã€‘ï¼šWorker ç»ä¸è°ƒç”¨ä¿®æ”¹æ–¹æ³•
    // void setProcessedData(...); // âŒ åªèƒ½åœ¨ä¸»çº¿ç¨‹è°ƒç”¨
};
```

**æ•°æ®ä¿®æ”¹çº¦æŸ**:

```cpp
// âœ… æ­£ç¡®ï¼šWorker åªè¯»è®¿é—®
QVariant DifferentiationAlgorithm::executeWithContext(AlgorithmContext* context) {
    auto curve = context->get<ThermalCurve*>("activeCurve").value();
    const QVector<ThermalDataPoint>& data = curve->getProcessedData(); // âœ… const å¼•ç”¨

    QVector<ThermalDataPoint> result; // æ–°æ•°æ®
    for (const auto& point : data) {  // âœ… åªè¯»éå†
        // è®¡ç®—...
        result.append(newPoint);
    }

    return QVariant::fromValue(result); // âœ… è¿”å›æ–°æ•°æ®
}

// âŒ é”™è¯¯ï¼šWorker ä¿®æ”¹ä¸»çº¿ç¨‹å¯¹è±¡
QVariant WrongAlgorithm::executeWithContext(AlgorithmContext* context) {
    auto curve = context->get<ThermalCurve*>("activeCurve").value();
    curve->setProcessedData(newData); // âŒ è·¨çº¿ç¨‹ä¿®æ”¹ï¼Œå´©æºƒï¼
}
```

**ä¸»çº¿ç¨‹å†™å…¥çº¦æŸ**:

```cpp
// âœ… æ­£ç¡®ï¼šä¸»çº¿ç¨‹é€šè¿‡å‘½ä»¤ä¿®æ”¹
void AlgorithmManager::onWorkerFinished(...) {
    // Worker è¿”å›æ–°æ•°æ®ï¼Œä¸»çº¿ç¨‹åˆ›å»ºæ–°æ›²çº¿
    ThermalCurve* outputCurve = new ThermalCurve(result);

    // é€šè¿‡å‘½ä»¤æ¨¡å¼æ·»åŠ ï¼ˆæ”¯æŒæ’¤é”€ï¼‰
    auto command = new AddCurveCommand(m_curveManager, outputCurve);
    HistoryManager::instance()->executeCommand(command);
}
```

### 4.2 å–æ¶ˆæœºåˆ¶

**å®ç°æ–¹å¼**:
1. ç”¨æˆ·ç‚¹å‡»å–æ¶ˆæŒ‰é’®
2. MainController è°ƒç”¨ `AlgorithmManager::cancelTask(taskId)`
3. AlgorithmManager è°ƒç”¨ `AlgorithmWorker::requestCancellation()`
4. Worker è®¾ç½® `m_cancellationRequested = true`
5. ç®—æ³•åœ¨å¾ªç¯ä¸­å®šæœŸæ£€æŸ¥ `shouldCancel()`
6. å¦‚æœè¿”å›trueï¼Œç®—æ³•ç«‹å³è¿”å› `QVariant()`
7. Worker å‘å‡º `taskFailed` ä¿¡å·

**è¦æ±‚**:
- ç®—æ³•å¿…é¡»å®šæœŸæ£€æŸ¥å–æ¶ˆè¯·æ±‚ï¼ˆæ¯100æ¬¡è¿­ä»£æˆ–æ¯100msï¼‰
- ç®—æ³•ä¸èƒ½åœ¨å¾ªç¯å¤–é•¿æ—¶é—´é˜»å¡ï¼ˆå¦‚IOæ“ä½œï¼‰
- å–æ¶ˆååº”è¯¥å¿«é€Ÿè¿”å›ï¼ˆ< 1ç§’ï¼‰

### 4.3 é”™è¯¯å¤„ç†

**å¼‚å¸¸æ•è·**:
- Worker åœ¨ `executeTask()` ä¸­ä½¿ç”¨ `try-catch` æ•è·æ‰€æœ‰å¼‚å¸¸
- å‘å‡º `taskFailed` ä¿¡å·å¹¶é™„å¸¦é”™è¯¯ä¿¡æ¯
- ä¸»çº¿ç¨‹æ˜¾ç¤ºé”™è¯¯å¯¹è¯æ¡†

**æ•°æ®éªŒè¯**:
- åœ¨ä¸»çº¿ç¨‹ä¸­éªŒè¯ä¸Šä¸‹æ–‡ï¼ˆ`prepareContext()`ï¼‰
- é¿å…åœ¨å·¥ä½œçº¿ç¨‹ä¸­å‘ç°æ•°æ®é—®é¢˜

### 4.4 æ€§èƒ½ä¼˜åŒ–

**çº¿ç¨‹æ± ç­–ç•¥**:
- æœ€å¤§çº¿ç¨‹æ•°ï¼š`QThread::idealThreadCount()`ï¼ˆé€šå¸¸æ˜¯CPUæ ¸å¿ƒæ•°ï¼‰
- çº¿ç¨‹å¤ç”¨ï¼šç©ºé—²Workerä¿ç•™åœ¨æ± ä¸­ï¼Œé¿å…é¢‘ç¹åˆ›å»º/é”€æ¯
- ä»»åŠ¡é˜Ÿåˆ—ï¼šå¦‚æœæ‰€æœ‰Workerå¿™ï¼Œæ–°ä»»åŠ¡è¿›å…¥é˜Ÿåˆ—ç­‰å¾…

**æ•°æ®æ‹·è´ä¼˜åŒ–**:
- ä½¿ç”¨ `QSharedPointer` å…±äº«å¤§æ•°æ®ï¼ˆå¦‚ ThermalCurveï¼‰
- ä¸Šä¸‹æ–‡ä¸­å­˜å‚¨æŒ‡é’ˆè€Œéå€¼ï¼ˆé¿å…æ‹·è´ï¼‰
- ç»“æœè¿”å›ä½¿ç”¨ `QVariant::fromValue` é¿å…å¤šæ¬¡æ‹·è´

---

## 5. å‘åå…¼å®¹æ€§

### 5.1 ä¿ç•™åŒæ­¥æ¥å£

ä¸ºäº†æµ‹è¯•å’Œè°ƒè¯•ï¼Œä¿ç•™åŒæ­¥æ‰§è¡Œæ¥å£ï¼š

```cpp
// AlgorithmManager (ä¿ç•™)
void executeWithContext(const QString& algorithmName, AlgorithmContext* context);
```

### 5.2 æ¸è¿›å¼è¿ç§»

**ç¬¬ä¸€é˜¶æ®µ**: å®ç°å¼‚æ­¥åŸºç¡€è®¾æ–½ï¼Œä½†ä¸»è¦ä½¿ç”¨åŒæ­¥æ¥å£
**ç¬¬äºŒé˜¶æ®µ**: åœ¨ MainController ä¸­å¯ç”¨å¼‚æ­¥æ‰§è¡Œï¼Œæ·»åŠ è¿›åº¦å¯¹è¯æ¡†
**ç¬¬ä¸‰é˜¶æ®µ**: åºŸå¼ƒåŒæ­¥æ¥å£ï¼ˆæ ‡è®°ä¸º `[[deprecated]]`ï¼‰
**ç¬¬å››é˜¶æ®µ**: å®Œå…¨ç§»é™¤åŒæ­¥æ¥å£

---

## 6. æ–‡æ¡£å’Œæ³¨é‡Š

### 6.1 ä»£ç æ³¨é‡Š

- æ¯ä¸ªæ–°ç±»éƒ½éœ€è¦è¯¦ç»†çš„ç±»çº§æ³¨é‡Šï¼ˆèŒè´£ã€ç”¨æ³•ï¼‰
- æ¯ä¸ªå…¬å…±æ–¹æ³•éƒ½éœ€è¦æ–‡æ¡£æ³¨é‡Šï¼ˆå‚æ•°ã€è¿”å›å€¼ã€æ³¨æ„äº‹é¡¹ï¼‰
- å¤æ‚çš„çº¿ç¨‹äº¤äº’éœ€è¦æµç¨‹å›¾æ³¨é‡Š

### 6.2 æ›´æ–° CLAUDE.md

åœ¨ `CLAUDE.md` ä¸­æ·»åŠ ç« èŠ‚ï¼š

```markdown
## ç®—æ³•å¤šçº¿ç¨‹æ‰§è¡Œ

### æ¦‚è¿°
æ‰€æœ‰ç®—æ³•è®¡ç®—åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­æ‰§è¡Œï¼Œé¿å…é˜»å¡UIã€‚

### æ ¸å¿ƒç±»
- **AlgorithmTask**: ä»»åŠ¡å°è£…
- **AlgorithmWorker**: å·¥ä½œçº¿ç¨‹å¯¹è±¡
- **AlgorithmThreadManager**: çº¿ç¨‹æ± ç®¡ç†å™¨

### æ‰§è¡Œæµç¨‹
1. AlgorithmCoordinator è°ƒç”¨ `AlgorithmManager::executeAsync()`
2. AlgorithmManager è·å–ç©ºé—²Workerå¹¶æäº¤ä»»åŠ¡
3. Worker åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­æ‰§è¡Œç®—æ³•
4. Worker é€šè¿‡ä¿¡å·è¿”å›ç»“æœ
5. AlgorithmManager åœ¨ä¸»çº¿ç¨‹å¤„ç†ç»“æœ

### è¿›åº¦æŠ¥å‘Š
ç®—æ³•å¯ä»¥é€‰æ‹©å®ç°è¿›åº¦æŠ¥å‘Šï¼š
- è°ƒç”¨ `reportProgress(percentage, message)` æŠ¥å‘Šè¿›åº¦
- è°ƒç”¨ `shouldCancel()` æ£€æŸ¥å–æ¶ˆè¯·æ±‚

### å–æ¶ˆæ‰§è¡Œ
ç”¨æˆ·å¯ä»¥åœ¨è¿›åº¦å¯¹è¯æ¡†ä¸­ç‚¹å‡»"å–æ¶ˆ"æŒ‰é’®ä¸­æ­¢è®¡ç®—ã€‚
```

---

## 7. é£é™©å’Œç¼“è§£

| é£é™© | å½±å“ | æ¦‚ç‡ | ç¼“è§£æªæ–½ |
|------|------|------|----------|
| çº¿ç¨‹æ­»é” | é«˜ | ä½ | ä½¿ç”¨ä¿¡å·æ§½é¿å…ç›´æ¥é”ï¼Œä»£ç å®¡æŸ¥ |
| å†…å­˜æ³„æ¼ | é«˜ | ä¸­ | ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆï¼ŒValgrindæ£€æµ‹ |
| ç«æ€æ¡ä»¶ | é«˜ | ä½ | æ‰€æœ‰UIæ“ä½œåœ¨ä¸»çº¿ç¨‹ï¼Œä»£ç å®¡æŸ¥ |
| æ€§èƒ½ä¸‹é™ | ä¸­ | ä½ | æ€§èƒ½æµ‹è¯•å¯¹æ¯”ï¼Œä¼˜åŒ–çº¿ç¨‹æ±  |
| å…¼å®¹æ€§é—®é¢˜ | ä½ | ä½ | ä¿ç•™åŒæ­¥æ¥å£ï¼Œæ¸è¿›å¼è¿ç§» |

---

## 8. æ€»ç»“

### 8.1 é¢„æœŸæ”¶ç›Š

- âœ… **UIå“åº”æ€§**: å³ä½¿ç®—æ³•æ‰§è¡Œä¸­UIä¹Ÿä¿æŒæµç•…
- âœ… **ç”¨æˆ·ä½“éªŒ**: å®æ—¶è¿›åº¦åé¦ˆï¼Œå¯å–æ¶ˆæ“ä½œ
- âœ… **å¹¶å‘èƒ½åŠ›**: æ”¯æŒå¤šä¸ªç®—æ³•åŒæ—¶æ‰§è¡Œï¼ˆæœªæ¥æ‰©å±•ï¼‰
- âœ… **æ¶æ„ä¼˜åŒ–**: æ¸…æ™°çš„å¼‚æ­¥æ‰§è¡Œæ¨¡å¼

### 8.2 å·¥ä½œé‡ä¼°ç®—

| é˜¶æ®µ | å·¥ä½œé‡ | è¯´æ˜ |
|------|--------|------|
| Phase 1 | 0.5å¤© | è®¾è®¡å’Œæ–‡æ¡£ï¼ˆâœ… å·²å®Œæˆï¼‰ |
| Phase 2 | 1.5å¤© | å®ç°æ ¸å¿ƒç±» |
| Phase 3 | 1å¤© | ä¿®æ”¹ AlgorithmManager |
| Phase 4 | 1å¤© | é€‚é…ç®—æ³•æ¥å£ |
| Phase 5 | 0.5å¤© | é›†æˆåˆ° Coordinator |
| Phase 6 | 1å¤© | UIè¿›åº¦åé¦ˆ |
| Phase 7 | 1.5å¤© | æµ‹è¯•å’Œä¼˜åŒ– |
| **æ€»è®¡** | **7å¤©** | çº¦1.5å‘¨ |

### 8.3 ä¸‹ä¸€æ­¥è¡ŒåŠ¨

1. âœ… å®¡æŸ¥è®¾è®¡æ–‡æ¡£
2. å¼€å§‹ Phase 2ï¼šå®ç°æ ¸å¿ƒçº¿ç¨‹åŸºç¡€è®¾æ–½
3. ç¼–å†™å•å…ƒæµ‹è¯•æ¡†æ¶
4. å‡†å¤‡æ€§èƒ½æµ‹è¯•åŸºå‡†

---

## é™„å½•

### A. å‚è€ƒèµ„æ–™

- [Qt Threading Basics](https://doc.qt.io/qt-5/thread-basics.html)
- [QThread Documentation](https://doc.qt.io/qt-5/qthread.html)
- [Worker Object Pattern](https://doc.qt.io/qt-5/threads-technologies.html#worker-object)

### B. ä»£ç ç¤ºä¾‹

è¯¦è§å„é˜¶æ®µçš„ä»£ç ç‰‡æ®µã€‚

### C. æµ‹è¯•è®¡åˆ’

è¯¦è§ Phase 7ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.2 (ç¬¬äºŒè½®ä¿®å¤) ğŸ”§ğŸ”§
**åˆ›å»ºæ—¥æœŸ**: 2025-11-10
**æœ€åæ›´æ–°**: 2025-11-10
**ä½œè€…**: Claude
**çŠ¶æ€**: Phase 1 å®Œæˆ âœ…ï¼Œè®¾è®¡ç¼ºé™·å·²ä¿®å¤ âœ…âœ…

**æ›´æ–°æ—¥å¿—**:
- **v1.2** (2025-11-10): ç¬¬äºŒè½®ä¿®å¤ - é˜Ÿåˆ—ç®¡ç†ã€å–æ¶ˆé€»è¾‘ã€è¯­ä¹‰çº¦æŸã€é…ç½®åŒ–
  - ğŸ”´ ä¿®å¤é˜Ÿåˆ—åˆ†é…çš„ä¿¡å·è¿æ¥ç¼ºå£ï¼ˆé˜Ÿåˆ—ä¸Šç§»åˆ° AlgorithmManagerï¼‰
  - ğŸŸ¡ å®ç° cancelTask() å®Œæ•´é€»è¾‘ï¼ˆè¿è¡Œä¸­+æ’é˜Ÿä»»åŠ¡ï¼‰
  - ğŸŸ¡ æ˜ç¡®ä¸Šä¸‹æ–‡å¿«ç…§è¯­ä¹‰ï¼ˆæ·±æ‹·è´ç»“æ„ã€åªè¯»è®¿é—®ã€å‘½ä»¤æ¨¡å¼å†™å…¥ï¼‰
  - ğŸŸ¢ çº¿ç¨‹æ•°é…ç½®åŒ–ï¼ˆmin(idealThreadCount, 8)ï¼Œæ”¯æŒè¿è¡Œæ—¶è°ƒæ•´ï¼‰
  - ğŸ“ æ·»åŠ å†å²å‘½ä»¤é›†æˆè¯´æ˜
- **v1.1** (2025-11-10): ç¬¬ä¸€è½®ä¿®å¤ - åŸºç¡€è®¾è®¡ç¼ºé™·
  - ğŸ”´ AlgorithmTask åŒé‡é‡Šæ”¾ â†’ QSharedPointer
  - ğŸ”´ prepareContext() é‡å¤æ‰§è¡Œ â†’ åªåœ¨ä¸»çº¿ç¨‹
  - ğŸŸ¡ çº¿ç¨‹æ± æ»¡æ—¶ä»»åŠ¡ä¸¢å¤± â†’ ä»»åŠ¡é˜Ÿåˆ—
  - ğŸŸ¡ ProgressReporter æœªè®¾ç½® â†’ Worker è°ƒç”¨ setProgressReporter
  - ğŸŸ¡ AlgorithmContext å¹¶å‘è®¿é—® â†’ ä¸Šä¸‹æ–‡å¿«ç…§
- **v1.0** (2025-11-10): åˆå§‹è®¾è®¡æ–¹æ¡ˆ
