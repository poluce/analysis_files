# 热分析数据处理工具 - 四周架构设计计划

## 设计目标

本文档规划了如何在四周内完成一个工业级热分析数据处理工具的**架构设计**。最终交付一套完整的架构文档，包括领域模型、分层架构、设计模式、交互流程、接口定义等，为后续开发提供清晰的蓝图。

**设计范围**:
- 🏗️ 四层分层架构（DDD）
- 🧠 领域模型与核心概念
- 🔥 创新设计模式（双枚举、上下文驱动、统一输出）
- 🎯 交互流程与状态机
- 📐 接口设计与依赖关系
- 📊 数据流向与组件协作

**最终交付物**:
- ✅ 完整的架构设计文档（15+ 篇）
- ✅ UML 类图、时序图、状态图
- ✅ 接口定义与 API 规范
- ✅ 设计模式应用说明
- ✅ 扩展性与可测试性分析

---

## Week 1: 需求分析与领域建模

**目标**: 理解业务需求，建立领域模型，定义核心概念和业务规则

### Day 1: 需求收集与业务理解

**任务清单**:
- [ ] **业务调研**
  - 研究热分析仪器类型（TGA、DSC、ARC）
  - 理解热分析数据特征（温度、时间、测量值三元组）
  - 分析用户工作流程：导入 → 可视化 → 处理 → 分析 → 导出
  - 调研竞品软件（AKTS-Thermokinetics、TA Universal Analysis）

- [ ] **功能需求列表**
  - 数据导入（TXT、CSV、专有格式）
  - 数据可视化（多曲线、缩放、平移、交互）
  - 算法处理（微分、积分、滤波、基线校正、峰面积）
  - 撤销/重做（历史管理）
  - 项目管理（多曲线、父子关系）
  - 测量工具（质量损失、峰高、面积）

- [ ] **非功能需求**
  - 性能：支持 10,000+ 数据点流畅显示
  - 可扩展性：易于添加新算法、新仪器类型
  - 可维护性：清晰的分层架构，职责分离
  - 可测试性：核心逻辑可单元测试

**交付物**:
- ✅ 《需求规格说明书.md》
- ✅ 《用户故事与用例.md》
- ✅ 《非功能需求分析.md》

---

### Day 2-3: 领域建模与核心概念

**任务清单**:
- [ ] **领域概念识别**
  - **核心实体**: ThermalCurve（热分析曲线）
  - **值对象**: ThermalDataPoint（数据点）
  - **枚举**: InstrumentType（仪器类型）、SignalType（信号类型）、PlotStyle（图表样式）
  - **服务**: 算法服务、文件读取服务

- [ ] **双枚举分离设计** 🔥
  - **问题**: 传统软件混用 TGA/DSC/DTG，语义混乱
  - **解决方案**: 分离为 InstrumentType（仪器）+ SignalType（信号状态）
  - **优势分析**:
    - 语义清晰：仪器是硬件，信号是数据处理状态
    - 易于扩展：新增仪器或处理方法互不影响
    - 算法通用化：算法不针对特定仪器，适用于所有类型

- [ ] **数据不可变性设计**
  - **双数据结构**: rawData（原始，不可变）+ processedData（处理，可变）
  - **撤销支持**: 通过 `resetProcessedData()` 恢复到原始数据
  - **血缘追踪**: parentId 字段记录派生关系

- [ ] **曲线属性分类设计** 🆕
  - `isMainCurve`: 主曲线（数据源，不可删除）
  - `isAuxiliaryCurve`: 辅助曲线（继承父曲线 Y 轴）
  - `isStronglyBound`: 强绑定曲线（不在树中独立显示）

**交付物**:
- ✅ 《领域模型设计文档.md》
- ✅ 《双枚举分离设计说明.md》
- ✅ 《数据不可变性设计.md》
- ✅ UML 类图（领域层）

---

### Day 4-5: 算法抽象与分类

**任务清单**:
- [ ] **算法分类体系**
  - **A 类算法**: 简单算法（无交互，如微分、积分、滤波）
  - **B 类算法**: 交互算法（需要点选，如基线校正、峰面积）
  - **C 类算法**: 复杂算法（多步骤，如动力学分析）

- [ ] **算法输入类型设计**
  - `InputType::None`: 无需额外输入
  - `InputType::PointSelection`: 需要用户选点
  - `InputType::DualCurve`: 需要两条曲线
  - `InputType::MultiPoint`: 需要多个点（基线锚点）

- [ ] **算法输出类型设计**
  - `OutputType::Curve`: 输出新曲线
  - `OutputType::Marker`: 输出标注点
  - `OutputType::Region`: 输出区域（阴影填充）
  - `OutputType::ScalarValue`: 输出数值
  - `OutputType::Composite`: 混合输出

- [ ] **信号类型转换规则**
  - 微分：Raw → Derivative
  - 积分：Raw → Integrated
  - 基线校正：Raw → Baseline
  - 峰面积：Raw → PeakArea
  - 滤波：保持原信号类型

**交付物**:
- ✅ 《算法分类体系设计.md》
- ✅ 《算法抽象接口设计.md》
- ✅ 《信号类型转换规则.md》

---

### Day 6-7: Week 1 总结与评审

**任务清单**:
- [ ] **领域词汇表**
  - 编写术语定义（Glossary）
  - 中英文对照表

- [ ] **设计评审**
  - 评审领域模型是否覆盖所有业务场景
  - 检查概念是否清晰、无歧义
  - 验证扩展性（新增仪器、算法、格式）

- [ ] **设计文档汇总**
  - 整理 Week 1 所有文档
  - 创建文档索引

**Week 1 里程碑**:
- ✅ 领域模型清晰
- ✅ 核心概念定义完整
- ✅ 算法分类体系建立
- ✅ 双枚举设计完成

---

## Week 2: 分层架构与设计模式

**目标**: 设计四层架构，选择设计模式，定义接口规范

### Day 8-9: 四层架构设计

**任务清单**:
- [ ] **架构分层设计**
  - **表示层 (Presentation)**: UI 组件、控制器
  - **应用层 (Application)**: 服务、管理器、协调器
  - **领域层 (Domain)**: 核心模型、算法接口、业务规则
  - **基础设施层 (Infrastructure)**: 文件 IO、算法实现、数据库

- [ ] **依赖规则定义**
  - ✅ 上层可以依赖下层
  - ❌ 下层不能依赖上层
  - ✅ 同层之间通过接口依赖
  - ✅ 领域层不依赖任何其他层（纯业务逻辑）

- [ ] **组件职责划分**
  - **MainWindow**: 布局管理，信号转发，不包含业务逻辑
  - **ChartView**: 图表显示，交互管理，算法状态机
  - **CurveManager**: 曲线生命周期管理，活动曲线管理
  - **AlgorithmManager**: 算法注册、执行、结果处理
  - **ProjectTreeManager**: 树形结构管理，父子关系维护

- [ ] **依赖注入设计**
  - ApplicationContext 统一初始化
  - 构造函数注入依赖
  - 避免循环依赖

**交付物**:
- ✅ 《四层架构设计文档.md》
- ✅ 《组件职责矩阵.md》
- ✅ 《依赖关系图.png》（UML 包图）
- ✅ 《依赖注入设计.md》

---

### Day 10-11: 核心设计模式选择

**任务清单**:
- [ ] **命令模式 (Command Pattern)**
  - **应用场景**: 撤销/重做功能
  - **设计**: ICommand 接口（execute/undo/redo）
  - **实现**: AddCurveCommand、AlgorithmCommand、BaselineCommand
  - **优势**: 操作可逆、历史记录、宏录制（未来扩展）

- [ ] **策略模式 (Strategy Pattern)**
  - **应用场景**: 算法可插拔
  - **设计**: IThermalAlgorithm 接口
  - **优势**: 运行时切换算法、易于扩展新算法

- [ ] **观察者模式 (Observer Pattern)**
  - **应用场景**: 组件间通信
  - **设计**: Qt 信号槽机制
  - **优势**: 松耦合、响应式更新

- [ ] **单例模式 (Singleton Pattern)**
  - **应用场景**: HistoryManager、ApplicationContext
  - **设计**: 懒汉式单例（线程安全）
  - **优势**: 全局唯一实例、统一访问点

- [ ] **工厂模式 (Factory Pattern)**
  - **应用场景**: 文件读取器创建（未来扩展）
  - **设计**: FileReaderFactory
  - **优势**: 隐藏创建逻辑、根据文件类型自动选择读取器

**交付物**:
- ✅ 《设计模式应用说明.md》
- ✅ 《命令模式设计文档.md》
- ✅ 《策略模式设计文档.md》
- ✅ UML 类图（每种模式）

---

### Day 12-13: 创新设计模式 🔥

**任务清单**:
- [ ] **纯上下文驱动执行模式** 🆕
  - **问题**: 传统算法需要繁琐的参数传递
  - **解决方案**: 算法从 AlgorithmContext 拉取数据
  - **设计**:
    - AlgorithmContext: 键值对容器（值、时间戳、来源）
    - executeWithContext(AlgorithmContext*): 唯一执行接口
    - context->get<T>(key): 类型安全访问
  - **优势**:
    - ✅ 零参数传递
    - ✅ 单一数据源
    - ✅ 类型安全
    - ✅ 扩展无需修改接口

- [ ] **两阶段执行机制** 🆕
  - **问题**: 交互算法数据可能不完整时就被调用
  - **解决方案**: prepareContext() 验证数据完整性
  - **设计**:
    - 阶段 1: prepareContext() → 返回 bool（是否就绪）
    - 阶段 2: executeWithContext() → 执行计算
  - **优势**: 防止过早执行、明确状态检查

- [ ] **统一输出容器 (AlgorithmResult)** 🆕
  - **问题**: 算法输出类型多样（曲线、标注、数值、区域）
  - **解决方案**: 结构化封装所有输出类型
  - **设计**:
    - ResultType 枚举（Curve/Marker/Region/ScalarValue/Composite）
    - 专门字段：curve, markers, regions, scalarValue
    - 元数据：meta (QVariantMap)
  - **优势**: 类型安全、易于解析、可扩展

- [ ] **活动算法状态机** 🆕
  - **问题**: 用户交互流程复杂，难以管理
  - **解决方案**: ChartView 维护当前活动算法状态
  - **设计**:
    - InteractionState（Idle/WaitingForPoints/PointsCompleted/Executing）
    - ActiveAlgorithmInfo（算法名、所需点数、提示信息）
    - 自动触发：用户完成选点 → 发射 algorithmInteractionCompleted 信号
  - **优势**: 状态清晰、自动执行、可取消

**交付物**:
- ✅ 《纯上下文驱动执行模式设计.md》
- ✅ 《两阶段执行机制设计.md》
- ✅ 《统一输出容器设计.md》
- ✅ 《活动算法状态机设计.md》
- ✅ UML 状态图（状态机）

---

### Day 14: Week 2 总结与评审

**任务清单**:
- [ ] **架构评审**
  - 检查依赖方向是否符合规则
  - 验证组件职责是否单一
  - 评估扩展性和可测试性

- [ ] **设计模式评审**
  - 评审模式选择是否合理
  - 检查是否过度设计

- [ ] **设计文档汇总**
  - 整理 Week 2 所有文档
  - 更新文档索引

**Week 2 里程碑**:
- ✅ 四层架构清晰
- ✅ 设计模式选择完成
- ✅ 创新模式设计完成
- ✅ 依赖关系明确

---

## Week 3: 详细设计与交互流程

**目标**: 设计详细的接口、数据流向、交互流程、状态机

### Day 15-16: 接口设计与 API 规范

**任务清单**:
- [ ] **领域层接口**
  - `IThermalAlgorithm` 接口定义
    ```cpp
    class IThermalAlgorithm {
    public:
        virtual QString name() const = 0;
        virtual QString displayName() const = 0;
        virtual QString category() const = 0;
        virtual SignalType getOutputSignalType(SignalType input) const = 0;
        virtual AlgorithmDescriptor descriptor() const = 0;
        virtual void prepareContext(AlgorithmContext* context) = 0;
        virtual QVariant executeWithContext(AlgorithmContext* context) = 0;
        virtual InputType inputType() const = 0;
        virtual OutputType outputType() const = 0;
        virtual bool isAuxiliaryCurve() const = 0;
    };
    ```
  - `IFileReader` 接口定义
  - `ICommand` 接口定义

- [ ] **应用层接口**
  - `CurveManager` 公共 API
    - `addCurve()`, `removeCurve()`, `getCurve(id)`
    - `setActiveCurve(id)`, `getActiveCurve()`
    - 信号：`curveAdded`, `curveRemoved`, `activeCurveChanged`
  - `AlgorithmManager` 公共 API
    - `registerAlgorithm(IThermalAlgorithm*)`
    - `executeWithContext(name, AlgorithmContext*)`
    - 信号：`algorithmResultReady`
  - `ProjectTreeManager` 公共 API

- [ ] **UI 层接口**
  - `ChartView` 公共方法
    - `addCurve()`, `removeCurve()`, `clearCurves()`
    - `setInteractionMode()`, `setXAxisMode()`
    - `startAlgorithmInteraction()`, `cancelAlgorithmInteraction()`
    - `addFloatingLabel()`, `addMeasureTool()`
  - `MainWindow` 信号定义

**交付物**:
- ✅ 《接口设计规范.md》
- ✅ 《API 参考手册.md》
- ✅ UML 类图（详细接口）

---

### Day 17-18: 数据流向与组件协作

**任务清单**:
- [ ] **导入数据流设计**
  ```
  用户选择文件
    → DataImportWidget (预览)
    → TextFileReader (读取)
    → ThermalCurve (创建)
    → CurveManager (管理)
    → 信号: curveAdded
    → ├─ ProjectTreeManager (更新树)
      └─ ChartView (显示图表)
  ```

- [ ] **算法执行流设计**
  ```
  用户选择算法
    → MainWindow (菜单触发)
    → MainController::onAlgorithmRequested
    → AlgorithmCoordinator::handleAlgorithmTriggered
    → ├─ 收集参数 (如需要)
      ├─ 请求选点 (如需要)
      └─ executeAlgorithm
        → 清空上下文
        → 设置 activeCurve, params, selectedPoints
        → AlgorithmManager::executeWithContext
          ├─ prepareContext (验证数据)
          └─ executeWithContext (执行)
        → handleAlgorithmResult
        → 创建新曲线
        → 添加到 CurveManager
    → CurveManager 发出 curveAdded 信号
    → UI 更新
  ```

- [ ] **撤销/重做流设计**
  ```
  用户执行操作
    → MainController 创建 Command
    → HistoryManager::executeCommand
      → Command::execute
      → 推入 undoStack
      → 清空 redoStack

  用户点击撤销
    → MainController::onUndo
    → HistoryManager::undo
      → 从 undoStack 弹出
      → Command::undo
      → 推入 redoStack
  ```

- [ ] **活动算法交互流设计**
  ```
  用户选择基线校正
    → AlgorithmCoordinator::requestPointSelection 信号
    → ChartView::startAlgorithmInteraction
      → 状态: Idle → WaitingForPoints
      → 切换到 Pick 模式

  用户选择第 1 个点
    → ChartView::handlePointSelectionClick
      → 添加点到 m_selectedPoints
      → 提示: "已选 1/2 点"

  用户选择第 2 个点
    → ChartView::handlePointSelectionClick
      → 添加点到 m_selectedPoints
      → 检查: size >= requiredPointCount
      → 状态: WaitingForPoints → PointsCompleted
      → 发射: algorithmInteractionCompleted 信号 ⭐

  MainController 接收信号
    → AlgorithmCoordinator::handlePointSelectionResult
    → 继续执行算法
  ```

**交付物**:
- ✅ 《数据流向设计.md》
- ✅ 《组件协作流程.md》
- ✅ UML 时序图（导入流程、算法执行流程、撤销流程、交互流程）

---

### Day 19-20: 状态机与交互设计

**任务清单**:
- [ ] **ChartView 交互状态机**
  - **状态定义**:
    - `InteractionState::Idle`: 空闲状态
    - `InteractionState::WaitingForPoints`: 等待用户选点
    - `InteractionState::PointsCompleted`: 选点完成
    - `InteractionState::Executing`: 算法执行中
  - **状态转换**:
    - Idle → WaitingForPoints: 调用 startAlgorithmInteraction()
    - WaitingForPoints → PointsCompleted: 用户完成选点
    - PointsCompleted → Idle: 算法执行完成
    - Any → Idle: 调用 cancelAlgorithmInteraction()
  - **事件触发**:
    - 用户点击 → handlePointSelectionClick()
    - 检查点数 → 自动发射 algorithmInteractionCompleted

- [ ] **AlgorithmCoordinator 状态管理**
  - **PendingRequest 结构体**:
    - algorithmName: 算法名称
    - curveId: 曲线 ID
    - parameters: 已收集的参数
    - selectedPoints: 已选择的点
  - **流程编排**:
    - 参数收集 → 点选请求 → 算法执行

- [ ] **HistoryManager 状态管理**
  - **状态**:
    - canUndo: 是否可以撤销
    - canRedo: 是否可以重做
    - currentIndex: 当前位置（O(1) 查询优化）
  - **状态更新**: 每次操作后更新，发射 historyChanged 信号

**交付物**:
- ✅ 《状态机设计文档.md》
- ✅ 《交互流程设计.md》
- ✅ UML 状态图（ChartView、AlgorithmCoordinator、HistoryManager）

---

### Day 21: Week 3 总结与评审

**任务清单**:
- [ ] **接口评审**
  - 检查接口是否满足所有用例
  - 验证接口粒度是否合理
  - 评估接口的稳定性（向后兼容）

- [ ] **流程评审**
  - 验证数据流向是否清晰
  - 检查是否有循环依赖
  - 评估性能瓶颈

- [ ] **设计文档汇总**
  - 整理 Week 3 所有文档
  - 更新文档索引

**Week 3 里程碑**:
- ✅ 所有接口定义完成
- ✅ 数据流向清晰
- ✅ 交互流程完整
- ✅ 状态机设计完成

---

## Week 4: 文档完善与设计优化

**目标**: 完善设计文档，进行设计评审，优化架构，输出最终交付物

### Day 22-23: 扩展性与可测试性设计

**任务清单**:
- [ ] **扩展性设计**
  - **新增算法**: 实现 IThermalAlgorithm 接口 → 注册到 AlgorithmManager
  - **新增文件格式**: 实现 IFileReader 接口 → 注册到 FileReaderFactory
  - **新增仪器类型**: 扩展 InstrumentType 枚举 → 更新 getYAxisLabel()
  - **新增信号类型**: 扩展 SignalType 枚举 → 更新算法转换规则
  - **插件系统设计**（未来扩展）:
    - 动态加载算法插件（.dll/.so）
    - 插件元数据（名称、版本、作者、描述）
    - 插件注册 API

- [ ] **可测试性设计**
  - **依赖注入**: ApplicationContext 统一管理，易于替换 Mock 对象
  - **接口驱动**: 所有核心逻辑通过接口访问，易于 Mock
  - **纯函数设计**: 算法核心逻辑无副作用，易于单元测试
  - **测试策略**:
    - 单元测试：算法、Manager 类
    - 集成测试：数据流、信号槽
    - UI 测试：交互流程、状态机

- [ ] **性能优化设计**
  - **O(1) 查询**: HistoryManager 当前状态缓存
  - **批量更新**: QLineSeries::replace() 替代逐点添加
  - **按需更新**: 信号驱动更新，避免全局刷新
  - **内存优化**: 限制历史深度（50 步）、智能指针管理

**交付物**:
- ✅ 《扩展性设计文档.md》
- ✅ 《可测试性设计文档.md》
- ✅ 《性能优化策略.md》
- ✅ 《插件系统设计.md》（Phase 4 扩展）

---

### Day 24-25: UI/UX 设计与交互规范

**任务清单**:
- [ ] **UI 组件设计**
  - **MainWindow**: 布局设计（菜单、工具栏、停靠面板）
  - **ChartView**: 图表交互设计（缩放、平移、选点）
  - **FloatingLabel**: 浮动标签设计（拖动、缩放、锚定模式）
  - **TrapezoidMeasureTool**: 测量工具设计（端点拖动、自动吸附）
  - **DataImportWidget**: 导入对话框设计（预览、列映射）

- [ ] **交互规范**
  - **鼠标操作**:
    - 右键拖动 → 平移图表
    - Ctrl + 滚轮 → 缩放图表
    - 左键点击 → 选择曲线/选点
  - **键盘快捷键**:
    - Ctrl+Z → 撤销
    - Ctrl+Y → 重做
    - Ctrl+O → 打开文件
    - Ctrl+S → 保存项目
  - **视觉反馈**:
    - 十字光标 → Pick 模式
    - 手型光标 → 可拖动对象
    - 高亮显示 → 活动曲线

- [ ] **样式设计**
  - **颜色方案**: 曲线默认颜色序列
  - **字体**: 标签、坐标轴、图例字体大小
  - **图标**: 工具栏图标设计

**交付物**:
- ✅ 《UI 设计文档.md》
- ✅ 《交互规范.md》
- ✅ 《UI 组件库设计.md》
- ✅ UI 原型图（Mockup）

---

### Day 26: 设计评审与优化

**任务清单**:
- [ ] **架构评审**
  - 评审四层架构是否满足需求
  - 检查依赖关系是否合理
  - 验证扩展性和可维护性

- [ ] **设计模式评审**
  - 评审模式选择是否恰当
  - 检查是否过度设计或设计不足

- [ ] **接口评审**
  - 验证接口完整性
  - 检查接口粒度
  - 评估接口稳定性

- [ ] **性能评审**
  - 识别潜在性能瓶颈
  - 提出优化方案

- [ ] **风险评估**
  - 识别技术风险（Qt Charts 性能、多 Y 轴复杂度）
  - 制定缓解策略

**交付物**:
- ✅ 《架构评审报告.md》
- ✅ 《设计优化建议.md》
- ✅ 《风险评估与应对.md》

---

### Day 27-28: 最终文档整理与交付

**任务清单**:
- [ ] **核心设计文档**
  - 《CLAUDE.md》- 项目指南（架构说明、编码约定、使用指南）
  - 《01_主架构设计.md》- 四层架构总览
  - 《02_四层架构详解.md》- 各层职责与依赖关系
  - 《03_架构案例分析.md》- 典型场景分析

- [ ] **创新设计文档** 🆕
  - 《纯上下文驱动执行模式设计.md》
  - 《两阶段执行机制设计.md》
  - 《统一输出容器设计.md》
  - 《活动算法状态机设计.md》
  - 《双枚举分离设计说明.md》

- [ ] **功能设计文档**
  - 《AlgorithmContext 类设计文档.md》
  - 《AlgorithmContext 数据清单.md》（60+ 数据项）
  - 《AlgorithmResult 统一输出设计.md》
  - 《撤销重做功能实现文档.md》
  - 《曲线交互功能实现计划.md》

- [ ] **UML 图汇总**
  - 类图（领域层、应用层、表示层、基础设施层）
  - 包图（依赖关系）
  - 时序图（导入流程、算法执行流程、撤销流程、交互流程）
  - 状态图（ChartView、AlgorithmCoordinator、HistoryManager）

- [ ] **文档索引与导航**
  - 创建 `设计文档索引.md`
  - 创建文档目录结构
  - 添加交叉引用链接

- [ ] **开发路线图**
  - 《ARCHITECTURE_OPTIMIZATION_PLAN.md》- 四阶段开发路线
    - Phase 1: 命令模式和历史管理 ✅
    - Phase 2: 项目管理
    - Phase 3: 算法扩展
    - Phase 4: 高级功能

**交付物**:
- ✅ 完整的架构设计文档集（15+ 篇）
- ✅ UML 图集（10+ 个图）
- ✅ 《设计文档索引.md》
- ✅ 《开发实施指南.md》

---

## 设计文档结构

```
Analysis/
├── CLAUDE.md                              # 项目指南（总纲）
├── 设计文档索引.md                        # 文档导航
├── 设计文档/
│   ├── 01_主架构设计.md                   # 架构总览
│   ├── 02_四层架构详解.md                 # 分层设计
│   ├── 03_架构案例分析.md                 # 场景分析
│   ├── UI设计文档.md                      # UI/UX 设计
│   ├── 撤销重做功能实现文档.md             # 命令模式
│   └── 曲线交互功能实现计划.md             # 交互设计
├── 新设计文档/
│   ├── 一、MVC层次划分总览.md             # MVC 架构
│   ├── 统一初始化.md                      # 依赖注入
│   ├── 交互类.md                          # 交互组件
│   ├── 抽象算法行为类型.md                 # 算法分类
│   ├── AlgorithmContext类设计文档.md      # 上下文容器
│   ├── AlgorithmContext数据清单.md        # 数据字典
│   └── 统一输出算法_AlgorithmResult设计.md # 输出容器
├── UML图/
│   ├── 类图/
│   │   ├── 领域层类图.png
│   │   ├── 应用层类图.png
│   │   ├── 表示层类图.png
│   │   └── 基础设施层类图.png
│   ├── 时序图/
│   │   ├── 导入数据流时序图.png
│   │   ├── 算法执行流时序图.png
│   │   ├── 撤销重做时序图.png
│   │   └── 交互流程时序图.png
│   ├── 状态图/
│   │   ├── ChartView状态机.png
│   │   ├── AlgorithmCoordinator状态机.png
│   │   └── HistoryManager状态机.png
│   └── 包图/
│       └── 依赖关系包图.png
└── ARCHITECTURE_OPTIMIZATION_PLAN.md     # 开发路线图
```

---

## 设计评审检查清单

### 架构层面

- [ ] ✅ 四层架构清晰，职责分离明确
- [ ] ✅ 依赖方向符合规则（单向依赖）
- [ ] ✅ 领域层不依赖其他层（纯业务逻辑）
- [ ] ✅ 接口驱动设计，易于扩展
- [ ] ✅ 依赖注入，避免循环依赖

### 设计模式层面

- [ ] ✅ 命令模式实现撤销/重做
- [ ] ✅ 策略模式实现算法可插拔
- [ ] ✅ 观察者模式实现组件通信
- [ ] ✅ 单例模式管理全局服务
- [ ] ✅ 模式选择恰当，无过度设计

### 创新设计层面

- [ ] ✅ 双枚举分离设计清晰
- [ ] ✅ 纯上下文驱动执行模式完整
- [ ] ✅ 两阶段执行机制合理
- [ ] ✅ 统一输出容器设计完善
- [ ] ✅ 活动算法状态机逻辑清晰

### 数据流层面

- [ ] ✅ 导入数据流清晰
- [ ] ✅ 算法执行流完整
- [ ] ✅ 撤销/重做流正确
- [ ] ✅ 交互流程合理
- [ ] ✅ 信号槽连接无循环

### 扩展性层面

- [ ] ✅ 易于添加新算法
- [ ] ✅ 易于添加新文件格式
- [ ] ✅ 易于添加新仪器类型
- [ ] ✅ 易于添加新信号类型
- [ ] ✅ 插件系统架构清晰（Phase 4）

### 可测试性层面

- [ ] ✅ 核心逻辑可单元测试
- [ ] ✅ 接口易于 Mock
- [ ] ✅ 纯函数设计（算法）
- [ ] ✅ 依赖注入支持测试
- [ ] ✅ 状态管理清晰

### 性能层面

- [ ] ✅ O(1) 查询优化（HistoryManager）
- [ ] ✅ 批量更新策略（Qt Charts）
- [ ] ✅ 按需更新（信号驱动）
- [ ] ✅ 内存优化（历史深度限制）
- [ ] ✅ 无明显性能瓶颈

### 文档层面

- [ ] ✅ 所有核心概念有文档说明
- [ ] ✅ 所有设计模式有文档说明
- [ ] ✅ 所有接口有 API 文档
- [ ] ✅ 所有流程有时序图
- [ ] ✅ 文档索引清晰

---

## 总体时间分配

| 周次 | 主要任务 | 交付物数量 | 累计文档 |
|------|---------|-----------|---------|
| Week 1 | 需求分析 + 领域建模 | 7 篇文档 + 1 个类图 | 8 个 |
| Week 2 | 分层架构 + 设计模式 | 9 篇文档 + 5 个 UML 图 | 22 个 |
| Week 3 | 详细设计 + 交互流程 | 6 篇文档 + 7 个 UML 图 | 35 个 |
| Week 4 | 文档完善 + 设计评审 | 10 篇文档 + 评审报告 | 45+ 个 |

---

## 关键成功因素

### 设计原则

1. **简单性优先**: 优先选择简单的设计，避免过度设计
2. **职责单一**: 每个类/模块职责明确
3. **接口隔离**: 接口粒度合理，不强制实现不需要的方法
4. **依赖倒置**: 高层模块不依赖低层模块，都依赖抽象
5. **开闭原则**: 对扩展开放，对修改封闭

### 设计方法

1. **自顶向下**: 从业务需求出发，逐步细化到技术实现
2. **迭代设计**: 每周评审优化，不断改进
3. **文档驱动**: 先写设计文档，再实现代码
4. **评审机制**: 定期设计评审，及时发现问题

### 协作方式

1. **同行评审**: 设计文档需要同行评审
2. **跨职能讨论**: 架构师、开发、测试共同参与
3. **用户反馈**: 原型演示，收集用户反馈
4. **版本控制**: 设计文档纳入版本管理

---

## 风险管理

### 设计风险

| 风险 | 影响 | 缓解策略 |
|------|------|---------|
| 过度设计 | 复杂度增加，开发成本高 | 遵循 YAGNI 原则，优先简单设计 |
| 设计不足 | 扩展性差，后期重构成本高 | 预留扩展点，接口驱动设计 |
| 依赖循环 | 架构混乱，难以维护 | 严格依赖规则，定期检查 |
| 性能瓶颈 | 用户体验差 | 性能评审，提前优化关键路径 |

### 应对策略

- **原型验证**: 关键设计先做原型验证
- **设计评审**: 每周定期评审，及时调整
- **文档先行**: 先写设计文档，避免边做边改
- **增量设计**: 分阶段设计，避免一次性设计过多

---

## 总结

本计划将一个工业级热分析软件的**架构设计**分解为 4 周 28 天的可执行任务。按照此计划，团队可以从需求分析开始，逐步完成领域建模、分层架构、设计模式、详细设计、交互流程、文档完善等工作，最终输出一套完整的架构设计文档，为后续开发提供清晰的蓝图。

**核心价值**:
- 🏗️ **工业级架构**: 四层分层 + DDD，清晰可维护
- 🔥 **创新设计模式**: 双枚举、上下文驱动、统一输出、状态机
- 🎯 **完整设计文档**: 15+ 篇文档，10+ 个 UML 图
- 📚 **可扩展架构**: 易于添加新算法、新格式、新功能
- 🧪 **可测试设计**: 接口驱动、依赖注入、纯函数

**最终交付**:
- ✅ 15+ 篇架构设计文档
- ✅ 10+ 个 UML 图（类图、时序图、状态图、包图）
- ✅ 完整的接口定义与 API 规范
- ✅ 清晰的数据流向与组件协作流程
- ✅ 详细的扩展性与可测试性分析
- ✅ 开发实施指南与路线图

---

**文档版本**: v1.0
**创建日期**: 2025-11-11
**作者**: Claude Code
